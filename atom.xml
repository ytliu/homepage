<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Mctrain's Blog]]></title>
  <link href="http://ytliu.github.com/atom.xml" rel="self"/>
  <link href="http://ytliu.github.com/"/>
  <updated>2013-02-17T15:11:55+08:00</updated>
  <id>http://ytliu.github.com/</id>
  <author>
    <name><![CDATA[Liu Yutao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[【转】计算机的启动]]></title>
    <link href="http://ytliu.github.com/blog/2013/02/17/%5B%28zhuan-%29%5D-ji-suan-ji-de-qi-dong/"/>
    <updated>2013-02-17T14:24:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/02/17/[(zhuan-)]-ji-suan-ji-de-qi-dong</id>
    <content type="html"><![CDATA[<p>寒假回来就要开始执行新年的计划了~首先是每周的一篇blog。</p>

<p>今天看了<a href="http://www.ruanyifeng.com/blog/">阮一峰</a>最新的一篇博客<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a>，感觉写得很好，又清楚又简单。虽然自己关于计算机启动这个过程从大三OS课的时候就陆陆续续地一直有了解，但是都没有一个系统的了解，或者了解了又忘了，希望通过这次记录把这点彻底弄清楚来并且记在脑子里。另外在评论中有另外一个小哥<a href="http://www.dalei.org/">大磊</a>把他的<a href="http://www.dalei.org/linux-unix-boot-process/">博客</a>也贴出来了，写得很详细，作为阮一峰的补充吧。</p>

<hr />

<p>以下是转来的文章，中间加上了大磊的补充，也没有区分哪句话是谁说的，具体的还是看之前提到的两篇博客吧：</p>

<h4>零、boot的含义</h4>

<p>先问一个问题，&#8221;启动&#8221;用英语怎么说？</p>

<p>回答是boot。可是，boot原来的意思是靴子，&#8221;启动&#8221;与靴子有什么关系呢？ 原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：</p>

<pre><code>"pull oneself up by one's bootstraps"
</code></pre>

<p>字面意思是&#8221;拽着鞋带把自己拉起来&#8221;，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！</p>

<p>早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做&#8221;拉鞋带&#8221;，久而久之就简称为boot了。</p>

<p>计算机的整个启动过程分成四个阶段。</p>

<h4>一、第一阶段：BIOS</h4>

<p>上个世纪70年代初，&#8221;只读内存&#8221;（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-1.png" title="BIOS" alt="BIOS" /></p>

<p>这块芯片里的程序叫做&#8221;基本輸出輸入系統&#8221;（Basic Input/Output System），简称为BIOS。</p>

<h5>1.1 硬件自检</h5>

<p>BIOS中主要存放的程序包括：自诊断程序（通过读取CMOS RAM中的内容识别硬件配置，并对其进行自检和初始化）、CMOS设置程序（引导过程中，通过特殊热键启动，进行设置后，存入CMOS RAM中）、系统自动装载程序（在系统自检成功后，将磁盘相对0道0扇区上的引导程序装入内存使其运行）和主要I/O驱动程序和中断服务（BIOS和硬件直接打交道，需要加载I/O驱动程序）。</p>

<p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做&#8221;硬件自检&#8221;（Power-On Self-Test），缩写为POST。</p>

<p>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p>

<h5>1.2 启动顺序</h5>

<p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</p>

<p>这时，BIOS需要知道，&#8221;下一阶段的启动程序&#8221;具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做&#8221;启动顺序&#8221;（Boot Sequence）。</p>

<p>打开BIOS的操作界面，里面有一项就是&#8221;设定启动顺序&#8221;。</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-2.png" title="BIOS Sequence" alt="BIOS Sequence" /></p>

<h4>二、第二阶段：主引导记录</h4>

<p>BIOS按照&#8221;启动顺序&#8221;，把控制权转交给排在第一位的储存设备。即根据用户指定的引导顺序从软盘、硬盘或是可移动设备中读取启动设备的MBR，并放入指定的位置（0x7c000）内存中。</p>

<p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给&#8221;启动顺序&#8221;中的下一个设备。</p>

<p>这最前面的512个字节，就叫做&#8221;主引导记录&#8221;（Master boot record，缩写为MBR）。</p>

<h5>2.1 主引导记录的结构</h5>

<p>&#8220;主引导记录&#8221;只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p>

<p>主引导记录由三个部分组成：</p>

<pre><code>（1） 第1-446字节：调用操作系统的机器码。
（2） 第447-510字节：分区表（Partition table）。
（3） 第511-512字节：主引导记录签名（0x55和0xAA）。
</code></pre>

<p>其中，第二部分&#8221;分区表&#8221;的作用，是将硬盘分成若干个区。</p>

<h5>2.2 分区表</h5>

<p>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，&#8221;主引导记录&#8221;因此必须知道将控制权转交给哪个区。</p>

<p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做&#8221;主分区&#8221;。</p>

<p>每个主分区的16个字节，由6个部分组成：</p>

<pre><code>（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3） 第5个字节：主分区类型。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数。
</code></pre>

<p>最后的四个字节（&#8221;主分区的扇区总数&#8221;），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p>

<p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p>

<h4>三、第三阶段：硬盘启动</h4>

<p>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p>

<h5>3.1 情况A：卷引导记录</h5>

<p>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做&#8221;卷引导记录&#8221;（Volume boot record，缩写为VBR）。</p>

<p>&#8220;卷引导记录&#8221;的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p>

<h5>3.2 情况B：扩展分区和逻辑分区</h5>

<p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成&#8221;扩展分区&#8221;（Extended partition）。</p>

<p>所谓&#8221;扩展分区&#8221;，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做&#8221;逻辑分区&#8221;（logical partition）。</p>

<p>计算机先读取扩展分区的第一个扇区，叫做&#8221;扩展引导记录&#8221;（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p>

<p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p>

<p>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p>

<h5>3.3 情况C：启动管理器</h5>

<p>在这种情况下，计算机读取&#8221;主引导记录&#8221;前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的&#8221;启动管理器&#8221;（boot loader），由用户选择启动哪一个操作系统。</p>

<p>Linux环境中，目前最流行的启动管理器是Grub。</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-3.png" title="Grub" alt="Grub" /></p>

<p>对于grub而言，在MBR中的446字节的引导程序属于GRUB的开始执行程序，通过这段程序，进一步执行stage1.5或是stage2的执行程序，将在下面详细介绍执行过程。</p>

<p>其中stage1.5或是stage2便属于阶段2引导的过程了，stage2过程也是作为GRUB kernel的核心代码出现。Stage1.5过程（对于GRUB而言存在stage1.5，GRUB2则不存在）的功能很单一，主要就是为了引导stage2过程服务。由于stage2过程的代码存放在文件系统下的boot分区目录中，因此stage1.5过程就是需要提供一个文件系统的环境，而该文件系统环境需要保证系统可以找到stage2过程的文件，那么stage1.5阶段提供的文件系统需要是boot文件系统所对应的，这个在执行grub install过程中就已经确定了。stage2过程中，主要会把系统切换到保护模式，设置好C运行时环境，找到config文件（事实上就是menulist文件），如果没有找到就执行一个shell，等待用户的执行。然后的工作就变成了输入命令->解析命令->执行命令的循环中。当然该阶段引导的最终状态就是执行boot命令，将内核和initrd镜像加载进入内存中，进而将控制权转交给内核。</p>

<h4>四、第四阶段：操作系统</h4>

<p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p>

<p>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p>

<p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。</p>

<p>至此，全部启动过程完成。</p>

<hr />

<p>另外在大磊的<a href="http://www.dalei.org/linux-unix-boot-process/">博客</a>中还有许多细节部分：</p>

<h4>BIOS启动细节：</h4>

<p>a) 按下电源开关，电源就开始向主板和其它设备供电；当芯片组检测到电源已经开始稳定供电了(当然从不稳定到稳定的过程只是一瞬间的事情)，它便撤去RESET信号(如果是手工按下计算机面板上的Reset按钮来重启机器，那么松开该按钮时芯片组就会撤去RESET信号)；CPU马上就从地址FFFF:0000H 处开始执行指令，放在这里的只是一条跳转指令，跳到系统BIOS中真正的启动代码处。</p>

<p>b) 系统BIOS的启动代码首先进行POST(Power－On Self Test，加电后自检)。POST的主要检测系统中一些关键设备是否存在和能否正常工作，例如内存和显卡等设备；由于POST是最早进行的检测过程，此时显卡还没有初始化，如果系统BIOS在进行POST的过程中发现了一些致命错误，例如没有找到内存或者内存有问题(此时只会检查640K常规内存)，那么系统BIOS就会直接控制喇叭发声来报告错误，声音的长短和次数代表了错误的类型；在正常情况下，POST过程进行得非常快，几乎无法感觉到它的存在。POST结束之后就会调用其它代码来进行更完整的硬件检测。</p>

<p>c) 接下来系统BIOS将查找显卡的BIOS。前面说过，存放显卡BIOS的ROM芯片的起始地址通常设在C0000H处，系统BIOS在这个地方找到显卡BIOS之后就调用它的初始化代码，由显卡BIOS来初始化显卡。此时多数显卡都会在屏幕上显示出一些初始化信息，介绍生产厂商、图形芯片类型等内容，不过这个画面几乎是一闪而过。系统BIOS接着会查找其它设备的BIOS程序，找到之后同样要调用这些BIOS内部的初始化代码来初始化相关的设备。</p>

<p>d) 查找完所有其它设备的BIOS之后，系统BIOS将显示出它自己的启动画面，其中包括有系统BIOS的类型、序列号和版本号等内容。</p>

<p>e) 接着系统BIOS将检测和显示CPU的类型和工作频率，测试所有的RAM，并同时在屏幕上显示内存测试的进度。可以在CMOS设置中自行决定使用简单耗时少或者详细耗时多的测试方式。</p>

<p>f) 内存测试通过之后，系统BIOS将开始检测系统中安装的一些标准硬件设备，包括硬盘、CD-ROM、串口、并口和软驱等设备，另外绝大多数较新版本的系统BIOS在这一过程中还要自动检测和设置内存的定时参数、硬盘参数和访问模式等。</p>

<p>g) 标准设备检测完毕后，系统BIOS内部支持即插即用的代码将开始检测和配置系统中安装的即插即用设备。每找到一个设备之后，系统BIOS都会在屏幕上显示出设备的名称和型号等信息，同时为该设备分配中断、DMA通道和I/O端口等资源。</p>

<p>h) 到这一步为止，所有硬件都已经检测配置完毕了，多数系统BIOS会重新清屏并在屏幕上方显示出一个表格，其中概略地列出了系统中安装的各种标准硬件设备，以及它们使用的资源和一些相关工作参数。</p>

<p>i) 接下来系统BIOS将更新ESCD(Extended System Configuration Data，扩展系统配置数据)。ESCD是系统BIOS用来与操作系统交换硬件配置信息的一种手段，这些数据被存放在CMOS(一小块特殊的RAM，由主板上的电池来供电)之中。通常ESCD数据只在系统硬件配置发生改变后才会更新，所以不是每次启动机器时都能够看到“Update ESCD… Success”这样的信息。不过，某些主板的系统BIOS在保存ESCD数据时使用了与Windows 9x不相同的数据格式，于是Windows 9x在它自己的启动过程中会把ESCD数据修改成自己的格式。但在下一次启动机器时，即使硬件配置没有发生改变，系统BIOS也会把ESCD的数据格式改回来。如此循环，将会导致在每次启动机器时，系统BIOS都要更新一遍ESCD，这就是为什么有些机器在每次启动时都会显示出相关信息的原因。</p>

<p>j) ESCD更新完毕后，系统BIOS的启动代码将进行它的最后一项工作：即根据用户指定的启动顺序从软盘、硬盘或光驱启动MBR。在这个过程中会按照启动顺序顺序比较其放置MBR的位置的结尾两位是否为0xAA55，通过这种方式判断从哪个引导设备进行引导。在确定之后，将该引导设备的MBR内容读入到0x7C00[1]的位置，并再次判断其最后两位，当检测正确之后，进行阶段1的引导。</p>

<h4>EFI启动细节</h4>

<p>与传统MBR相比，GPT采用了不同的分区方式。</p>

<p>对于传统MBR，其结构主要如下：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-4.png" title="BIOS Graph" alt="BIOS Graph" /></p>

<p>上图即对上文中所述的很形象的说明，在图中看到MBR被分成三个部分，分别是：Bootloader、分别表以及Magic Number。其中Bootloader部分为stage1中被执行的起始部分。</p>

<p>相反，对于EFI系统中所采用的GPT分区方式，则采用了不同于MBR分区方式的形式，从下图中可以发现：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-5.png" title="EFI Graph" alt="EFI Graph" /></p>

<p>如上图所示，GPT分区表主要包括：保护MBR、首要GPT头、首要GPT、备用GPT、备用GPT头和磁盘数据区。保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表。首要GPT头包含了众多信息，具体内容如下：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-6.png" title="EFI Table" alt="EFI Table" /></p>

<p>分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量。分区表头还记录了这块硬盘的GUID，记录了分区表头本身的位置和大小（位置总是在LBA1）以及备份分区表头和分区表的位置和大小（在硬盘的最后）。它还存储着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否有错误，如果出错了，可以使用软件从硬盘最后的备份GPT分区表恢复整个分区表，如果备份GPT也校验错误，那么磁盘将不可用，系统拒绝启动。</p>

<p>接下来主要是128个分区表项，GPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。例如，EFI系统分区的GUID类型是{C12A7328-F81F-11D2-BA4B-00A0C93EC93B} 。接下来的16字节是该分区的唯一的GUID（这个指的是该分区本身，而之前的GUID指的是该分区的类型）。在接下来是分区其实和末尾的64位LBA编号，以及分区的名字和属性。具体结构如下表：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-7.png" title="EFI Table2" alt="EFI Table2" /></p>

<h4>MBR引导</h4>

<p>接下来开始真正的引导过程了，主要说明GRUP的引导。总体上GRUB更像是一个mini os，只不过这个mini os的作用只是加载其他的操作系统，在GRUB中包括stage1、stage1.5（可选）和stage2，其中stage1和stage1.5属于boot loader，stage2属于mini os的内核部分。GRUB中stage1过程主要位于MBR的前446字节中（对于支持GPT分区的磁盘，同样有最开始的512字节作为保护MBR，保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表，不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作），之后的64字节为硬盘的分区表，最后两个字节为MBR结束标志位（0xAA55）。</p>

<p>stage1部分占用了446字节，其代码文件是源码目录下stage1/stage1.S文件，汇编后生成一个512字节的boot.img，被写在硬盘的0面0道1扇区中，作为硬盘的MBR。stage1的工作很简单，就是加载0面0道2扇区上的512字节到0×8000，然后跳转到0×8000执行。</p>

<p>在0面0道2扇区上的512字节内容为stage1/start.S文件汇编后生成。该扇区上的内容的作用是加载stage1.5或是stage2过程，并将控制权转交。</p>

<h4>Grub引导</h4>

<p>在start过程将控制权转交后，接下来就是GRUB的核心过程了。该过程之所以区分stage1.5和stage2，主要原因是GRUB和GRUB2的区别。在GRUB2中，将stage1.5过程集成到了stage2的过程中，所以stage1.5过程仅仅是针对GRUB的。下面将会分别介绍两种GRUB版本的两种过程。</p>

<p>4.1 GRUB中stage1.5过程</p>

<p>Stage1.5过程很无辜，它的作用很单一，但是非常关键。它的主要功用就是构造一个boot分区系统对应的文件系统，这样可以通过文件系统的路径（/boot/grub/）寻找stage2过程需要的core.img，进而加载到内存中开始执行。</p>

<p>Stage1.5存在于0面0道3扇区开始的地方，并一直延续十几k字节的区域，具体的大小与相应的文件系统的大小有关（文中涉及到了0面0道1-3+x扇区，这部分扇区为保留扇区，BIOS不会放置任何数据。正因为如此如果转换到GPT分区形式，系统将不能被正确引导，如上文所示，MBR后面的扇区都被其他内容所占据）。Stage1.5过程被构建成多种不同类型，但是功能类似，下面简单介绍一下基本的stage1.5过程的文件系统。e2fs_stage1_5（针对ext2fs，可引导ext2和ext3文件系统）、fat_stage1_5（针对fat文件系统，可引导fat32和fat16）、ffs_stage1_5、jfs_stage1_5、minix_stage1_5、reiserfs_stage1_5、vstafs_stage1_5和xfs_stage1_5，这些文件被称为stage1.5过程，这些文件每个至少都在11k以上。除此之外还有两个比较特殊的文件，分别为nbgrub和pxegrub，这两个文件主要是在网络引导时使用，只是格式不同而已，他们很类似与stage2，只是需要建立网络来获取配置文件。</p>

<p>由于stage1.5过程中会涉及到多个文件系统对应的文件，因此本文中主要以ext2fs为例进行说明，其他文件系统与此类似，可以同样进行分析理解。</p>

<p>对于ext2fs文件系统，用于生成该文件系统的stage1.5过程文件（e2fs_stage1_5）的代码为stage2/fsys_ext2fs.c文件。</p>

<p>在stage2/filesys.h文件中定义了每个文件系统对外的接口，用于上层调用，作为stage2过程寻找核心代码使用，文件系统一般被定义的接口主要就是三个函数，分别是mount、read和dir函数。对应ext2fs，其定义的函数为：</p>

<h1>ifdef FSYS_EXT2FS</h1>

<h1>define FSYS_EXT2FS_NUM 1</h1>

<p>int ext2fs_mount (void);
int ext2fs_read (char <em>buf, int len);
int ext2fs_dir (char </em>dirname);</p>

<h1>else</h1>

<h1>define FSYS_EXT2FS_NUM 0</h1>

<h1>endif</h1>

<p>针对ext2fs有如上的函数名称，每个函数将具体在stage2/fsys_ext2fs.c文件中被定义，这里面没有包含任何的写的过程，对于bootloader而言仅仅读就可以完成任务了，没必要对其系统进行写操作。其中ext2fs_mount函数用于检查文件系统类型，并将superblock读入到内存中；ext2fs_read函数和ext2fs_dir函数用于对文件系统具体的操作。在stage2/fsys_ext2fs.c文件中除了需要对这三个函数的定义之外，还需要文件系统的属性的数据结构（superblock、inode和group结构，这些结构最初被定义在include/linux/ext2_fs.h文件中），通过这些数据结构描述一个文件系统。</p>

<p>如果读者有兴趣可以试着创建新的文件系统的支持，可以参照目前存在的一些文件系统的模板（实例）编写。</p>

<p>4.2 GRUB中stage2过程</p>

<p>GRUB中的核心过程也就是stage2过程了，该过程主要是在文件系统建立以后选择合适的操作系统进行加载并转交控制权，达到最后引导操作系统的目标。由于GRUB属于multi boot loader，因此在引导的时候要进行选择，选择哪种操作系统来运行。在GRUB内部主要包括两种方式，首先是从menu.list中读取显示到屏幕让用户选择，其次是通过grub-shell中定义的命令手动进行启动。本文将在后面介绍这两种方式如何运行，接下来先介绍一下stage2的具体的执行过程。</p>

<p>在上面一节中介绍过，stage1.5过程中将boot分区的文件系统加载了，之后又做了一件事情，就是将控制权转交给stage2，而stage2入口的地方就是stage2/asm.S文件。Stage2/asm.S文件属于汇编代码，主要作用是初始化C语言的运行环境，为下面执行C语言的函数做好准备，在准备好之后，将执行init_bios_info(stage2/common.c)函数。init_bios_info函数的作用是执行一些底层的函数，然后跳转到cmain执行，cmain函数位于stage2/stage2.c文件中。cmain函数内部进行一个死循环，在循环内部首先加载配置文件，显示给用户，在这同时循环一个内层循环，在内层循环中，获取配置文件中的命令，并解析执行。过程中如果没有可用的配置文件，那么进入命令行模式（enter_cmdline函数），如果找到可用的menu，那么开始执行menu的对应的内容（run_menu函数）。</p>

<p>对于enter_cmdline（stage2/stage2.c）函数，将调用find_command（stage2/cmdline.c），进而执行相应命令的函数。</p>

<p>对于run_menu（stage2/stage2.c）函数，将调用stage2/cmdline.c文件中的run_script函数，进而调用find_command，执行相应命令的函数。</p>

<p>这两种方式虽然经过了不同的过程，对用户输入的行为进行分析和处理，最终调用的函数为find_command，在该函数中顺序循环比较“输入”的命令是否与系统内部定义的相同，如果相同转到执行该函数。在这个比较的过程中包含了一个全局的数据结构为struct builtin（stage2/shared.h），由该数据结构组成了一个table类型（stage2/builtins.c），将命令与相对应的builtin结构对应一起并进行串联。下面描述一下builtin结构的定义：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">builtin</span> <span class="p">{</span>
</span><span class='line'>  <span class="cm">/* 命令名称，重要，是搜索命令时的依据*/</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/* 命令函数，重要，是搜索匹配后调用的函数*/</span>
</span><span class='line'>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span><span class='line'>  <span class="cm">/* 功能标示，一般未用到. */</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/* 简短帮助信息*/</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">short_doc</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/* 完整帮助信息*/</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">long_doc</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">builtin</span> <span class="o">*</span><span class="n">builtin_table</span><span class="p">[]</span><span class="err">；</span>
</span></code></pre></td></tr></table></div></figure>


<p>有兴趣的读者可以对上面的内容进行扩展，形成自己的命令，主要在stage2/builtins.c文件中按照预定的格式更新，并添加到builtin_table中即可。</p>

<p>在上面打开配置文件的过程中，主要是通过一些文件操作函数（被定义在stage2/disk_io.c中）完成。这些文件操作函数主要包括：grub_open、grub_read、grub_seek和grub_close等，这些函数属于grub对外的上层接口，具体的函数内部将调用前文中提到的boot分区对应的文件系统的相应的函数完成，这个过程主要是通过回调函数来完成。该过程整体思路类似于面向对象过程，通过对象操作具体的函数。关于用C语言实现面向对象的编程思路，可以参考一本书——《Object-oriented Programming with ANSI-C》。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[乔帮主传有感]]></title>
    <link href="http://ytliu.github.com/blog/2013/01/12/qiao-bang-zhu-chuan-you-gan/"/>
    <updated>2013-01-12T20:34:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/01/12/qiao-bang-zhu-chuan-you-gan</id>
    <content type="html"><![CDATA[<p>这几周花了晚上的时间把乔帮主的传记给看完了。在我的记忆中我已经很久很久（或许久到甚至都不记得）没有看过什么名人传记，或许我本身就没有资格评论别人，而且由于自己的孤陋寡闻，也从来没有什么自己所谓的偶像。从乔帮主的传记中我惊叹于原来一个人可以那么真实地出现在这个世界中，通过他的创造力改变这个世界；居然存在一个让人看起来那么“讨厌”的人却有着别人无法逃脱的魅力；通过自己的意志让真正强大的人做到自己从未想过做到原本也确实无法做到的事，用他那强大到无法抗拒的“现实扭曲力场“来改变别人甚至使自己相信原本不存在的现实；他是一个自私到不行的非主流痞子，从不会设身处地地为周围的人考虑全凭自己一厢情愿去判定事物的好坏，去赞扬别人，去不惜代价地辱骂对方，但当面对全世界时，却毫不吝啬地为她着想，甚至去赌博这个世界未来的样子；或许没有一个人能像他那样将艺术和科技如此无缝地结合，让这个社会的普通人类去感受一个由它个人，以及一个伟大的公司所创造的更高的品味，即使是在即将离开人世的时候还在专注于此。他尽自己全力经营并留下的那个公司，由他物色、培养并使之无比强大的那些富有激情和创造力的人们，必将继续为我们大众带来一件件跨时代的产品，而他的一生一世，所经历的、所遭受的、所创造的、所改变的，留给世人一个神话般的存在，所有的这些遗产，不仅伟大，而且永恒。</p>

<p>当我看完上面这段文字，我都怀疑自己是否也进入的乔帮主的”现实扭曲力场“，被他的成就所折服，甚至忽略了他的一切令人厌恶的性格抑或缺点。在看书的过程中，他的太多做法使我无法理解，甚至强烈地抵抗，但却又有另一些让我毫无迹象地被其魅力和强大所折服，以至于甚至对他的偏激、阴暗面、对身边人的残酷、强大到无与伦比的控制欲、以及极其简单却让人无法理解的二元论，都带着一种幽默的嘲弄的态度，甚至会自发地将其归为其不可或缺的成功因子。当这种人出现，我又有什么资历，又怎么忍心去批判他，还带着无法忍受的态度去看待他呢？或许我的这些所想并非被逼迫，而是完全地心甘情愿吧？我敬重他、崇拜他、信任他、感激他，感动于他之所为，并发自内心地希望他一路走好。</p>

<p>尽管如此，虽然还仅仅是作为一个挣扎在毕业路上的IT学生，一方面，我无比愉悦而满怀感激地使用乔帮主为我们带来的ipad/iphone/air/icloud&#8230;，享受着它强烈的控制欲下设计且实现的近乎完美的端到端一体化系统和服务，一方面，我又在内心深处弱弱地支持着黑客精神，支持着用户对自己所拥有的一切（包括软件）的所有权和完全自由控制权。我毫无保留地信奉着开放对这个世界带来的绝对远胜于封闭，我信奉黑客世界中的自由而不作恶，我崇尚google文化，崇尚Linux等所有开源社区文化，崇尚git等这些为开源、开放所做出贡献的软件和组织。</p>

<p>我使用苹果的产品并热衷于此，但我却又无条件地支持开放与开源，而且我确信这样的人绝对不止我一个，而应该会是千千万万，那么这又是因为什么呢？</p>

<p>就在刚才我突然冒出来一个想法，或许是一个很显然和一目了然的想法，但是我发现我却刚刚才发现它，而且为此兴奋了好一阵子就如同我发现了一个真理一般。我想尝试着解答为什么，而且我相信这是唯一合理的解释。</p>

<h4>开放 &amp; 封闭</h4>

<p>我支持开放，因为我是一个开发者，是这个计算机世界中本应该创建规则的人，当这个世界中存在的规则开放了，才能更快地让这个世界不停滞地前进，试想如果每一个希望改进某个系统的人还需要重新再实现一个这个系统的话，每时每分每秒又能有多少所谓的创新呢？当这个世界的所有规则都是封闭的，又有多少人能进入这个世界而为此奉献自身呢？或许你可以说我们有点自私，希望用自己的方便换来单纯用户的更差体验，或许你可以说开放只是为了我们这些所谓的开发者更方便而简单地进行抄袭。发自内心地说，这些并不是没有道理，而且大量存在于现实社会中，但是这种现象不会长久，甚至会很容易由于其匮乏的核心竞争力迅速埋没，而创新的力量则会比原来任何时候都强大，况且封闭并不意味着没有抄袭，只是增加了难度而已，并非杜绝；而难道你又能否认封闭的windows没有从开放的linux里面借鉴些什么东西吗？开放使得我们创新于我们自己的东西，而不是纠结于已经存在于世的技术，而封闭只能将更多的人无情地拒之门外，或是浪费大量毫无价值的时间。</p>

<p>用户更喜欢苹果的产品（至少从目前的趋势来看），因为他们并不在意谁创造了苹果，并不在意这个世界的创新与前进出现在哪个公司，由那个hacker所推动。用户只在意于体验，在意于现在拿在我手中的产品是否满足于我的喜好，是否从品味上来看更优于其它。对于他们来说，封闭系统的创新总归可以由那些封闭系统的公司解决，因为不管是哪个封闭的系统总是由个人或公司开发的，只要最后结果符合需求，其它那些被封闭系统拒之门外或浪费大量时间的开发者又会有那个用户去care呢？苹果的优势在于他知道用户的心理，而由其强势控制的端到端一体化封闭系统是一个能够走在这条道路上的最可靠而又迅速的捷径。再加上苹果公司有着其它公司所缺乏的艺术与科技融合的本领以及其对未来电子产品的前瞻能力，于是他能在用户体验这个领域做出别人所无法比拟的成功，使得竞争对手甚至无法复制。而用户在乎的不就在于体验以及产品的品味吗？</p>

<p>而对于我来说，尽管我是一个开发者，我支持开放，但我同时也是一个不择不扣的用户，从一个普通用户的心态去评判产品时，苹果总能以它无以伦比的核心竞争力打败其它公司而被我选中。我没有Cory Doctorow那样”为什么我不会买ipad“这样的决心和霸气，因为一方面苹果的产品是无害的，而我也没有对我的手机具有完全控制能力的需求，而另一方面，苹果的电脑对于开发者的友好有时甚至优于linux等其它系统，只要我没有对这个系统本身做出修改或者控制的需求。</p>

<h4>我和计算机</h4>

<p>还记得在”我的梦想“这篇博文中我提到自己以后不想做和计算机相关的事，但是渐渐地，随着看的书越来越多，我发现我却慢慢喜欢上了IT这个行业，并不是因为我发现我的技术水平提高了，而是因为我发现计算机带给我，以及我们的，不仅仅是掌握了编程能力以至于挣口饭吃不至于饿死那么简单，它带给我的，是使得我能从一个更不同的视角来看待这个世界，而从这个角度中看到的世界，是一群人们所谓的书呆子，所谓的不谙世事的geek在用自己的方式改变世界、创造世界。是啊，我之前也说过我觉得自己没有创新的能力，没有那么的雄心壮志，但是渐渐地我发现，仅仅是默默地站在旁边，关注于这些时而微小时而不可思议的改变，仰望于这些可爱的geek们为这个我所生活的世界所带来的改变时，竟也如此的让我着迷。世界在无数个不同的领域进步着，被创造着价值，而真正的价值创造者们，不是那些或许站在公司最顶端的董事们、CEO等管理者们（更确切地说他们仅仅再为他们自己以及公司创造价值），也不是那些有着诡辩的口才每天产生收入的销售者们，而是这些真正地在创造着什么的工程师，或是人们所说的杰出的程序猿们！我没有渴望说我能创造出多大的价值，但是单单想着这些竟然也能让我兴奋，难道这个不是一种不一样的感觉吗？</p>

<p>我突然发现或许我该一直做下去，就算我像梦想中所说的从40岁开始开启一个新的生活，但是也不要放弃这项事业，或者更确切地说是这种生活，以一种程序员的角度来看待这个世界，感受它的变化，感受价值的创造和创造的过程，去亲手参与到这一系列从历史长河中必定会让人们不可思议的成就，哪怕只有一点点，哪怕连所谓的一点点都没有，或者我能为我自己创造出些什么东西，以及为我周围的人。</p>

<hr />

<p>真的很惊讶而又感动于乔帮主的一生，哪怕就是感受这么一个传奇的故事也能使得全身感到兴奋，或许这就是他的魅力吧，或者一个纯粹的创造者的利益吧，无与伦比，而又无可忘怀！没有人能知道乔布斯带给我了些什么或是改变了我什么，甚至你让我说，我也说不出，道不明吧。可是那又怎样呢，我确实感觉到了自己思想中的那么一些不一样，这就够了！</p>

<p>The Journey is the Reward, 过程就是奖励，后来想想我还是蛮喜欢这句话的，比那句”那些疯狂到以为自己能够改变世界的人，才能真正改变世界“更喜欢，或许是因为它更符合我的性格吧？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Base64编码]]></title>
    <link href="http://ytliu.github.com/blog/2013/01/06/base64bian-ma/"/>
    <updated>2013-01-06T12:42:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/01/06/base64bian-ma</id>
    <content type="html"><![CDATA[<p>这两天看<a href="http://www.csc.ncsu.edu/faculty/jiang/" title="Xuxian Jiang">Jiang</a>团队对<a href="http://www.csc.ncsu.edu/faculty/jiang/AnserverBot/" title="AnserverBot Malware">AnserverBot</a>的一篇详细的<a href="http://www.csc.ncsu.edu/faculty/jiang/pubs/AnserverBot_Analysis.pdf" title="AnserverBot Analysis">分析</a>中提到AnserverBot中对很多数据（比如C&amp;C server的url等）进行了Base64编码，于是，我对这种编码进行了了解，并根据他们实现的python解码脚本，写了一个ruby的解码脚本。</p>

<h4>Base64</h4>

<p>以下资料基本上来自于<a href="http://en.wikipedia.org/wiki/Base64" title="Base64">wiki</a></p>

<p>Base64用于对字符串进行编码，并将该编码通过网络传输出去，源于<code>MIME</code>内容（如邮件）的编码，用于防止内容在网络传输中被篡改。</p>

<p>接下来会通过一个示例进行说明：</p>

<p>首先我们会有一张Base64 index table:</p>

<p><img src="http://ytliu.github.com/images/2013-01-06-1.png" title="Base64 index table" alt="Base64 index table" /></p>

<p>该表记录了0-63（即000000-111111)对应的ASCII字符。</p>

<p>然后我们有一段需要翻译的字符串，一段从<a href="http://en.wikipedia.org/wiki/Thomas_Hobbes" title="Thomas Hobbes">Thomas Hobbes</a> <a href="http://en.wikipedia.org/wiki/Leviathan_book" title="Leviathan">Leviathan</a>的引用：</p>

<blockquote><p>Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.</p></blockquote>

<p>如果将每一个字母的ASCII码作为一个8-bit的二进制数展开的话会得到一个二进制串，比如我们<code>Man</code>的三个字母<code>M</code>、<code>a</code>、<code>n</code>的ASCII码分别为<code>77</code>、<code>97</code>、<code>110</code>，展开二进制并连起来既得到<code>010011010110000101101110</code>。然后我们将这个3x8的bit分成4x6，并将每6个bit组成的数字记下来，然后通过查询前面的那张<em>Base64 index table</em>即可得到四个字符<code>TWFu</code>，也就是<code>Man</code>的Base64表达形式。如下图所示：</p>

<p><img src="http://ytliu.github.com/images/2013-01-06-2.png" title="Base64 example" alt="Base64 example" /></p>

<p>当然这张<em>Base64 index table</em>可以采用任意的字母数字顺序，而不用按照这种顺序，只要解码的时候用同一张index table就可以了。</p>

<p>还有一点要注意的是如果字符的数目不是3的倍数该怎么办？也就是说最后一个block也有可能是1个字符或者2个字符。这个时候就需要在后面再加0来进行补齐了，然后再用Base64的规则进行转换，在编码后的base64文本后加上一个或两个<code>=</code>号，代表补足的字节数。也就是说，当最后剩余1个字符时，最后一个6位的base64字节块有四位是0值，最后附加上两个等号；如果最后剩余2个字符时，最后一个6位的base64字节块有两位是0值，最后附加一个等号。</p>

<h4>Base64 decode by Ruby</h4>

<p>在ruby中可以通过<code>requite 'base64'</code>来很方便地对Base64字符串进行解码，比如在AnserverBot中，采用了<code>STvJjktoVFZ9f0PGlicqy3xK7zH8ruXdn5WwDRIeb1UmEgOhYs2NpLC4QBa6AM+/_</code>的<em>index table</em>进行编码，于是ruby程序如下所示：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># decrypt str encoded by base64</span>
</span><span class='line'><span class="c1"># ARGV[0] translate command (0 for string, 1 for file)</span>
</span><span class='line'><span class="c1"># ARGV[1] translate string or file</span>
</span><span class='line'><span class="c1"># ARGV[2] my_base64chars if exist</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;base64&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">BEGIN</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;Hello!</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">cmd</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">to_i</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="no">ARGV</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;Usage: ruby </span><span class="si">#{</span><span class="vg">$0</span><span class="si">}</span><span class="s2"> [0|1] [str|file] [base64chars]&quot;</span>
</span><span class='line'>  <span class="nb">exit</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="k">elsif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">1</span>
</span><span class='line'>  <span class="n">f</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">translate string is:</span><span class="se">\n</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std_base64chars</span> <span class="o">=</span> <span class="s2">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">!=</span> <span class="kp">nil</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="mi">2</span><span class="o">].</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">65</span><span class="p">)</span>
</span><span class='line'>  <span class="n">my_base64chars</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">my_base64chars</span>  <span class="o">=</span> <span class="s2">&quot;STvJjktoVFZ9f0PGlicqy3xK7zH8ruXdn5WwDRIeb1UmEgOhYs2NpLC4QBa6AM+/_&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">translate str according to </span><span class="si">#{</span><span class="n">my_base64chars</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">tr</span><span class="p">(</span><span class="n">my_base64chars</span><span class="p">,</span> <span class="n">std_base64chars</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">data</span> <span class="o">=</span> <span class="no">Base64</span><span class="o">.</span><span class="n">decode64</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">translated str is </span><span class="si">#{</span><span class="n">data</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">END</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Bye!&quot;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>s.tr(my_base64chars, std_base64chars)</code>是将自定义的<em>index table</em>和标准<em>index table</em>进行下转换，将字符串中的字符用标准<em>index table</em>中对应的字符进行替换，然后再通过<code>Base64.decode64(s)</code>进行解码。</p>

<p>整个过程还是很简单的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Qemu study for Android emulator]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/30/qemu-study-for-android-emulator/"/>
    <updated>2012-12-30T19:10:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/30/qemu-study-for-android-emulator</id>
    <content type="html"><![CDATA[<p>这两天看了下android emulator的源代码，位置在<code>android-src/external/qemu</code>里面，</p>

<p>编译和启动的方式很简单；</p>

<pre><code>$ ./android-configure.sh
$ make
$ export ANDROID_SDK_ROOT=/path/to/androdi-sdk
$ emulator-arm @4.2
</code></pre>

<p>你可以对源码进行修改，然后重新编译、使用，而这里主要要讲的是qemu的运行原理，资料来源是<a href="http://lists.gnu.org/archive/html/qemu-devel/2011-04/pdfhC5rVdz7U8.pdf">Qemu detailed study</a>。要说明的一点是，android emulator原理基本上是和qemu一样的，只是加了一些android specific的东西在里面。</p>

<p>首先是qemu整体流程：</p>

<p><img src="http://ytliu.github.com/images/2012-12-30-1.png" title="qemu process" alt="qemu process" /></p>

<p>首先将guest code（这里即为arm code）被TCG（Tiny Code Generator)转换成一个中间表达，然后再转换成host code（这里即为x86 code），具体来说分为两步：</p>

<ul>
<li>一个TB（Translation Block）被翻译成TCG ops</li>
<li>TCG ops被翻译成host code</li>
</ul>


<p>我们先来看下qemu的code base：</p>

<p><img src="http://ytliu.github.com/images/2012-12-30-2.png" title="qemu code base" alt="qemu code base" /></p>

<ul>
<li><code>vl.c/vl-android.c</code>: 这个是整个qemu的入口函数，主要是初始化qemu环境，然后进入<code>main_loop</code>；</li>
<li><code>target-xyz/translate.c</code>: 将guest code翻译成TCG ops；</li>
<li><code>tcg/*/tcg-target.c</code>: 将TCG ops翻译成host code；</li>
<li><code>tcg/tcg.c</code>: TCG的主函数；</li>
<li><code>cpu-exec.c</code>: 寻找下一个TB（如果没找到则调用tcg.c生成TB），然后执行。</li>
</ul>


<p>在qemu中也很好地利用了locality，即没产生一段code（TCG ops或host code），就将其存在一个code cache中，然后用LRU进行替换。</p>

<h4>运行流程（code perspective）</h4>

<p>主要分为两部分： <em>代码生成</em>和<em>代码运行</em></p>

<h5>代码生成</h5>

<p>这是主要部分，流程是这样的：</p>

<p><img src="http://ytliu.github.com/images/2012-12-30-3.png" title="qemu process from code perspective" alt="qemu process from code perspective" /></p>

<p>其中函数<code>cpu_exec()</code>相当于主要的执行循环函数，它将TB第一次初始化，在两个嵌套无限for循环中通过<code>tb_find_fast()</code>来获得host code TB，然后通过<code>tcg_qemu_tb_exec()</code>来执行相应代码。</p>

<p><code>tb_find_fast</code>会首先查看code cache中是否有TB存在了，有则直接执行<code>tcg_qemu_tb_exec()</code>，否则通过<code>tb_find_slow()</code>来查找或者生成TB，后者通过一系列调用，最后到达<code>disas_insn()</code>，该函数执行了实际的guest code到TCG ops的翻译，并将其加入TCG ops的code buffer，最后调用<code>tcg_gen_code()</code>来生成host code。</p>

<h5>代码运行</h5>

<p>代码运行就是通过<code>tcg_qem_tb_exec()</code>来实现的，可以看到，其实这是一个宏，定义在<code>tcg/tcg.h</code>里面：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define tcg_qemu_tb_exec(tb_ptr) \</span>
</span><span class='line'><span class="cp"> ((long REGPARM __attribute__ ((longcall)) (*)(void *))code_gen_prologue)(tb_ptr)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个感觉非常复杂的调用，我们知道， <code>((long REGPARM (*)(void *))</code> 是一个指向函数的指针，<code>void *</code>是它的参数，返回值为<code>long</code>；而在这里 <code>REGPARAM(*)</code>是一个GCC选项，表示函数是通过寄存器传参而不是通过栈传参的。</p>

<p>而一个数组的名字表示的是指向这个数组的基地址，于是，<code>(function_pointer) array_name</code>则会将这个基地址cast成一个函数地址。</p>

<p>另外，一个函数可以通过<code>(*pointer_to_func)(args)</code>被调用，所以<code>((long REGPARM (*)(void *))code_gen_prologue)(tc_ptr)</code>进行了一次函数调用，似乎在这里少了一个<code>*</code>号，不过其实只要测试下可以发现 <code>(*pointer_to_func)(args)</code>和<code>(pointer_to_func)(args)</code>是一样的。</p>

<p>所以上面<code>tcg_qemu_tb_exec(tb_ptr)</code>翻译的宏可以表示为一个数组<code>code_gen_prologue</code>被cast成一个函数指针，参数为<code>tc_ptr</code>，返回值为<code>long</code>（指向下一个TB），并且被调用。其实，被<code>code_gen_prologue</code>指向的函数就是<code>Function Prologue</code>，将控制流转到<code>tc_ptr</code>指向的host code开头部分。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如果明天是世界末日]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/20/ru-guo-ming-tian-shi-shi-jie-mo-ri/"/>
    <updated>2012-12-20T21:44:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/20/ru-guo-ming-tian-shi-shi-jie-mo-ri</id>
    <content type="html"><![CDATA[<p>那我觉得今天过的好没意义啊。</p>

<p>早晨起床，刷牙，洗脸，拉尿，换衣服，滑轮滑去买了两个肉包，到实验室喝了杯蜂蜜水，写了两行related work，被叫去开组会，突然华为的人进来又听海波和他们讨论了一个上午，中午吃了碗和方便面长的一样但是比方便面难吃还要17块钱的“辛拉面”，回到实验室抄了两个小时的政治课笔记，莫名其妙地又待了一个小时写了几行related work，唯一还算比较有意义的就是晚上和实验室去吃了世界末日前最后一餐，回来被小呆众闺蜜调戏了一番，然后和“追梦的贱人们”聊了会儿天&#8230;然后等下又要冒着雨会寝室，洗脸洗脚，刷牙睡觉&#8230;</p>

<p>如果明天真的是世界末日的话，那这个就算我的遗嘱了吧&#8230;</p>

<p>算了，虽然懒，但是还是再加几句吧：</p>

<blockquote><p>很高兴认识你们（你们懂的），如果还有下辈子（我还是比较相信投胎一说的），我还是希望在另外一个星球遇到你们，然后和你们一起傻一起疯，一起度过最二逼的青春岁月。<br/>然后，我还要在初中遇到小呆，经过一段暧昧的光年，传递那么几封可以用来回忆当年青涩傻逼岁月的信，然后再来上那个霸气的短信“刘宇涛先生，要不我们不谈了，直接结婚吧”，再然后，度过一段充满思念的异地恋，最终在一起，每周都能见个面，开启个“相亲相爱”模式，或者偶尔听你哭一哭，安静地看着你流泪，然后来个强有力的男人的拥抱&#8230;<br/>至于读书嘛~就不读那么认真啦，多享受享受生活，把自己想做的事不管有钱没钱有时间没时间都一股脑儿挤出时间来做掉，省的又来个世界末日啥的。<br/>世界太危险，读博要谨慎啊&#8230;</p></blockquote>


<p>好了，就这些吧，让暴风雨来的更猛烈些，把这一切都冲毁吧，包括我以上那些无聊的YY&#8230;</p>

<p>还是回去早点洗洗睡了吧》》》</p>

<blockquote><p>就算世界没了，那又关我鸟事呢啦啦啦》》》</p></blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Linker]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/15/dynamic-linker/"/>
    <updated>2012-12-15T13:03:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/15/dynamic-linker</id>
    <content type="html"><![CDATA[<p>在了解dynamic linker之前，得先对ELF文件有一个初步的了解：</p>

<p>在<a href="http://www.jollen.org/blog/2006/12/enabling_dynamic_loader_1.html" title="elf">jollen</a>的博客中有一断对ELF Session的表格:</p>

<p><img src="http://ytliu.github.com/images/2012-12-09-1.png" title="elf section" alt="elf section" /></p>

<p>很有参考价值。其中将会涉及到的sections有<em>.got</em>, <em>.plt</em>, <em>.interp</em>。</p>

<p>另外在<a href="http://www.bottomupcs.com/" title="computer science from bottom up">Computer Science from the Bottom Up</a>中有一章对dynamic linker进行了详细的说明。</p>

<p>以下的内容很多来自于该文档和俞甲子的《程序员的自我修养》一书第七章。</p>

<p>问题的产生是这样子的：当我们使用一段shared library的时候，它并没有指定说一定要把相应的代码放在哪个内存地址，而是由dynamic linker根据当前内存情况选择一段最合适的内存区域用于放置相应的code和data。那么dynamic linker是怎么做的呢？我们举一个很简单的例子来说明；</p>

<p>首先，我们编写并编译一段动态链接库lib.c, lib.h：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;lib.h&quot;;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;in dynamic lib, i is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">Char</span> <span class="o">*</span><span class="n">dylib</span> <span class="o">=</span> <span class="s">&quot;Test Dynamic Linker String&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后将其编译为动态连接库libtest.so</p>

<pre><code>$ gcc -fPIC -shared -o libtest.so lib.c
</code></pre>

<p>这里 &#8220;-shared&#8221;表示产生共享对象，&#8221;-fPIC&#8221;表示地址无关代码，这在后面会说。</p>

<p>然后我们编写一段程序dytest.c来利用libtest.so:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;lib.h&quot;;</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dylib</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dylib</span><span class="p">);</span>
</span><span class='line'>    <span class="n">test</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后对其进行编译：</p>

<pre><code>$ gcc -o dytest dytest.c ./libtest.so
$ ./dytest
Hello, Test Dynamic Linker String
in dynamic lib, i is 5
</code></pre>

<p>就这么一段简单的测试代码中，动态链接是怎么完成的呢？它和静态链接有什么不同呢？</p>

<p>在静态链接中，整个程序只有一个可执行文件，在这个可执行文件中，所有变量和函数的地址都已经固定好了（这是由linker在链接时从静态链接的文件中读出来并进行地址重定位），而在动态链接中，这些地址并不会进行地址重定位。那么，链接器怎么知道一个地址是静态符号还是动态符号呢？其实在我们编译dytest的时候也将libtest.so加进去进行编译了，而在libtest.so中保存了完整的符号信息，从而linker可以知道该符号是一个动态符号。</p>

<p>既然动态链接库主要用于共享，那么有一个问题：共享对象在编译时不应该假设自己在进程虚拟地址空间中的位置。一种解决的方法是采用“装载时重定位”，但是这样有一个缺点，因为它要在程序装载时对指令部分进行修改，所以就无法使得指令部分在多个进程中共享，这样就失去了共享库的优势，另一种就是地址无关代码，它的基本想法就是把指令中那些需要修改的部分分离出来，和数据放在一起。</p>

<p>我们把地址引用分为4个部分</p>

<ul>
<li>模块内部函数调用</li>
<li>模块内部数据访问</li>
<li>模块外部数据访问</li>
<li>模块外部函数调用</li>
</ul>


<p>第一种情况应该是最简单的，因为在模块内部函数与调用者的位置是相对的，可以采取相对地址调用。</p>

<p>第二种情况同样采用相对地址的访问，这里有一个trick，就是如何得到数据地址和当前地址的相对值，俞子甲的书中介绍了一种方法(7.3节)。另外，在处理共享库的全局变量的时候，编译器都把它当作定义在其它模块的全局变量，相当于后面讲的类型三，使用GOT表。</p>

<p>第三种情况就复杂一点了，因为它要等到装载时才能决定。这里就要用到GOT（Global Offset Table）表了，ELF在数据段中建立一个指向相关地址的指针数组。对于数据变量a，在GOT表中有一个4bytes的地址项与之对应，在程序装载时，链接器会找到这个变量的地址，并将该项进行修改。</p>

<p>第四种情况和第三种类似，只是地址为函数地址。</p>

<p>其实还有第五中情况，就是模块间的全局变量，比如下面这个例子：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">extern</span> <span class="kt">int</span> <span class="n">global</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">global</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果一个定义在共享模块内部的全局变量，编译器并不知道它是否会被其它模块使用，所以当前编译器在遇到这种全局变量的时候都会把其当做定义在其它模块中的全局变量，即上面的第三种情况，使用GOT表进行访问。</p>

<p>这里还要注意一点的是，在产生地址无关代码的时候参数-fpic和-fPIC的区别，-fpic产生的代码相对较小，而且较快，但是对于一些硬件平台有一些限制。另外，它也可以被用在可执行代码上，这时，就被称为PIE（using -fPIE or -fpie）。</p>

<p>这里需要澄清的一点是，对于一个共享库lib.so来说，它在不同的进程中都有自己独立的副本，而在同个进程不同线程中则是共享的。而对于多进程共享全局变量使用的是“共享数据段”，而多线程访问不同全局变量则被称为“线程私有存储”。</p>

<p>还有，对于数据段的绝对地址引用，可以用到装载时重定位的方法来解决，即对于共享对象来说，如果数据段中有绝对地址引用，如static int *p = &amp;a，编译器和链接器会产生一个重定位表，当动态链接器装载共享对象时若发现有重定位入口，则对其进行重定位。</p>

<h4>延迟绑定（PLT）</h4>

<p>在动态链接的程序开始运行的时候都会通过动态链接器寻找并装载共享对象，但是有些函数其实可能并不会被调用。为了增加性能，会采用一种被称为PLT（Procedure Linkage Table）的方式，它的基本思想就是当函数第一次被用到时才进行绑定。它采用了一些很精巧的指令来完成:</p>

<p>每个外部函数都有一个在PLT对应的项（bar@plt)</p>

<pre><code>bar@plt:
jmp *(bar@GOT)
push n
push moduleID
jmp _dl_runtime_resolve
</code></pre>

<p>在这里第一条指令跳转到bar在GOT中的项，该项中的初始地址即为这里第二条指令（push n）的地址，相当于没有效果，然后将bar的信息和其所在模块的信息压入栈，最后调用_dl_runtim_resolve将bar真正对的地址填入到bar@GOT中，当下次真正调用bar的时候就会跳转到真正的函数地址，并返回到调用者，而不会回到<em>push n</em>的地址了。</p>

<p>ELF将GOT分成了两个表“.got&#8221;和&#8221;.got.plt&#8221;, &#8220;.got&#8221;用来保存全局变量引用地址，&#8221;.got.plt&#8221;用来保存函数引用的地址，在&#8221;.got.plt&#8221;中前三项是有特殊意义的：</p>

<ul>
<li>第一项保存&#8221;.dynamic&#8221;段的地址，这个段描述了本模块动态链接相关的信息；</li>
<li>第二项保存的是本模块的ID；</li>
<li>第三项保存的是_dl_runtime_resolve()的地址。</li>
</ul>


<p>而&#8221;.got.plt&#8221;的其余项分别对应每个外部函数的引用。</p>

<h4>动态链接相关结构</h4>

<p>在动态链接的情况下，在装载完可执行文件之后，操作系统会将控制权转交给动态链接器，动态链接器的路径在&#8221;.interp&#8221;下指定。</p>

<p>和动态链接相关的段比如说：</p>

<h5>.dynamic</h5>

<p>动态链接器中最重要的结构就是&#8221;.dynamic&#8221;段，它就像动态链接下ELF文件的”文件头“。</p>

<h5>.dynsym</h5>

<p>&#8220;.dynsym&#8221;段是为了表示模块间动态链接相关符号的导入导出关系的，当然，和&#8221;.symtab&#8221;段类似，它也需要一些辅助的表，如&#8221;.dynstr&#8221;动态符号字符串表，&#8221;.hash&#8221;符号哈希表。</p>

<h5>动态链接重定位表</h5>

<p>&#8220;rel.dyn&#8221;和&#8221;rel.plt&#8221;相当于静态链接中的&#8221;rel.data&#8221;和&#8221;rel.text&#8221;。&#8221;rel.dyn&#8221;是对数据引用的修正，它所修正的位置即&#8221;.got&#8221;以及数据段，而&#8221;.rel.plt&#8221;则是对函数引用的修正，即&#8221;.got.plt&#8221;段。</p>

<h4>动态链接的步骤和实现</h4>

<p>主要分为三步：</p>

<h5>动态链接器自举</h5>

<p>这里有两个条件：</p>

<ul>
<li>本身不可以依赖于其它任何共享对象</li>
<li>本身所需要的全局和静态变量的重定位工作由其本身完成——即“自举”</li>
</ul>


<h5>装载共享变量</h5>

<p>从全局符号表中开始寻找其所依赖的共享变量，即&#8221;.dynamic&#8221;段中一个DT_NEEDED类型，将里面提到的所有共享对象的名字放入一个装载集合中，然后从集合中一个个读取共享变量名字，找到相对应的文件，读取里面的ELF文件头和&#8221;.dynamic&#8221;段，然后将相应的代码段和数据段映射到其地址空间中，并递归地做这件事。所以当所有共享变量都被装载进来后，全局符号表里面将包含所有动态链接所需要的符号。</p>

<h4>重定向和初始化</h4>

<p>装载完成后，链接器开始重新遍历可执行文件和每个共享对象的重定向表，将其GOT/PLT中需要重定向的进行修正，然后就将控制权转交给程序的入口了。由此，动态链接也就完成了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ASLR in android]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/09/aslr-in-android/"/>
    <updated>2012-12-09T11:07:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/09/aslr-in-android</id>
    <content type="html"><![CDATA[<p>这两篇看了两篇文章分析<a href="https://blog.duosecurity.com/2012/02/a-look-at-aslr-in-android-ice-cream-sandwich-4-0/" title="asli in 4.0">aslr in androi4.0</a>和<a href="https://blog.duosecurity.com/2012/07/exploit-mitigations-in-android-jelly-bean-4-1/" title="aslr in 4.1">android 4.1</a>，觉得蛮有趣的，这里简单介绍下。</p>

<h3>ASLR with Liux Kernel</h3>

<p>首先介绍下linux中的ASLR，ASLR可以对任意内存进行随机化：</p>

<ul>
<li>stack：The userspace stack mapping set up by the kernel during exec(2) should be sufficiently randomized. Stack randomization is performed by the randomize_stack_top() function.</li>
<li>Heap：The heap location returned by the brk(2) system call when a program is first exec’ed should be randomized. Heap randomization is performed by the arch_randomize_brk() function.</li>
<li>Libs and mmap：After NX was introduced, static library mapping led to the popularity of ret-to-libc and more generic ret-to-lib attacks. The location of libraries and other mmap’ed regions should be randomized.</li>
<li>Exec：Even if you’re randomized the mapping of all the shared libaries that an executable uses, you still need to randomize the location of the executable itself when it is mapped into the address space. Otherwise, the executable mapping can be used as a source for ROP gadgets.</li>
<li>Linker：On most Linux systems, the ld.so dynamic linker provided by glibc can self-relocate itself, so its mapping is randomized. However, as we’ll see, this isn’t the case for all linkers.</li>
<li>VDSO(Virtual Dynamically-linked Shared Object)：an executable mapping of a virtual shared library provided by the kernel for syscall transitions. However, most Android devices run on the ARM architecture, which doesn’t use a VDSO.</li>
</ul>


<h3>ASLR in Android 2.x</h3>

<p>在Android 2.x开始，唯一对ASLR支持的是stack（这可以通过多次查看/proc/pid/maps来发现），其通过load_elf_binary()函数调用randomize_stack_top()来实现：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#ifndef STACK\_RND\_MASK</span>
</span><span class='line'><span class="cp">#define STACK\_RND\_MASK (0x7ff &gt;&gt; (PAGE\_SHIFT - 12)) </span><span class="cm">/* 8MB of VA */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">randomize</span><span class="err">\</span><span class="n">_stack</span><span class="err">\</span><span class="n">_top</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack</span><span class="err">\</span><span class="n">_top</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">random_variable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_RANDOMIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>              <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">ADDR_NO_RANDOMIZE</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">random_variable</span> <span class="o">=</span> <span class="n">get_random_int</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">STACK_RND_MASK</span><span class="p">;</span>
</span><span class='line'>            <span class="n">random_variable</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'><span class="cp">#ifdef CONFIG\_STACK\_GROWSUP</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack</span><span class="err">\</span><span class="n">_top</span><span class="p">)</span> <span class="o">+</span> <span class="n">random_variable</span><span class="p">;</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack</span><span class="err">\</span><span class="n">_top</span><span class="p">)</span> <span class="o">-</span> <span class="n">random_variable</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>ASLR in Android 4.0</h3>

<p>而在4.0，即其所谓的支持ASLR的版本上，其实ASLR也仅仅增加了对libc等一些shared libraries进行了随机化，而对于heap, executable和linker还是static的。</p>

<p>对于heap的随机化来说，可以通过</p>

<pre><code>echo 2 &gt; /proc/sys/kernel/randomize_va_space
</code></pre>

<p>来开启。</p>

<p>而对于executable的随机化，由于大部分的binary没有加GCC的-pie -fPIE选项，所以编译出来的是EXEC，而不是DYN这种shared object file，因此不是PIE（Position Independent Executable），所以没有办法随机化；</p>

<p>同样的linker也没有做到ASLR。</p>

<h3>ASLR in Android 4.1</h3>

<p>终于，在4.1 Jelly Bean中，Android终于支持了所有内存的ASLR。在第二个对4.1ASLR介绍中，作者列出了从Android 1.5开始用到的安全加强机制：</p>

<h5>Android 1.5+</h5>

<ul>
<li>ProPolice to prevent stack buffer overruns (-fstack-protector)</li>
<li>safe_iop to reduce integer overflows</li>
<li>Extensions to OpenBSD dlmalloc to prevent double free() vulnerabilities and to prevent chunk consolidation attacks. Chunk consolidation attacks are a common way to exploit heap corruption.</li>
<li>OpenBSD calloc to prevent integer overflows during memory allocation</li>
</ul>


<h5>Android 2.3+</h5>

<ul>
<li>Format string vulnerability protections (-Wformat-security -Werror=format-security)</li>
<li>Hardware-based No eXecute (NX) to prevent code execution on the stack and heap</li>
<li>Linux mmap_min_addr to mitigate null pointer dereference privilege escalation (further enhanced in Android 4.1)</li>
</ul>


<h5>Android 4.0+</h5>

<ul>
<li>Address Space Layout Randomization (ASLR) to randomize key locations in memory</li>
</ul>


<h5>Android 4.1+</h5>

<ul>
<li>PIE (Position Independent Executable) support</li>
<li>Read-only relocations / immediate binding (-Wl,-z,relro -Wl,-z,now)</li>
<li>dmesg_restrict enabled (avoid leaking kernel addresses)</li>
<li>kptr_restrict enabled (avoid leaking kernel addresses)</li>
</ul>


<p>在Android 4.1中，基本上所有binary都被编译和连接成了PIE模式（可以通过readelf查看其Type）。所以，相比于4.0，4.1对Heap，executable和linker都提供了ASLR的支持。</p>

<p>另外，4.1还增加了几个小的安全加强机制：</p>

<ul>
<li>大部分系统binary都添加了RELRO和BIND_NOW的编译flag，起作用主要是将GOT表设置成只读，防止之前出现过的<a href="http://jon.oberheide.org/files/bsides11-dontrootrobots.pdf" title="don't root robot">Gingerbreak</a>攻击。</li>
<li>另外，对dmesg_restrict / kptr_restrict的sysctl的利用，有效防止了一些低权限的用户从dmesg/klogctl中读取一些敏感信息，或者读取一些kernel内存中的敏感数据（比如很多/proc下的接口）。</li>
</ul>


<h3>What&#8217;s next</h3>

<p>之后作者还提到一些还需要继续努力的事：</p>

<ul>
<li>ASLR的弱点 - 32-bit，容易破解</li>
<li>一些安全的libc调用，比如FORTIFY_SOURCE</li>
<li>PaX Hardening，虽然很多不适合手机，但是也可以cherry pick一些啦</li>
<li>MAC/RBAC，其实这个现在也已经有了，比如SEAndroid&#8230;</li>
<li>Mandatory Code Signing，向IPhone学习吧</li>
</ul>


<p>另外，作者还提到一个Zygote的问题，为了性能问题，现在Android上所有的进程都是Zygote fork出来的，也就是说很多的地址空间在fork出来后是固定不变的，这样也就出现了一种可能性：a malicious app on a victim’s device leaks address mappings from its own process off to an attacker to assist in exploiting another process (eg. the browser) that might have higher privilege or valuable data.</p>

<p>当然，作者认为这种场景可能性比较小，所以还不算一个大问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[get root in my android]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/08/get-root-in-my-android/"/>
    <updated>2012-12-08T16:28:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/08/get-root-in-my-android</id>
    <content type="html"><![CDATA[<p>首先申明，这其实并不是一篇android root教程，因为我并没有用什么exploit的方法，也没有用CWM等这些第三方ROM，而是该了ASOP，然后把它刷到机子上，然后对其进行所谓的root，装了一个dSploit和busybox。</p>

<p>具体的做法是这样的：</p>

<ul>
<li>更新到ASOP的最新版 - 4.2.4</li>
<li>lunch full-maguro, make</li>
<li>fastboot to smartphone</li>
<li>把手机连到电脑上，通过adb shell上去，进入su模式</li>
<li>通过<a href="http://www.cypherpunk.at/2011/10/08/manual-rooting-android-on-linux-2/" title="manual rooting">这里</a>的方法进行root</li>
</ul>


<p>即：</p>

<ul>
<li>mount -o remount,rw /dev/block/&#8230;/system /system</li>
<li>mv path/to/modified/su /system/xbin/su</li>
<li>mount -o remount,ro /dev/block/&#8230;/system /system</li>
</ul>


<p>但是发现失败了，我怀疑是su这个文件不兼容，于是，我想了一个更贱的方法：</p>

<ul>
<li>把ASOP代码中的/system/extras/su/su.c该掉，把检查的部分全部去掉</li>
<li>然后刷机</li>
</ul>


<p>这样就直接root了！不过这只能用于我的测试机啦，正常的手机千万不敢那么做，太危险了！</p>

<hr />

<p>另外，我用了两款软件，<a href="https://github.com/evilsocket/dsploit" title="dsploit">dSploit</a>和<a href="github.com/mwrlabs/mercury" title="mercury">Mercury</a>，而且都有源码，准备之后两周研究下，学习下android编程和如何进行penetration</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[connect smartphone to android emulator]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/01/connect-smartphone-to-android-emulator/"/>
    <updated>2012-12-01T15:37:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/01/connect-smartphone-to-android-emulator</id>
    <content type="html"><![CDATA[<p>这两天碰到一个难题，如何让手机中的某应用程序通过网络连接PC中的android emulator里面的服务。</p>

<p>即我在emulator里面开启了一个服务，该服务通过socket监听2012端口，那么在我的手机中，如何通过socket连接到这个服务中，也就是说，我的IP要设为什么，端口号要设为什么？</p>

<p>这个问题在于PC为emulator分配了一个端口号（这里为5554），所以在PC中可以很方便地和emulator进行交互，但是emulator并没有一个对外可见的IP地址。</p>

<p>在<a href="http://stackoverflow.com,%20stackoverflow">stackoverflow</a>上查了好久，有一个说<a href="http://stackoverflow.com/questions/7108326/how-can-we-change-the-ip-of-android-emulator">如何连接两个emulator的</a>，还有一个<a href="http://stackoverflow.com/questions/7108326/how-can-we-change-the-ip-of-android-emulator">介绍了一个非常复杂但经过我的测试有效的方法</a>。这里简单介绍一下：</p>

<h3>两个emulator相连</h3>

<p>为了两个emulator能进行网络相连，首先必须满足一下三个条件：</p>

<ul>
<li>A为PC</li>
<li>B为运行在A中的一个emulator，端口为5554</li>
<li>C为运行在A中的另一个emulator，端口为5556</li>
</ul>


<p>是不是很废话&#8230;好了，进入正题，我们要做的就是一下三步：</p>

<p>在B中起一个server，可以让C进行连接</p>

<pre><code>B listening on 10.0.2.15:80
</code></pre>

<p>telnet到B的console里面对端口进行重定向：</p>

<pre><code>$ telnet localhost 5554
# redir add tcp:8080:90
</code></pre>

<p>在C中连接10.0.2.2:8080就可以和B进行交互了。</p>

<p>这里补充一下，你如果进入adb shell在里面查看自己的IP会发现其为10.0.2.15，其通过10.0.2.2和PC进行连接。redir相当于将到达PC的8080端口的信息全部重定向到5554端口emulator的80端口。这样就完成而来emulator之间的连接了。</p>

<hr />

<h3>手机和emulator相连</h3>

<p>照理来说按照上面的说法，手机和emulator的连接应该也很简单，只需要将手机连接到PC的ip加上一个端口P1，然后将P1重定向到emulator中server监听的端口P2就可以了。</p>

<p>但是显示总是残酷的，包括redir和adb forwarding（功能似乎和redir是一样的）都只能将PC自己向端口P中写的信息forward到emulator里面的端口，而不能把其它地方从端口进来的forward。</p>

<p>于是在<a href="http://stackoverflow.com/questions/7108326/how-can-we-change-the-ip-of-android-emulator%20question">这个问题</a>的回答中提到一种方法，在中间再加一个proxy，接下来我来介绍下这种方法：</p>

<p>这是现在的框架：</p>

<p><img src="http://ytliu.github.com/images/2012-12-01-1.png" title="framework of smartphone and emulator" alt="framework" /></p>

<p>原理和两个模拟器相连很像，但是中间加了一个proxy：</p>

<ul>
<li>首先在emulator中server监听2012端口</li>
<li>在PC上通过<em>adb forward</em>命令将PC上的2012端口forward到emulator中的2012端口（<em>adb forward tcp:2012 tcp:2012</em>）</li>
<li>在proxy中将从外面来的2013端口forward到2012端口</li>
<li>而在手机端则直接向PC的2013端口发送数据</li>
</ul>


<p>经过尝试这样是可行的。</p>

<hr />

<h3>tap/tun</h3>

<p>虽然说上面的方法是可行的，但是并没有很好地解决这个问题，因为如果是通过这种方法，则我的emulator没开启一个server，都要起一个相应的proxy，这样就显得很废。有没有什么一劳永逸的方法呢？</p>

<p>听斌哥说之前他在配qemu的时候通过tap/tun的技术来配置qemu的网络，于是我也尝试着配置tap/tun，不过虽然已经将其在PC中启动好了，但是由于对其原理还是不清楚，所以还是没有搞明白要如何使得emulator有一个自己独立的对外可见的IP，这块内容可能会等自己完全搞明白了再写吧。</p>

<p>这里推荐下wikibook中对qemu networking的配置：</p>

<p>http://en.wikibooks.org/wiki/QEMU/Networking</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ISF见闻与收获]]></title>
    <link href="http://ytliu.github.com/blog/2012/11/25/isfjian-wen-yu-shou-huo/"/>
    <updated>2012-11-25T13:03:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/11/25/isfjian-wen-yu-shou-huo</id>
    <content type="html"><![CDATA[<p>11月22-23日两天参加了<a href="http://isf.cisrg.org/%20ISF2012">ISF2012</a>，作为一个刚刚涉入安全领域的我来说实在是收获太多，很有必要进行个比较详细的总结。</p>

<p>我想自己在这两天最大的收获在于认识了<a href="http://www.claudxiao.net/%20ClaudXiao">Claud Xiao</a>，第一天中午吃饭的时候，当发现一起聊了很久的坐在旁边吃饭的竟然是Claud的时候我瞬间就由一种穿越的感觉，前几天还在疯狂地浏览和学习他的博客，突然发现这个人就坐在我对面。他和我们讲了很多包括业界和学术界的关于安全方面的经历和事情，讲的很平易近人，而且非常的实在。这两天包括和他的聊天，还有他对很多问题的看法，甚至让我觉得他应该在安全领域做了好久了，而最后一个晚上吃饭的时候问他才知道他竟然只比我大了一岁！唉。。。差距啊。。。作为一个学术界和工业界两头都要兼顾的人，真的很不容易吧，而他对于学习新的事物又是那么的渴望而又充满激情，实在是钦佩。在这里真的很推荐他的<a href="http://www.claudxiao.net/%20IClaud">博客</a>，这几天从那里学到好多东西。</p>

<p>还有在这两天与交大的gossip组和港中文的两个博士（sbark和茗坤）也聊了很多，发现他们在代码的静态和动态分析这块领域真的专的蛮深的，和他们一起聊这块东西感觉很多时候我们都插不上话，而只是默默地倾听和学习。和他们的聊天中发现他们对于这方面的东西如数家珍，能够非常融会贯通地聊，而很多东西在我看来听起来很熟悉，但是却时常不能将人与事物，名称和做的东西联系起来，实在是惭愧。</p>

<p>另外还见到了Seak江海客，真的是一个很有性格的boss，背着一个改造过的超大的登山包，操作着巨大的笔记本工作站，还在下面垫两块“水冷”装置，而且还有无时不刻的工作状态，感觉非常的潇洒和陶醉。还有会议的组织者Billy，真的是一个非常感性的人，充满激情，而且为人豪爽。让我感觉在他们安天的团队里一定是非常的惬意的。</p>

<p>当然了，还听了好多精彩的演讲，Seak、360的赵武、武大的玉如&#8230;这里简单地介绍下我都学到了哪些东西吧，当然了有一个最遗憾的事就是没有听到Claud的演讲，竟然被万恶地调到了周五的上午，太可惜了，估计只能看看slide了。</p>

<hr />

<h4>11月22日</h4>

<p>降速的发动机 —— 安全设备第三方AV引擎开发者的反思 by Seak</p>

<p>其实这个更像是Seak从反病毒厂商的角度出发的一篇反思的文章，讲的非常的好，而且很实在。他从“我们做了什么”、“我们仿佛为你做了这件事”、“我们拒绝做哪些”、“我们给你找了这些麻烦”、“我知道你不知道我知道的事”这几点出发，提出AV领域冗长和保守这么一点，并且和我们分享了许多现在杀毒厂商的许多做法，比如我们似乎很熟悉其实却并不了解的包过滤、云查杀、多线程支持、脱壳功能、对照扫描、行为分析等一系列话题，非常有收获。</p>

<p>而且我觉得Seak在之后的问答环节中对提问者的回答也非常的有条理和清晰，而且很实在，并不会有什么夸夸其谈，真的是一个大牛风范啊~</p>

<hr />

<p>未知感知——安全领域不可回避的挑战 by 武大</p>

<p>这个是由武大的梁博士和玉如两个人做的talk，主要是介绍他们之前和现在做的一些工作，我比较感兴趣的是玉如讲的对于android的研究，特别是他提到的LBE，这个公司之前我们都没有关注过，而似乎和我们关系很大，而且听Claud说这个属于一个高帅富团队，做的东西真的是蛮不错的，我向他们要了一份LBE最初版本的apk想来研究看看。从代码入手会深入很多吧。</p>

<hr />

<p>智能电话和平板电脑的信息安全现状以及对策</p>

<p>这个本来是由日本的西本逸郎来说的，后来他有事情没来，就由以为很和蔼的爷爷代替了，说的主要是日本相关的一些和智能相关的话题，比如他提到的恐怖事件（开发者机器被控制，应用程序自动窃取用户隐私数据；或者远程控制在bbs上发布恐怖信息）等，之后还提到了现实生活中和智能相关的话题和需求，比如（个人不希望携带多台设备；企业希望实现系统云计算化）等等。讲的还是比较泛，没有学到太多的东西，就当了解下异国文化吧。</p>

<hr />

<p>中国网站安全状况和解决方案 by 360赵武</p>

<p>这个报告讲的还是很有意思的，发现360的人其实还是做了挺多东西的，而且让我了解到目前网站这个市场上的一些黑幕和现状。我觉得他有一句话讲的很有道理，他说对于现在的网站或者企业来说，安全不是他们的硬需求！大家都知道现在网络非常危险，可是如果我连盈利都还没有开始盈利，又有谁会真正去care安全呢？</p>

<p>而现在网站面临这一系列的危险，比如网站勒索, 中国站长不懂技术，不懂安全，只会赚钱，网站管理员拥有一切，除了他的网站，还有一系列的攻击：挂马、篡改、黑链、后门、DDoS、钓鱼…而这些安全隐患由于一些主要矛盾的存在：</p>

<ul>
<li>巨大需求 - 高昂的成本</li>
<li>安全技能需求 - 网站业务发展重点</li>
<li>安全产品形式 - 网站需求</li>
</ul>


<p>使得现在的安全真的很不好做。</p>

<p>后来赵老师还提到他觉得现在互联网最大的软肋在于DNS，虽然我对此不是很赞同，不过DNS确实很危险，非常容易被攻击者所利用。</p>

<hr />

<h4>11月23日</h4>

<p>非常遗憾上午没去，所以没有听到Sbark和Claud的演讲，下午的演讲听起来没有第一天那么有意思，就没有做太多的笔记了。</p>

<hr />

<p>这两天的会开下来，让我真真切切感受到自己对于安全这一块还是多么的不了解，还有太多的东西需要去学习。</p>

<p>我现在希望自己从Claud还没写完的一本书开始，从静态和动态分析开始学习，学着去对malware进行分析，学习ded/smali/wireshark/metasploit等分析和追踪工具，把一些比较理论的东西在现实中进行尝试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Partition Explaination]]></title>
    <link href="http://ytliu.github.com/blog/2012/11/12/android-partition-explaination/"/>
    <updated>2012-11-12T21:16:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/11/12/android-partition-explaination</id>
    <content type="html"><![CDATA[<p>这两天看了AndroidForums上的一个Thread，主要是介绍Android Partition的，感觉写的非常好，很有必要做个简单的笔记。</p>

<p>具体的信息在以下两个链接地址中：</p>

<p>http://androidforums.com/evo-4g-all-things-root/278898-android-partitions-kernels-explained.html</p>

<p>http://androidforums.com/evo-4g-all-things-root/279261-more-information-about-android-partitions.html</p>

<p>这个thread由两个人来写，<a href="http://androidforums.com/members/novox77.html">novox77</a>主要介绍了下android中partition的大概组织结构，<a href="http://androidforums.com/members/akazabam.html">akazabam</a>则详细地介绍了android partition的内部机制和原理，以及如何利用其来将application从RAM中移到sdcard上。</p>

<p>以下做一些节选和注释吧：</p>

<hr />

<h4>Android partitions, kernels explained</h4>

<pre><code>Here are the standard partitions on an Android phone:

/misc     - not sure what this is for.
/boot     - bootloader, kernel
/recovery - holds the recovery program (either clockworkmod or RA recovery for a rooted Evo)
/system   - operating system goes here: Android, Sense, boot animation, Sprint crapware, busybox, etc
/cache    - cached data from OS usage
/data     - user applications, data, settings, etc.

The below partitions are not android-specific. They are tied to the hardware of the phone, but the kernel may have code allowing Android to interact with said hardware.

/radio - the phone's radio firmware, controls cellular, data, GPS, bluetooth.
/wimax - firmware for Sprint's flavor of 4G, WiMax.

During the rooting process, a critical piece of the process is disabling a security system built into the bootloader that protects these partitions 
from accidental (or intentional) modification. This is what's referred to as "unlocking NAND." 
The security system can be set to active or inactive. S-ON means the security is in place (NAND locked). 
S-OFF means the security is off (NAND unlocked). When S-OFF, you have the ability to modify all partitions. 
With S-ON, you only have write access to /cache and /data. Everything else is read-only.
</code></pre>

<p>也就是说root的过程就是NAND unlock，使得partition可以被任意修改。否则你只能修改/cache和/data文件夹，而不能修改更为关键的/system</p>

<pre><code>When you flash a custom ROM, that ROM typically includes a kernel and an OS. That means the /boot and /system partitions will be modified at a minimum.
</code></pre>

<p>在这里作者把kernel和OS区别开来，在我看来，它这里的kernel主要是一些boot的信息，而OS则指framework和传统意义上的kernel？</p>

<pre><code>When you do a factory reset (AKA: wipe, hard reset, factory wipe, etc.), you are erasing the /data and /cache partitions. 
Note that a factory reset does NOT put your phone back to its factory state from an OS standpoint. 
If you've upgraded to froyo, you will stay on froyo, because the OS lives in /system, and that is not touched during a factory reset. 
</code></pre>

<p>所以所谓的&#8221;factory reset&#8221;并不是真正意义上的reset，而是&#8221;data reset&#8221;。只有root了才有可能做到真正的reset吧？</p>

<pre><code>The SD card can also be partitioned to include a section dedicated to storing user apps. To create the partition, your SD card needs to be formatted. 
</code></pre>

<p>这个会在后来akazabam的文章中详细的描述。</p>

<pre><code>Onto kernels....
</code></pre>

<p>之后novox77扯了点关于kernel的东西，这里就不讲了，具体的可以看原贴。</p>

<hr />

<h4>More information about Android partitions</h4>

<h5>The Basics</h5>

<pre><code>Linux/UNIX type systems have one top level file structure. The top level is called root, and is designated by /. 
There are no drive letters, and the files and folders under / are not necessarily all stored in the same physical location. 

From this point on, the root of the file system will just be referred to as /. There really isn't much under / by itself. 
It's generally a small partition. In order to use other partitions, Android must make these partitions available under /. 
There is a special directory called /dev. In order to use partitions found in /dev, the system must mount them under /. 
</code></pre>

<p>也就是说，不过我们mount哪一个设备，它都把mount point作为它自己文件系统的root，即&#8221;/&#8221;。</p>

<h5>Mounting</h5>

<pre><code>There are two very important conclusions:
1) The system mounts and unmounts partitions at boot and shutdown. 
If you pull the battery out while the system is running or use a poorly written app to reboot the phone, partitions are still mounted, 
and if the system is writing to them, you could easily corrupt something. 
Granted, sometimes this is necessary if the phone becomes unresponsive. It's more likely to be a problem if repeatedly done.
2) Ever wonder why you cannot access the sdcard while the phone is connected to a computer as a disk drive? 
It's because the computer is mounting the sdcard partition so that you can see it there. What does that mean? 
It means Windows, Linux, etc. (whatever OS you have on your computer) has direct access to that physical media. 
No two operating systems can have direct control over physical media at the same time. It would result in massive data corruption. 
You may be wondering how it's possible to share drives or partitions in the networking world. 
You can do so because the Computer that has the physical media is still the only host that can physically read and write to the media. 
Sharing of the data is done at a much higher level and is controlled by the operating system.
</code></pre>

<p>第一点告诉我们，不能随便插拔电池，做多了会有问题的。第二点解释了为什么通常我们在把手机插到电脑上时在手机上就没办法访问sdcard上的数据了：因为这时候sdcard被mount在了电脑上，而一个设备不可能被同时mount在两个系统上。</p>

<h5>Mount Options</h5>

<pre><code>Linux based systems have a file called fstab. That file is a mapping of physical partitions and their mountpoints, 
along with options it needs to know when mounting said partitions. It uses this file to mount partitions at boot time. 
So, the fact that you don't have to mount /system, /boot, /data, etc. yourself is because the system does it for you. 
</code></pre>

<p>这段话解释了我们linux系统上的fstab，系统在启动的时候会自动在这个文件中查找需要mount的设备和mountpoint，并自动帮我们mount了该mount的东西。</p>

<pre><code>The partition mounted as /data is mounted as rw. It has to be, otherwise the system would be all but unusable. 
You wouldn't be able to install apps, change settings, etc. 
Do not confuse this with file permissions. That is a different discussion for a different time, but at least understand this - 
file and directories have certain permissions that allow the file owner, the group the file owner belongs to, 
and everyone else specific access to said file. 
The point is that a partition must be mounted as rw in order for write permissions to work. 
If you have permission to write to a file on a partition, but it is mounted as ro, it will not work.
</code></pre>

<p>这个区分了mount option和file permission之间的关系。这是两种不同的限制方式，mount option是针对整个文件系统的，而file permission只针对一个文件或是文件夹。也就是说，即使你某个文件有write权限，如果整个文件系统的mount option是ro，那么文件也是不可写的。</p>

<h5>The System Partition</h5>

<pre><code>The partition mounted as /system is automatically mounted as read only. It's like this because, even with root 
(the unlocked ability to make changes to the partition mounted as /system) it's dangerous to make changes there 
if you do not know what you are doing. When you flash a ROM from recovery, it wipes that partition, and writes new contents to it. 
Recovery scripts, however, are smart enough to mount this partition in rw mode. 
If you are going to make changes to /system while booted up in Android, you must have /system mounted as rw. 
Otherwise, you will just get permission errors even thought you have root level permissions.
</code></pre>

<p>所以说在android系统中，/system分区是默认mount为ro的，对于那种刷机的程序它可以通过某些tricky的手段将其设为rw模式，然后将里面的数据覆盖掉。</p>

<pre><code>To do this, you must remount the partition under /system as rw. There are many ways of doing this. 
All of them are system-wide. What that means is, if you use an app to remount /system as rw, 
the entire system and any other app will see it such until you reboot the phone or remount it as ro. 
Root explorer, for example, has an option in the top right corner to mount whatever file system you are currently browsing 
as either rw or ro depending on what it's currently mounted as. Basically, it toggles between rw and ro. 
There is also an app in the marketplace called "Mount /system (rw /ro)", which will do that as well if you don't have root explorer. 
Let's look at it in a little more detail, though.
</code></pre>

<p>一般来说，如果你要将/system分区remount成rw的话，一般是要有root权限的，上文中说有一个app叫&#8221;Mount /system (rw /ro)&#8221;的不要root explorer，这个我没有搞太清楚。</p>

<pre><code>Should you want to remount the partition mounted under /system as rw using the command line from a terminal emulator, you would run this:

$ su mount -o remount,rw -t yaffs2 /dev/block/mtdblock4 /system
</code></pre>

<p>这里解释下几个参数：</p>

<pre><code>-o is the option used to specify certain special mount options. 
a comma separated list following -o are the options you want to specify for mounting.

remount means that the file system you are mounting is already mounted, and you want to specify some other options. 

rw means that you want /system to be mounted in read/write mode. 

-t yaffs2 is the filesystem type of the partition. 

/dev/block/mtdblock4 is the logical location of the partition itself under /dev as previously explained. 

/system is the location under / where the files belonging to the mtdblock4 partition will be made accessible. 
</code></pre>

<p>当用户可以用root权限的账户在模拟器上执行完以上操作，这/system分区就被remount了。这个root权限是指你前面的su，或者某个可以运行root用户的app。</p>

<h5>Current Mounts</h5>

<pre><code>To see how /system is currently mounted:

$ mount | grep /system

You will see something like:

/dev/block/mtdblock4 /system yaffs2 ro 0 0

Having an understanding of how this works will help you determine ways of saving space and making the most of your available storage. 
The three major partitions are /data, /system, and /cache. A majority of your 1 GB of internal storage is used by these. 
The partitions sizes are set when the partitions are created. By default, this is how they are partitioned:

/system – 350 MB
/data – 430 MB
/cache – 160 MB

As you can see, you only have 430 MB for apps and data. That’s less than half of the advertised space. 
There are numerous apps on the market that will display the free space available on each partition, 
but it can be done from the command line as well by typing this:

$ df -h

You will probably notice that both /system and /cache have a lot of free space. As it turns out, 
most of that free space rarely gets used, and cannot be used by you for apps, at all. It’s wasted space. 
Cache, of course, will show mostly free space, but it’s necessary for things like OTAs, which will download to that directory. 
It does need to be somewhat large, but not that big. In any case, there are ways of having more space available than just 430 MB. 
The best place to start is a2sd.
</code></pre>

<p>现在的系统中，如果我们有1G的内存，那么它会将大于一半的分给/system和/cache分区，而真正给应用程序使用的只有很少的一部分。而大部分时候我们是不需要那么多分区的。那么怎么办呢，接下来介绍的a2sd可以部分地解决这些个问题：</p>

<h5>A2sd, Apps2sd, and File System Types</h5>

<pre><code>With all of this knowledge in mind, you can probably get a better understanding of how something like a2sd works. 
A2sd is a system devised to move all installed applications to the sdcard. This is by no means the same thing as the built-in froyo apps2sd.
</code></pre>

<p>说白了，a2sd就是将一些应用程序移到sdcard上，而不要占用少量的/data分区，但是它和froyo内置的apps2sd又有很大的区别：</p>

<pre><code>With Froyo apps2sd:
The developer of a certain app specify that it is allowed to be moved to the sdcard.
Even when it is, if the app has widgets, those widgets will not be available once the app is on the sdcard. 
Why? Because the sdcard is unmounted once the phone is connected to a computer as a disk drive. 
If widgets belonging to such an app were on the homescreen at that time, they would stop working. 
Google designed Android to avoid such a case by just making those widgets unavailable.
</code></pre>

<p>如果我们把一部分应用通过apps2sd移动到sdcard上，有时候是会有问题的，比如如果这个app有widgets，那么如果我们把手机连接到电脑上，这个时候sdcard就被mount到电脑上了，但那些widgets还在屏幕中，这样就会有问题。为了防止这些问题，google会直接将那些个widgets禁掉。</p>

<pre><code>Only a part of the app is moved, not the entire thing. 
If you've ever looked at at an app that has been moved to the sdcard in manage applications, 
you will see that it still is taking up space on internal storage (in /data). 
The reason this happens goes back to file system types.
</code></pre>

<p>另一个更关键的问题是用apps2sd只能将应用的一部分移到sdcard上，而很大一部分会留下来，这是有文件系统类型决定的：</p>

<pre><code>Linux based systems have a certain number of file system types that it can use. 
Windows has its own as well. The sdcard needs to be formatted in a file system that is basically universal. 
This means that no matter what kind of computer you plug the phone into, plus the phone itself, 
you need to be able to view/modify the contents of the card. That file system is fat32. 
Both Linux and Windows can view/modify said contents. BUT, Linux (Android) can't execute anything off of a fat32 partition. 
Its use of it is somewhat limited. That being said, Android cannot move an entire app to the sdcard in its stock condition, 
as it would be moving it to a fat32 file system, where it would not be able to execute it.
</code></pre>

<p>因为一个手机上的sdcard可能会被mount在不同的系统中（比如windows, mac, linux），所以sdcard上的文件系统必须得足够universal。所以sdcard的文件系统一般是fat32，因为它可以被linux和windows都看到，但它有一个很大的限制就是不能再上面运行任何东西。也就是说应用程序运行的部分是不能被移到sdcard上的，否则它就无法被运行了。</p>

<pre><code>A2sd has none of these issues, and gets around them in a fairly creative way. 
The sdcard, in stock state, has one partition, which is this fat32 partition. 
You still need a majority of the card to have this fat32 partition for the purpose of using it normally, 
but a2sd must use a partition type that is native to Linux. 
So, the first thing you must do to use a2sd is partition the card into two separate partitions. 
This can be done in recovery. Once it is done partitioning, it formats the two partitions using a particular file system. 
The bigger partition, which the user will continue to see as /sdcard and keep all of there data, remains fat32. 
The smaller partition (usually made between 512 MB and 1 GB) is formatted in the ext3 file system. 
This ext3 file system type is native to Linux. What does this mean? 
It means that Android can use that partition on the sdcard the exact same way it could internal storage.
</code></pre>

<p>a2sd的原理是这样的，它将sdcard分成了两个区，一个比较大的继续当fat32用，存放正常数据，另一个将其格式化为ext3格式，就可以达到所谓的&#8221;native to linux&#8221;了。</p>

<pre><code>Doesn't Android have to mount this new ext3 partition just like it does internal storage partitions and the normal fat32 sdcard partition? 
Why, yes it does. It mounts the partition just like any other partition, but it makes the mount point /system/sd. 
Once you've created the ext3 partition, you can browse /system/sd. It will look just like a directory in internal storage, 
but since it's a mountpoint, when you view it, you're looking on the sdcard, just in the smaller, ext3 partition. 
Having done this, you've basically fooled the system into thinking you have more internal storage. 
The issue is that Android will look for apps in two main places - /data/app and /system/app. 
if you just stuck an apk (Android application) in /system/sd, Android system would never find it, as it will never look there. 
For those interested in seeing how the sdcard partitions are mounted, run these two commands:

$ mount | grep /sdcard
$ mount | grep /system/sd

The output for /system/sd, for example, looks like:

/dev/block/mmcblk0p2 on /system/sd type ext3 (rw,noatime,nodiratime,errors=continue,data=writeb ack)

Both of those commands, though, will show how the fat32 sdcard partition is mounted (/mnt/sdcard) and 
how the ext3 sdcard partition is mounted (/system/sd). As you can see, mmcblk0p2 is the ext partition, 
while the majority of the card (the fat32 partition) is mmcblk0p1. 
Another quick important point is that /system/sd is mounted as rw so that you can make changes. 
Remember this - if a partition is mounted as ro (/system) but a directory under it is used as a mountpoint (/system/sd) 
you will still be able to write to whatever is mounted under that second directory as long as the partition is mounted as rw. 
That being said, you can leave /system mounted as ro, and still always make changes to /system/sd.
</code></pre>

<p>所以，sdcard被分出来的那个区被mount在了/system/sd上，虽然/system是ro模式的，但并不影响它下面的子目录是可写的。但是有一个问题，android一般是在/data/app和/system/app中查找有没有应用，我们将其mount到/system/sd上就算有应用也不能被发现啊？</p>

<pre><code>The first thing a2sd does is move all applications from /data/app and /data/app-secure to /system/sd/app and /system/sd/app-secure. 
Remember that with just this step, the system would not see apps anymore. At this point, a2sd makes use of something called a symlink. 
a2sd removes the /data/app and /data/app-secure directories, then creates symlinks (shortcuts) called /data/app and /data/app-secure 
that point to directories in /system/sd for apps. This means that the system will continue to look in /data/app and /data/app-secure for apps, 
but will be directed to /system/sd. Basically, the system doesn't care where files actually are. 
It only cares that it can find them where it knows to look.
</code></pre>

<p>这里就用了symbol link的方式将/data/app和/system/app链接到/system/sd/app和/system/sd/app-secure上，这样就解决了上面说的问题了。</p>

<pre><code>A2sd can also be used to move dalvik cache to the sdcard. It does this in exactly the same manner as moving apps. 
Dalvik cache is normally stored in /data/dalvik-cache. A2sd creates a directory in /system/sd for dalvik-cache, 
then creates a /data/dalvik-cache symlink that points to the real location.
</code></pre>

<p>同样也可以用同样的方法将dalvik-cache移到sdcard上。</p>

<pre><code>As dalvik cache is stored in /data by default, it takes up your usable storage, needlessly. 
That is why it can be moved to the sdcard ext3 partition. If you choose to, though, it can also be moved to the /cache partition. 
/cache is normally just unused space on internal storage that is way bigger than it needs to be. 
Thus, dalvik cache can be moved there instead, too. The idea is the same, but it doesn't use symlinks. 
It does some creative work with the mount command to make the system look there for it. 
</code></pre>

<p>dalvik-cache也可以被移到/cache里面，虽然cache需要留一些空间，但是当前系统留的大于它需要的。而且移到/cache里就不需要用symbolic-link了。</p>

<h5>Other Space Saving Options</h5>

<pre><code>Some people do not want to use a2sd, as they do not have good enough sdcards and are not interested in buying a new one. 
A2sd will not work well with a slower card, such as the one that comes stock with the Evo. 
However, it is possible to reclaim some of the unusable internal storage. 
If you remember, /data, /system, and /cache make up a majority of your internal storage. They can be resized with this mod. 
</code></pre>

<p>很显然，将app移到sdcard上必然会减慢app的运行速度，特别是如果你的sdcard很弱的话。不过把一些程序从/data移到/system或/cache倒是一个可行的方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[getSystemService() in android]]></title>
    <link href="http://ytliu.github.com/blog/2012/11/11/getsystemservice-in-android/"/>
    <updated>2012-11-11T20:18:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/11/11/getsystemservice-in-android</id>
    <content type="html"><![CDATA[<p>在之前研究了那么久的bindService()这个API，一直没搞清楚一个问题：</p>

<p>为什么我看到的基本上都是和AMS相关的代码，而之前所学到说如果application要和service打交道都是需要通过ServiceManager获得某个service的binder才可以。那么AMS和ServiceManager到底是什么关系呢？如果AMS是通过ServiceManager获得的service binder，那么相关的代码又是在哪里呢？</p>

<p>这个问题困扰了我很久，直到我看到一个<a href="http://blog.csdn.net/windskier/article/details/6625883" title="杜文涛的专栏">博客</a>，我才发现其实我把一个很重要的概念混起来了：</p>

<p>Android中主要通过2种方法来获得service binder：</p>

<ul>
<li>通过一些API如bindService，来获得application service的binder。因为app service都是直接和AMS注册的，AMS运行在system_server进程；</li>
<li>通过ServiceManager.getService(String Descriptor)来获得Service Manager管理的service的binder，ServiceManager运行在servicemanager进程。</li>
</ul>


<p>也就是说，尼玛bindService只是用来bind application level的service！！！</p>

<p>而我们更在意的system service应该是由ServiceManager.getService()来获得的！！！</p>

<p>发现这个问题之后我整个人都有些凌乱了。。。不过静下来想想其实自己从bindService这里入手也学到很多东西，也就不纠结了！</p>

<p>那么现在的问题是，应用程序到底是如何获得system service的binder的？</p>

<p>在这个问题的探索过程初期，我又一次惊奇地发现android.os.ServiceManager竟然是@hide的！！！！</p>

<p>尼玛hide的啊！！！也就是如果不是和framework一起编译的话是找不到的啊！我在网上看到一个很无语的<a href="http://www.oschina.net/question/54100_32232?sort=time" title="隐藏类的使用">解决方案</a>，但是，我还是不知道应用程序到底是怎么调用system service的啊？总不可能每个人都懂得什么变态的“隐藏类的使用”吧？</p>

<p>后来不知道是怎么回事，我突然发现在android里面竟然有一个API叫getSystemService()！我问了下乃正，他竟然和我说“你们干嘛不问我，这不是很显然的吗？应用里面就是调用这个获得system service的啊”！尼玛伤不起啊，一个没写过android应用程序的还要研究android framework的人伤不起啊！！</p>

<hr />

<h3>getSystemService()</h3>

<p>好了，还是言归正传吧，到底getSystemService()是如何得到system service的呢？其实这个也没有想象的那么好理解。而且我查了下网上的资料，大部分还是讲ServiceManager.getService()是如何得到system service的，而基本上都没有涉及到getSystemService()是怎么和ServiceManager.getService()搭上关系的。</p>

<p>于是经过一番研究，我终于搞清楚了这里面所涉及的种种“复杂而又充满基情”的关系，请听我娓娓道来：</p>

<hr />

<p>在一个月黑风高的夜晚，一个郁郁不得志的少年Activity调用了一个具有扭转乾坤概率的大API&#8212;getSystemService()。</p>

<p>算了，没有写小说的潜质。。。还是老实点正常写着吧。。。早点写完早点洗洗睡吧。。。</p>

<p>在调用Activity.getSystemService()之后，就进入ContextImpl.getSystemService()。</p>

<p>至于是怎么进来的，其实也很简单，Activity继承ContextThemeWrapper，再继承ContextWrapper。里面会调用mBase.getSystemService()。这个mBase是一个ContextImpl实例变量，于是就调到了。</p>

<p>于是在ContextImpl.getSystemService()是这样的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="n">Object</span> <span class="nf">getSystemService</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">ServiceFetcher</span> <span class="n">fetcher</span> <span class="o">=</span> <span class="n">SYSTEM_SERVICE_MAP</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">fetcher</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">fetcher</span><span class="o">.</span><span class="na">getService</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>话说这个SYSTEM_SERVICE_MAP是怎么来的呢？这就要扯得远点了：</p>

<p>在每个Activity启动的时候都要运行一大段的static的代码（在android.app.ContextImpl.java）里面：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">registerService</span><span class="o">(</span><span class="n">ACCESSIBILITY_SERVICE</span><span class="o">,</span> <span class="k">new</span> <span class="n">ServiceFetcher</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getService</span><span class="o">(</span><span class="n">ContextImpl</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">AccessibilityManager</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}});</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">registerService</span><span class="o">(</span><span class="n">ACCOUNT_SERVICE</span><span class="o">,</span> <span class="k">new</span> <span class="n">ServiceFetcher</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="kd">public</span> <span class="n">Object</span> <span class="nf">createService</span><span class="o">(</span><span class="n">ContextImpl</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">IBinder</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ServiceManager</span><span class="o">.</span><span class="na">getService</span><span class="o">(</span><span class="n">ACCOUNT_SERVICE</span><span class="o">);</span>
</span><span class='line'>      <span class="n">IAccountManager</span> <span class="n">service</span> <span class="o">=</span> <span class="n">IAccountManager</span><span class="o">.</span><span class="na">Stub</span><span class="o">.</span><span class="na">asInterface</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="k">new</span> <span class="nf">AccountManager</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="n">service</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}});</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">registerService</span><span class="o">(</span><span class="n">ACTIVITY_SERVICE</span><span class="o">,</span> <span class="k">new</span> <span class="n">ServiceFetcher</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="kd">public</span> <span class="n">Object</span> <span class="nf">createService</span><span class="o">(</span><span class="n">ContextImpl</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="k">new</span> <span class="nf">ActivityManager</span><span class="o">(</span><span class="n">ctx</span><span class="o">.</span><span class="na">getOuterContext</span><span class="o">(),</span> <span class="n">ctx</span><span class="o">.</span><span class="na">mMainThread</span><span class="o">.</span><span class="na">getHandler</span><span class="o">());</span>
</span><span class='line'>      <span class="o">}});</span>
</span><span class='line'>
</span><span class='line'>    <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>它会在自己的SYSTEM_SERVICE_MAP为每一个系统服务注册一个ServiceFetcher的类，在这个类中，大部分的服务为重写一个函数叫<em>createService(ContextImpl)</em>，这个方法之后会用到，现在只需要知道我们从SYSTEM_SERVICE_MAP获得了某个服务的ServiceFetcher对象fetcher，并通过fetcher.getService(this)获得了该服务的对象。</p>

<p>fetcher.getService(ContextImpl):</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Object</span> <span class="nf">getService</span><span class="o">(</span><span class="n">ContextImpl</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">mServiceCache</span><span class="o">;</span>
</span><span class='line'>    <span class="n">Object</span> <span class="n">service</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">synchronized</span> <span class="o">(</span><span class="n">cache</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="c1">// Initialize the cache vector on first access.</span>
</span><span class='line'>      <span class="c1">// At this point sNextPerContextServiceCacheIndex</span>
</span><span class='line'>      <span class="c1">// is the number of potential services that are</span>
</span><span class='line'>      <span class="c1">// cached per-Context.</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sNextPerContextServiceCacheIndex</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">cache</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">service</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">mContextCacheIndex</span><span class="o">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">service</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">service</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="n">service</span> <span class="o">=</span> <span class="n">createService</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
</span><span class='line'>  <span class="n">cache</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">mContextCacheIndex</span><span class="o">,</span> <span class="n">service</span><span class="o">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">service</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>也就是说每个Activity都有一个mServiceCache，它cache了所有用到的service的ServiceFetcher类。如果hit了，那么直接返回该对象，否则会调用这个fetcher的createService()方法，这也就是我们刚才提到的每一个ServiceFetcher在注册的时候会重写的那个方法。</p>

<p>可以看到，大部分重写的方式都是类似于这样的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Object</span> <span class="nf">createService</span><span class="o">(</span><span class="n">ContextImpl</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">IBinder</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ServiceManager</span><span class="o">.</span><span class="na">getService</span><span class="o">(</span><span class="n">XXX_SERVICE</span><span class="o">);</span>
</span><span class='line'>    <span class="n">IXXXManager</span> <span class="n">service</span> <span class="o">=</span> <span class="n">IXXXManager</span><span class="o">.</span><span class="na">Stub</span><span class="o">.</span><span class="na">asInterface</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">XXXManager</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="n">service</span><span class="o">);</span>
</span><span class='line'><span class="o">}});</span>
</span></code></pre></td></tr></table></div></figure>


<p>于是乎，getSystemService()就在这里和ServiceManager.getService()无缝地结合在了一起！</p>

<hr />

<p>对于ServiceManager.getService()，在网上有很多关于它的说明和讨论，这里推荐其中两篇：</p>

<p>在<a href="http://blog.csdn.net/Luoshengyang" title="老罗的android之旅">老罗</a>的博客中两篇，</p>

<p>第一篇是<a href="http://blog.csdn.net/luoshengyang/article/details/6642463" title="java API">这篇文章</a>，主要介绍了怎么从java里面的ServiceManager.getService()开始的流程；</p>

<p>还有一篇是<a href="http://blog.csdn.net/luoshengyang/article/details/6633311" title="getService">这篇文章</a>，深入介绍了在C++和driver层是如何调用getService的</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Parcel object in android]]></title>
    <link href="http://ytliu.github.com/blog/2012/11/03/parcel-object-in-android/"/>
    <updated>2012-11-03T21:42:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/11/03/parcel-object-in-android</id>
    <content type="html"><![CDATA[<p>还记得之前被Android Framework里面的那个Parcel类搞得很摸不清头脑，这次为了完成一个任务把它彻底理了一遍，终于弄清楚了很多。</p>

<p>要做的事是这样子的：我有一个经过Parcel封装过的数据data，我需要通过socket把它发送到远程的一个进程中去进行处理，再返回一个Parcel对象reply。</p>

<p>首先在做这个之前我们先来看下Parcel在android中的用法和实现：</p>

<h5>用法</h5>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="nf">sayHello</span><span class="o">(</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">message</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">RemoteException</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Parcel</span> <span class="n">_data</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Parcel</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
</span><span class='line'>    <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Parcel</span> <span class="n">_reply</span> <span class="o">=</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Parcel</span><span class="o">.</span><span class="na">obtain</span><span class="o">();</span>
</span><span class='line'>    <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">_result</span><span class="o">;</span>
</span><span class='line'>    <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">_data</span><span class="o">.</span><span class="na">writeInterfaceToken</span><span class="o">(</span><span class="n">DESCRIPTOR</span><span class="o">);</span>
</span><span class='line'>  <span class="n">_data</span><span class="o">.</span><span class="na">writeString</span><span class="o">(</span><span class="n">message</span><span class="o">);</span>
</span><span class='line'>  <span class="n">mRemote</span><span class="o">.</span><span class="na">transact</span><span class="o">(</span><span class="n">Stub</span><span class="o">.</span><span class="na">TRANSACTION_sayHello</span><span class="o">,</span> <span class="n">_data</span><span class="o">,</span> <span class="n">_reply</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'>  <span class="n">_reply</span><span class="o">.</span><span class="na">readException</span><span class="o">();</span>
</span><span class='line'>  <span class="n">_result</span> <span class="o">=</span> <span class="n">_reply</span><span class="o">.</span><span class="na">readString</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一段用的最多的code，我们在android中的BinderProxy对象中调用一个sayHello()方法，它会首先封装一个Parcel对象，并将其作为参数调用transact()函数，通过android的Binder机制传到另一个进程的BBinder的onTransact()函数中：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="n">onTransact</span><span class="o">(</span><span class="kt">int</span> <span class="n">code</span><span class="o">,</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Parcel</span> <span class="n">data</span><span class="o">,</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">Parcel</span> <span class="n">reply</span><span class="o">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">android</span><span class="o">.</span><span class="na">os</span><span class="o">.</span><span class="na">RemoteException</span>
</span><span class='line'><span class="o">{</span>
</span><span class='line'>    <span class="k">switch</span> <span class="o">(</span><span class="n">code</span><span class="o">)</span>
</span><span class='line'>    <span class="o">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nl">INTERFACE_TRANSACTION:</span>
</span><span class='line'>      <span class="o">{</span>
</span><span class='line'>      <span class="n">reply</span><span class="o">.</span><span class="na">writeString</span><span class="o">(</span><span class="n">DESCRIPTOR</span><span class="o">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="k">case</span> <span class="nl">TRANSACTION_sayHello:</span>
</span><span class='line'>      <span class="o">{</span>
</span><span class='line'>      <span class="n">data</span><span class="o">.</span><span class="na">enforceInterface</span><span class="o">(</span><span class="n">DESCRIPTOR</span><span class="o">);</span>
</span><span class='line'>      <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">_arg0</span><span class="o">;</span>
</span><span class='line'>      <span class="n">_arg0</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="na">readString</span><span class="o">();</span>
</span><span class='line'>      <span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">_result</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">sayHello</span><span class="o">(</span><span class="n">_arg0</span><span class="o">);</span>
</span><span class='line'>      <span class="n">reply</span><span class="o">.</span><span class="na">writeNoException</span><span class="o">();</span>
</span><span class='line'>      <span class="n">reply</span><span class="o">.</span><span class="na">writeString</span><span class="o">(</span><span class="n">_result</span><span class="o">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">onTransact</span><span class="o">(</span><span class="n">code</span><span class="o">,</span> <span class="n">data</span><span class="o">,</span> <span class="n">reply</span><span class="o">,</span> <span class="n">flags</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而这两个进程数据的传递是在driver里面通过内存拷贝进行的。</p>

<p>那么如果我希望不通过binder driver而直接将Parcel对象data通过socket传到另一个进程那么该怎么办呢？大家都知道在Java里面要传递一个数据，该数据必须得是Serializable的。那么Parcel类是这样的吗？</p>

<p>需要先来看看Parcel的实现:</p>

<h5>实现</h5>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Parcel</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">dataSize</span><span class="o">();</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">int</span> <span class="nf">dataPosition</span><span class="o">();</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">marshall</span><span class="o">();</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">unmarshall</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">,</span> <span class="kt">int</span> <span class="n">offest</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">);</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">writeInterfaceToken</span><span class="o">(</span><span class="n">String</span> <span class="n">interfaceName</span><span class="o">);</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">enforceInterface</span><span class="o">(</span><span class="n">String</span> <span class="n">interfaceName</span><span class="o">);</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">writeString</span><span class="o">(</span><span class="n">String</span> <span class="n">val</span><span class="o">);</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="n">String</span> <span class="nf">readString</span><span class="o">();</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先可以看到Parcel并没有implements Serializable，同时它的方法都是JNI方法，可以在frameworks/base/core/jni/android_util_Binder.cpp里面找到，这里以writeString()为例：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">android_os_Parcel_writeString</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">clazz</span><span class="p">,</span> <span class="n">jstring</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Parcel</span><span class="o">*</span> <span class="n">parcel</span> <span class="o">=</span> <span class="n">parcelForJavaObject</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">clazz</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">parcel</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">NO_MEMORY</span><span class="p">;</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">const</span> <span class="n">jchar</span><span class="o">*</span> <span class="n">str</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetStringCritical</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>                <span class="n">err</span> <span class="o">=</span> <span class="n">parcel</span><span class="o">-&gt;</span><span class="n">writeString16</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">GetStringLength</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
</span><span class='line'>                <span class="n">env</span><span class="o">-&gt;</span><span class="n">ReleaseStringCritical</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">err</span> <span class="o">=</span> <span class="n">parcel</span><span class="o">-&gt;</span><span class="n">writeString16</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">signalExceptionForError</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">clazz</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>里面调用了Parcel的writeString16()这个方法，而这个Parcel是一个C类，实现在frameworks/base/libs/binder/Parcel.cpp里面：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="p">...</span>
</span><span class='line'><span class="n">status_t</span> <span class="n">Parcel</span><span class="o">::</span><span class="n">writeString16</span><span class="p">(</span><span class="k">const</span> <span class="n">char16_t</span><span class="o">*</span> <span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">str</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">return</span> <span class="n">writeInt32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">writeInt32</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">len</span> <span class="o">*=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">char16_t</span><span class="p">);</span>
</span><span class='line'>        <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">writeInplace</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">char16_t</span><span class="p">));</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>            <span class="o">*</span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">char16_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">data</span><span class="o">+</span><span class="n">len</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>            <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="n">err</span> <span class="o">=</span> <span class="n">mError</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="n">status_t</span> <span class="n">Parcel</span><span class="o">::</span><span class="n">writeInt32</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">val</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">writeAligned</span><span class="p">(</span><span class="n">val</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="n">template</span><span class="o">&lt;</span><span class="n">class</span> <span class="n">T</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">status_t</span> <span class="n">Parcel</span><span class="o">::</span><span class="n">writeAligned</span><span class="p">(</span><span class="n">T</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">COMPILE_TIME_ASSERT_FUNCTION_SCOPE</span><span class="p">(</span><span class="n">PAD_SIZE</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">))</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">mDataPos</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">mDataCapacity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="nl">restart_write:</span>
</span><span class='line'>        <span class="o">*</span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">mData</span><span class="o">+</span><span class="n">mDataPos</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">finishWrite</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">growData</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="k">goto</span> <span class="n">restart_write</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">...</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span><span class="o">*</span> <span class="n">Parcel</span><span class="o">::</span><span class="n">writeInplace</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">padded</span> <span class="o">=</span> <span class="n">PAD_SIZE</span><span class="p">(</span><span class="n">len</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// sanity check for integer overflow</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">mDataPos</span><span class="o">+</span><span class="n">padded</span> <span class="o">&lt;</span> <span class="n">mDataPos</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">mDataPos</span><span class="o">+</span><span class="n">padded</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">mDataCapacity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="nl">restart_write:</span>
</span><span class='line'>        <span class="c1">//printf(&quot;Writing %ld bytes, padded to %ld\n&quot;, len, padded);</span>
</span><span class='line'>        <span class="kt">uint8_t</span><span class="o">*</span> <span class="k">const</span> <span class="n">data</span> <span class="o">=</span> <span class="n">mData</span><span class="o">+</span><span class="n">mDataPos</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Need to pad at end?</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">padded</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="cp">#if BYTE_ORDER == BIG_ENDIAN</span>
</span><span class='line'>            <span class="k">static</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>                <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0xffffff00</span><span class="p">,</span> <span class="mh">0xffff0000</span><span class="p">,</span> <span class="mh">0xff000000</span>
</span><span class='line'>            <span class="p">};</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="cp">#if BYTE_ORDER == LITTLE_ENDIAN</span>
</span><span class='line'>            <span class="k">static</span> <span class="k">const</span> <span class="kt">uint32_t</span> <span class="n">mask</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>                <span class="mh">0x00000000</span><span class="p">,</span> <span class="mh">0x00ffffff</span><span class="p">,</span> <span class="mh">0x0000ffff</span><span class="p">,</span> <span class="mh">0x000000ff</span>
</span><span class='line'>            <span class="p">};</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'>            <span class="c1">//printf(&quot;Applying pad mask: %p to %p\n&quot;, (void*)mask[padded-len],</span>
</span><span class='line'>            <span class="c1">//    *reinterpret_cast&lt;void**&gt;(data+padded-4));</span>
</span><span class='line'>            <span class="o">*</span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">data</span><span class="o">+</span><span class="n">padded</span><span class="o">-</span><span class="mi">4</span><span class="p">)</span> <span class="o">&amp;=</span> <span class="n">mask</span><span class="p">[</span><span class="n">padded</span><span class="o">-</span><span class="n">len</span><span class="p">];</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">finishWrite</span><span class="p">(</span><span class="n">padded</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">status_t</span> <span class="n">err</span> <span class="o">=</span> <span class="n">growData</span><span class="p">(</span><span class="n">padded</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="k">goto</span> <span class="n">restart_write</span><span class="p">;</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实整个Parcel的实现是这样的，每一个Parcel对象有一个指针mData，指向一块内存的起始地址，一个指针mDataPos，指向到目前未知已经读到的数据的大小。在写一个String的时候，首先将字符串的大小通过writeInt32()写到某个合适的内存地址中：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">mDataPos</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">mDataCapacity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'><span class="nl">restart_write:</span>
</span><span class='line'>        <span class="o">*</span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">mData</span><span class="o">+</span><span class="n">mDataPos</span><span class="p">)</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">finishWrite</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">val</span><span class="p">));</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后通过writeInplace将字符串按照合适的Align方式写到之后的内存地址中：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>    <span class="kt">uint8_t</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="o">*</span><span class="p">)</span><span class="n">writeInplace</span><span class="p">(</span><span class="n">len</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">char16_t</span><span class="p">));</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">memcpy</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'>  <span class="o">*</span><span class="n">reinterpret_cast</span><span class="o">&lt;</span><span class="n">char16_t</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">data</span><span class="o">+</span><span class="n">len</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">NO_ERROR</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后更新相对应的mDataSize和mDataPos值。</p>

<hr />

<h6>Parcel对象的序列化</h6>

<p>也就是说我们在java层是没有办法不通过其提供的接口获得一个Parcel对象内存中的数据的，也就是说如果我们需要将Parcel对象通过socket传输，就只有两种方式：</p>

<ul>
<li>在jni层进行socket传输；</li>
<li>手动对其进行序列化，并将序列化的数据通过socket传输过去。</li>
</ul>


<p>其实细心的人可以发现我刚刚在列举Parcel的一系列jni方法的时候还列举了两个方法：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">Parcel</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">marshall</span><span class="o">();</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">final</span> <span class="kd">native</span> <span class="kt">void</span> <span class="nf">unmarshall</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">data</span><span class="o">,</span> <span class="kt">int</span> <span class="n">offest</span><span class="o">,</span> <span class="kt">int</span> <span class="n">length</span><span class="o">);</span>
</span><span class='line'>    <span class="o">...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两个方法在jni里面是这样实现的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">static</span> <span class="n">jbyteArray</span> <span class="nf">android_os_Parcel_marshall</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">clazz</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Parcel</span><span class="o">*</span> <span class="n">parcel</span> <span class="o">=</span> <span class="n">parcelForJavaObject</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">clazz</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">parcel</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1">// do not marshall if there are binder objects in the parcel</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">parcel</span><span class="o">-&gt;</span><span class="n">objectsCount</span><span class="p">())</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">jniThrowException</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="s">&quot;java/lang/RuntimeException&quot;</span><span class="p">,</span> <span class="s">&quot;Tried to marshall a Parcel that contained Binder objects.&quot;</span><span class="p">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">jbyteArray</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NewByteArray</span><span class="p">(</span><span class="n">parcel</span><span class="o">-&gt;</span><span class="n">dataSize</span><span class="p">());</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">jbyte</span><span class="o">*</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="n">jbyte</span><span class="o">*</span><span class="p">)</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">GetPrimitiveArrayCritical</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="k">if</span> <span class="p">(</span><span class="n">array</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="n">memcpy</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">parcel</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">(),</span> <span class="n">parcel</span><span class="o">-&gt;</span><span class="n">dataSize</span><span class="p">());</span>
</span><span class='line'>            <span class="n">env</span><span class="o">-&gt;</span><span class="n">ReleasePrimitiveArrayCritical</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">static</span> <span class="kt">void</span> <span class="nf">android_os_Parcel_unmarshall</span><span class="p">(</span><span class="n">JNIEnv</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="n">jobject</span> <span class="n">clazz</span><span class="p">,</span> <span class="n">jbyteArray</span> <span class="n">data</span><span class="p">,</span> <span class="n">jint</span> <span class="n">offset</span><span class="p">,</span> <span class="n">jint</span> <span class="n">length</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">Parcel</span><span class="o">*</span> <span class="n">parcel</span> <span class="o">=</span> <span class="n">parcelForJavaObject</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">clazz</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">parcel</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>       <span class="k">return</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">jbyte</span><span class="o">*</span> <span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="n">jbyte</span><span class="o">*</span><span class="p">)</span><span class="n">env</span><span class="o">-&gt;</span><span class="n">GetPrimitiveArrayCritical</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">parcel</span><span class="o">-&gt;</span><span class="n">setDataSize</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
</span><span class='line'>        <span class="n">parcel</span><span class="o">-&gt;</span><span class="n">setDataPosition</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">void</span><span class="o">*</span> <span class="n">raw</span> <span class="o">=</span> <span class="n">parcel</span><span class="o">-&gt;</span><span class="n">writeInplace</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
</span><span class='line'>        <span class="n">memcpy</span><span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="p">(</span><span class="n">array</span> <span class="o">+</span> <span class="n">offset</span><span class="p">),</span> <span class="n">length</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">env</span><span class="o">-&gt;</span><span class="n">ReleasePrimitiveArrayCritical</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>marshall和unmarshall正是两个Parcel提供的将其自身进行序列化和反序列化的方法，marshall()将其本身转换成一个byte[]数据序列，即将mData指向内存中的值通过内存拷贝的形式传到一个byte[]变量中去并返回，而unmarshall()则是将byte[]变量中的数据拷贝到Parcel对象的mData指向内存中。</p>

<p>也就是说，我们可以通过marshall方法将data序列化成byte[]变量dataBytes，通过socket的write传递到远端，在远端通过unmarshall方法将其转换回来。</p>

<p>另外通过实现，发现还有一个需要注意的地方，在远端通过unmarshall对象转换回来的时候，还需要调用data.setDataPosition(0)将mDataPos设成初始未知，否则之后无法读取正常的数据。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GoAgent setup note]]></title>
    <link href="http://ytliu.github.com/blog/2012/10/27/goagent-setup-note/"/>
    <updated>2012-10-27T12:21:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/10/27/goagent-setup-note</id>
    <content type="html"><![CDATA[<p>这次去武汉开会的时候听翔哥提到GoAgent很好用，就尝试着去搭了下环境。</p>

<p><a href="http://irising.me/2012/02/13376/%20GoAgent">原文地址</a></p>

<p>说实话这个环境搭起来真的很方便，主要分为四步：</p>

<ul>
<li><p>申请Google App Engine的请用，这个就不细说了，具体参看原文，唯一一个要注意的是在里面有一个Storage Schema的选项要选择High Replication (我之前注册的应用没有这一项，要转变成这个还挺麻烦的)。</p></li>
<li><p>安装GoAgent的客户端：代码的地址在<a href="http://code.google.com/p/goagent/">这里</a>，然后要修改local目录下的proxy.ini文件，之后要安装一个证书（不过据说不安装也行）。最后上传到GAE上：</p>

<p>  $ cd goagent/server</p>

<p>  $ python uploader.zip update ./</p></li>
</ul>


<p>会在后面提示输入appid和GAE账户信息。</p>

<ul>
<li><p>设置代理：新建一个网络位置，例如：命名为代理，并将Web代理、安全Web代理两项勾选上，代理服务器地址均为，127.0.0.1,端口为8087。</p></li>
<li><p>GoAgent使用：首先先在终端运行如下命令：</p>

<p>  $ cd goagent/local</p>

<p>  $ python proxy.python</p></li>
</ul>


<p>然后再在苹果菜单下切换location成代理。</p>

<p>这样就可以通过GoAgent上网了。</p>

<h4>GoAgentX</h4>

<p>由于这个需要每次都在终端下输入命令，切换网络位置，最关键的是如果换了一个代理服务器的地址的话还要手动更新，所以在P哥的推荐下我选择了使用GoAgentX，这个是GoAgent的图形界面版，而且可以自动更新，十分方便。</p>

<h6>安装</h6>

<p>下载地址在<a href="https://github.com/downloads/ohdarling/GoAgentX/GoAgentX-v1.3.6.dmg%20GoAgentX">这里</a>，直接点击安装就可以了。然后会在桌面上方的任务栏里有个戴帽子的小人图像出现，点击显示主窗口，在服务配置里面修改端口和appid，在代理配置里面勾选“不修改系统代理配置”，之后启动，并修改网络位置就可以了。</p>

<hr />

<p>我感觉苹果电脑配置这些东西都非常的方便，而且程序运行的也很稳定，相当赞啊~</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[regain my VM's account]]></title>
    <link href="http://ytliu.github.com/blog/2012/10/20/regain-my-vms-account/"/>
    <updated>2012-10-20T13:53:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/10/20/regain-my-vms-account</id>
    <content type="html"><![CDATA[<p>这两天在做opennebula项目的时候遇到一个问题，我忘记掉之前那几个虚拟机的用户密码了！试了好多可能的密码都不对，只能想办法把密码改掉了。</p>

<p>虚拟机的好处在于我可以把它直接mount到物理主机上对其进行操作，不过镜像文件不是一个普通的设备块，不能通过一般的方法mount，只能用不一般的方法了：</p>

<p>首先我有两种镜像，一个是普通的qemu镜像，以.img结尾的文件，一种是KVM的qcow2文件。</p>

<h5>.img镜像</h5>

<p>对于第一种，飞机教了我一个办法：</p>

<pre><code>$ fdisk -l vm.img
Disk datastores/vm.img: 8589 MB, 8589934592 bytes
255 heads, 63 sectors/track, 1044 cylinders, total 16777216 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x0004bacc
Device Boot      Start         End      Blocks   Id  System
datastores/vm3.img1   *        2048    15958015     7977984   83  Linux
datastores/vm3.img2        15960062    16775167      407553    5  Extended
datastores/vm3.img5        15960064    16775167      407552   82  Linux swap / Solaris
</code></pre>

<p>注意里面的一个数2048，然后执行下面一条指令：</p>

<pre><code>$ mount -o offset=$((2048*512)),loop vm.img /mnt
</code></pre>

<p>然后就mount到/mnt上去了。</p>

<h5>.qcow2镜像</h5>

<p>第二种镜像得用另外一个方法，这个是从<a href="http://blog.loftninjas.org/2008/10/27/mounting-kvm-qcow2-qemu-disk-images/">这里</a>看到的：</p>

<p>首先要先aptitude install 一个nbd-client，通过</p>

<pre><code>$ sudo modprobe nbd max_part=8
$ sudo qemu-nbd --connect=/dev/nbd0 vm.qcow2
$ sudo fdisk /dev/nbd0
$ sudo mount /dev/nbd0p1 /mnt
</code></pre>

<p>即完成了mount，当然我对其中的原理也不太了解就是了。</p>

<h5>chroot</h5>

<p>最后是如何改密码，我是痛过chroot来做的，这里想简单介绍下这个命令：</p>

<p>刚开始我直接运行：</p>

<pre><code>$ sudo chroot .
</code></pre>

<p>然后报了一个这个错误：</p>

<pre><code>chroot: failed to run command `/bin/zsh': No such file or directory`
</code></pre>

<p>之后了解了chroot的<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-chroot/">工作流程</a>才知道这是怎么回事：</p>

<p>一个相对完整的chroot流程是这样的：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &lt;stdio.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;unistd.h&gt;</span>
</span><span class='line'><span class="cp">#include &lt;stdlib.h&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">argc</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">){</span>
</span><span class='line'>  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Usage: chroot NEWROOT [COMMAND...] </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;newroot = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">chroot</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;chroot&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">chdir</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">perror</span><span class="p">(</span><span class="s">&quot;chdir&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">getenv</span><span class="p">(</span><span class="s">&quot;SHELL&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</span><span class='line'>      <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="s">&quot;/bin/sh&quot;</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="s">&quot;-i&quot;</span><span class="p">;</span>
</span><span class='line'>  <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">argv</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">execvp</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">argv</span><span class="p">);</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;chroot: cannot run command `%s`</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">argv</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在chdir之后会先看看用户有没有指定特定的shell，如果没有则根据环境变量中的SHELL来指定相同的shell，否则会使用用户指定的shell运行（argv += 2)。由于我原来用户的shell是<em>/bin/zsh</em>, 且我没有指定特定的shell，所以在chroot之后就默认使用<em>/bin/zsh</em>，但是在这个镜像的文件系统中并没有<em>/bin/zsh</em>，所以就会报错。</p>

<p>所以我只需要（1）将环境变量中的shell设成<em>/bin/bash</em>或者（2）指定一个shell（$ sudo chroot . /bin/bash）就可以了</p>

<p>之后就可以通过运行</p>

<pre><code>$ passwd root
</code></pre>

<p>来改变root的密码了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android messaging mechanism]]></title>
    <link href="http://ytliu.github.com/blog/2012/10/12/android-messaging-mechanism/"/>
    <updated>2012-10-12T21:43:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/10/12/android-messaging-mechanism</id>
    <content type="html"><![CDATA[<p>这两天做remote binder遇到一个bug，具体是什么就不细说了，总之是和android的message机制相关，在Handler.java里面通过mQueue.enqueueMessage()成功后却没有办法从Looper.java里面的mQueue.next()中读出该条message。搞了半天，打印了一堆log，最后发现竟然是因为Looper的线程被我自己block住了。这个主要是由于自己对其理解的错误造成的，之前我一直以为对于每个Activity（或Service）来说，除了主线程之外，都会有一个专用的Looper线程进行消息队列的轮询，今天和乃正讨论了下，其实不是这样的。对于一个进程来说，如果你没有需求说需要有某个线程做某些特定的事（比如socket监听），那么你的主线程就会进入Looper循环进行消息队列的轮询，否则你就需要自己再新建一个线程，或者重新开一个looper，或者进行socket监听&#8230;</p>

<p>此外还有一点，looper是thread local的，对于这个的理解，应该是这样的：在每个线程新建之后，都会有一个原来线程的mQueue的引用，而如果你要自己做一些特定的事，比如重新开一个新的Looper进行其它消息的轮询，那么没有问题，你新建一个looper，但是要注意，你的mQueue是唯一的，也就是说，你之前的对原来线程的mQueue的引用就没了，也就是说，对于一个线程来说只可能有唯一的mQueue。</p>

<p>之后就是message的流程。有两种可能的情况：</p>

<ul>
<li>sendMessage(): 这是最常见的形式，这个msg就是一个普通的message，它会依次调用sendMessageDelayed(), sendMessageAtTime(), queue.enqueueMessage()，最后将消息插到队列中去。</li>
<li>post(): 我这次遇到的就是这种形式，在ServiceDispatcher中用到的就是它，它传递的message是一个Runnable对象，叫RunConnection，在post里面会逐步调用sendMessageDelayed(), sendMessageAtTime(), queue.enqueueMessage()，并且会将msg.callback设成RunConnection对象。</li>
</ul>


<p>之后在Looper中会进入while循环，每次取出一个msg(<em>queue.next()</em>)，然后调用dispatchMessage()，在里面会有下面这段代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>if (msg.callback != null) {
</span><span class='line'>    msg.callback.run();
</span><span class='line'>}
</span><span class='line'>else {
</span><span class='line'>    ...
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>也就是说如果是post传进来的RunConnection对象的msg的话将会直接运行它的run函数，否则会直接调用handleMessage()进行处理。</p>

<hr />

<p>android的message机制其实就是一种异步消息处理机制，进程通过Handler的sendMessage或post将msg进行enqueueMessage，然后通过该线程自己的Looper进行消息队列轮询并根据相应的情况进行handle。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[android service startup]]></title>
    <link href="http://ytliu.github.com/blog/2012/10/05/android-service-startup/"/>
    <updated>2012-10-05T10:25:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/10/05/android-service-startup</id>
    <content type="html"><![CDATA[<p>现在要写一个service，在启动之后开启socket监听，等待用户端发消息给它进行处理。而这个service是不会有Activity的，于是乎就要考虑如何让这个service启动起来。</p>

<h4>System Service Startup</h4>

<p>最早想的是将这个service写成system service，然后通过SystemServer启动，这样是可行的，也蛮方便，具体的做法是这样的：</p>

<p>在framework/base/core/java/android/os/app/目录中写一个NewService类extends Service，之后在SystemServer.java中添加</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="k">try</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Slog</span><span class="o">.</span><span class="na">i</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;New Service&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">ServiceManager</span><span class="o">.</span><span class="na">addService</span><span class="o">(</span><span class="s">&quot;newservice&quot;</span><span class="o">,</span> <span class="k">new</span> <span class="n">NewService</span><span class="o">(</span><span class="n">context</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">Throwable</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">Slog</span><span class="o">.</span><span class="na">e</span><span class="o">(</span><span class="n">TAG</span><span class="o">,</span> <span class="s">&quot;Failure starting New Service&quot;</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>之后NewService就会开机启动，但是这样有一个问题，就是这个NewService的pid也就是SystemServer的pid，它们是处于同一个进程中的。于是由于种种原因我不希望启动一个系统服务，而是一个application level的service，这样就遇到一个问题：如果是一个单纯的没有activity的service应用，在通过<em>adb install</em>进系统后并不会自动启动，而是需要其它进程通过<em>startService()</em>或者<em>bindService()</em>启动，那么有没有什么其它方法让一个service在每次install之后启动呢？</p>

<h4>App Level Service Startup upon Installe</h4>

<p>这里有两种方案：</p>

<ul>
<li>1 通过先启动一个Activity，然后<em>startService()</em>启动该service，之后在Activity中将自己finish掉；</li>
<li>2 在application中注册一个BroadcastReceiver，监听PackageManager的<em>android.intent.action.PACKAGE_ADDED</em>的intent-filter，然后在Receiver的onReceive()里面通过</li>
</ul>


<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Intent</span> <span class="n">serviceIntent</span> <span class="o">=</span><span class="k">new</span> <span class="n">Intent</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">NewService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'><span class="n">context</span><span class="o">.</span><span class="na">startService</span><span class="o">(</span><span class="n">serviceIntent</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>进行启动。</p>

<p>在我看来第二种方案更符合我的要求，因为这样我就可以不用每次点击一下某个Activity才能启动service，但是这也是我最先否决的方案，因为我在Stack Overflow里面看到好多个讨论这个问题的帖子，其中有一个回复是这么说的：</p>

<blockquote><p>all applications, upon installation, are placed in a &#8220;stopped&#8221; state. This is the same state that the application winds up in after the user force-stops the app from the Settings application. While in this &#8220;stopped&#8221; state, the application will not run for any reason, except by a manual launch of an activity. Notably, noBroadcastReceviers will be invoked, regardless of the event for which they have registered, until the user runs the app manually.</p></blockquote>


<p>也就是说任何app level的应用都不可能在没有得到用户同意的情况下自动启动（特别是在android3.1之后，它们在安装后被置于了“stopped”的状态，只有当用户点击了某个Activity的图标才能启动起来，service也只有通过某个启动的Activity或Service通过startService()或bindService()才能启动起来。</p>

<p>所以第二个方案不可行，下面我们来看第一个方案：</p>

<p>在第一个方案里面，当Activity通过startService()启动service之后，就通过finish()将自己退出。这个时候按照android的specification，通过startService()启动的service是不会退出的（通过bindService()启动的service会随着activity的退出而退出），为了确定这一点，可以通过Settings->Apps->Running Service来查看。</p>

<h5>startForeground()</h5>

<p>另外，为了防止你在background运行的service在low memory的时候被系统强制退出，可以通过startForeground()将该service定义在foreground中，而这个所谓的foreground就是我们平时看到的位于android上方的消息栏，里面可以设置该service需要显示的信息，以及时间间隔&#8230;具体可以参见<a href="http://ytliu.github.com" title="Service API">Service API</a>，这里有一个简单的示例：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">Notification</span> <span class="n">note</span><span class="o">=</span><span class="k">new</span> <span class="n">Notification</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">drawable</span><span class="o">.</span><span class="na">stat_notify_chat</span><span class="o">,</span>
</span><span class='line'>  <span class="s">&quot;Can you hear the music?&quot;</span><span class="o">,</span>
</span><span class='line'>  <span class="n">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
</span><span class='line'><span class="n">Intent</span> <span class="n">i</span><span class="o">=</span><span class="k">new</span> <span class="n">Intent</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">FakePlayer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'><span class="n">i</span><span class="o">.</span><span class="na">setFlags</span><span class="o">(</span><span class="n">Intent</span><span class="o">.</span><span class="na">FLAG_ACTIVITY_CLEAR_TOP</span><span class="o">|</span>
</span><span class='line'>  <span class="n">Intent</span><span class="o">.</span><span class="na">FLAG_ACTIVITY_SINGLE_TOP</span><span class="o">);</span>
</span><span class='line'><span class="n">PendingIntent</span> <span class="n">pi</span><span class="o">=</span><span class="n">PendingIntent</span><span class="o">.</span><span class="na">getActivity</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">i</span><span class="o">,</span> <span class="mi">0</span><span class="o">);</span>
</span><span class='line'><span class="n">note</span><span class="o">.</span><span class="na">setLatestEventInfo</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="s">&quot;Fake Player&quot;</span><span class="o">,</span>
</span><span class='line'>  <span class="s">&quot;Now Playing: \&quot;Ummmm, Nothing\&quot;&quot;</span><span class="o">,</span>
</span><span class='line'>  <span class="n">pi</span><span class="o">);</span>
</span><span class='line'><span class="n">note</span><span class="o">.</span><span class="na">flags</span><span class="o">|=</span><span class="n">Notification</span><span class="o">.</span><span class="na">FLAG_NO_CLEAR</span><span class="o">;</span>
</span><span class='line'><span class="n">startForeground</span><span class="o">(</span><span class="mi">1337</span><span class="o">,</span> <span class="n">note</span><span class="o">);</span>
</span></code></pre></td></tr></table></div></figure>


<h4>App Level Service Startup when Bootup</h4>

<p>这是一种理论中的方法，因为我也没尝试过，具体方法参见<a href="http://" title="service startup when bootup">this article</a>，大概的意思是在application的Android.manifest文件中添加一个user-permission和一个receiver的intent-filter：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='xml'><span class='line'><span class="nt">&lt;application</span> <span class="err">...</span><span class="nt">&gt;</span>
</span><span class='line'>    ......
</span><span class='line'>    <span class="nt">&lt;receiver</span> <span class="na">android:name=</span><span class="s">&quot;.MyReceiver &quot;</span><span class="na">android:enabled=</span><span class="s">&quot;true&quot;</span> <span class="na">android:exported=</span><span class="s">&quot;false&quot;</span><span class="err">]]</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;intent-filter&gt;</span>
</span><span class='line'>      <span class="nt">&lt;action</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.action.BOOT_COMPLETED&quot;</span><span class="nt">/&gt;</span>
</span><span class='line'>  <span class="nt">&lt;/intent-filter&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/receiver&gt;</span>
</span><span class='line'><span class="nt">&lt;/application&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="nt">&lt;uses-permission</span> <span class="na">android:name=</span><span class="s">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span><span class="nt">/&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后在MyReceiver类里面的onReceive()函数中开启相应的service：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">MyReceiver</span> <span class="kd">extends</span> <span class="n">BroadcastReceiver</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onReceive</span><span class="o">(</span><span class="n">Context</span> <span class="n">context</span><span class="o">,</span><span class="n">Intent</span> <span class="n">intent</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">Intent</span> <span class="n">serviceIntent</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Intent</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">NewService</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>  <span class="n">context</span><span class="o">.</span><span class="na">startService</span><span class="o">(</span><span class="n">serviceIntent</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这种方法看上去应该是可行的，但是问题是用户每次装你的应用都要让系统重启一遍，那还有谁会那么好心情去安装你的应用啊？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[opennebula setup note]]></title>
    <link href="http://ytliu.github.com/blog/2012/09/28/opennebula-setup-note/"/>
    <updated>2012-09-28T14:30:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/09/28/opennebula-setup-note</id>
    <content type="html"><![CDATA[<p>这几天搞opennebula这个项目，一个很大的感受就是对于environement setup一定要有详细的笔记，不然过了一段时间就什么也想不起来了，遇到和以前一样的问题也不懂该如何解决。实在浪费时间，于是就把它记下来。</p>

<h2>基本命令</h2>

<p>首先是opennebula里面的一些基本命令，这里以kvm为例：</p>

<h3>Cloud Infrastructure Setup</h3>

<p>On Cluster:</p>

<pre><code>$ onecluster create cluster01
</code></pre>

<p>On Host (kvm):</p>

<pre><code>$ onehost create host01 --im im_kvm --vm vmm_kvm --net dummy 
$ onecluster addhost cluster01 host01
</code></pre>

<p>System Datastore (for running VM, not needed in front end):</p>

<pre><code>mount a NFS directory to /var/lib/one/datastores/0 for each host, if you would like to perform live migration.
</code></pre>

<p>Filesystem Datastore (for regular storage), sample config file: &#8216;ds.conf&#8217;</p>

<pre><code>$ onedatastore create ds.conf 
$ onecluster adddatastore cluster01 ds01 
$ onedatastore update 100
</code></pre>

<p>add SAFE_DIRS=&#8221;/var/lib/one/datastores/&#8221;, mount actual datastore to /var/lib/one/datastores/<datastore_id></p>

<h3>Set up Virtual Resource</h3>

<p>Virtual Machine Image</p>

<pre><code>$ oneimage create img_debian.conf --datastore ds01
</code></pre>

<p>Virtual Network</p>

<pre><code>$ onevnet create net_lease.conf
</code></pre>

<p>Virtual Machine Template</p>

<pre><code>$ onetemplate create vm_debian.conf 
$ onetemplate instantiate vm_debian --name debian1
</code></pre>

<p>Virtual Machine</p>

<pre><code>$ onevm deploy debian1 brick4 
$ onevm suspend debian1 
$ onevm resume debian1 
$ onevm resubmit debian1 
$ onevm stop debian1 
$ onevm delete debian1
</code></pre>

<h3>qemu/kvm</h3>

<p>create image:</p>

<pre><code>$ /usr/local/kvm/bin/qemu-img create -f qcow2 &amp;lt;img_name&amp;gt; 10G
</code></pre>

<p>create image from base:</p>

<pre><code>$ /usr/local/kvm/bin/qemu-img create -f qcow2 -b &amp;lt;base_img_name&amp;gt; &amp;lt;img_name&amp;gt;
</code></pre>

<p>install os:</p>

<pre><code>$ sudo /usr/local/kvm/bin/qemu-system-x86_64 -k en-us -hda vdisk.img -cdrom /path/to/boot-media.iso 
</code></pre>

<p>run image:</p>

<pre><code>$ /usr/local/kvm/bin/qemu-system-x86_64 -k en-us -hda vdisk.img -m 512
</code></pre>

<h2>权限问题</h2>

<h3>ssh 权限</h3>

<p>需要把front的oneadmin用户的.ssh/id_rsa.pub拷贝到host的oneadmin用户的.ssh/authorized_keys里面</p>

<p>需要把host的oneadmin用户的.ssh/id_rsa.pub拷贝到front的oneadmin用户的.ssh/authorized_keys里面（optional）</p>

<h3>账户设置</h3>

<p>两边oneadmin账户的uid，gid一定要相同！</p>

<p>On front:</p>

<pre><code>$ id oneadmin
uid=1002(oneadmin) gid=1002(oneadmin) groups=1002(oneadmin)
</code></pre>

<p>On host:</p>

<pre><code>$ addgroup --gid 1002 oneadmin
$ useradd --uid 1002 -g oneadmin -d /var/lib/one oneadmin
</code></pre>

<p>另外在host端的oneadmin还需要有/var/lib/one目录下所有东西的所有权，同时，oneadmin还需要加入<strong>group kvm</strong>（否则无法启动kvm）</p>

<pre><code>$ usermod -a -G kvm oneadmin
</code></pre>

<p>另外，由于/usr/bin/kvm的权限是root:root，所以这个也可能引发错误，或者将其权限改为oneadmin，或者为oneadmin添加一个root用户组:</p>

<pre><code>$ usermod -a -G root oneadmin
</code></pre>

<h3>libvirt</h3>

<p>！！！！搞了我好久，一直莫名其妙地出一个错误：</p>

<pre><code>internal error process exited while connecting to monitor: kvm: -drive file=/var/lib/one//datastores/0,if=none,id=drive-ide0-0-0,format=raw: 
could not open disk image /var/lib/one//datastores/0: Permission denied
</code></pre>

<p>我直接用kvm打开那个镜像都没问题，然后看到一个帖子http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=673427，再加上http://opennebula.org/documentation:archives:rel3.4:kvmg看到这样一句：</p>

<pre><code>Qemu should be configured to not change file ownership. Modify /etc/libvirt/qemu.conf to include dynamic_ownership = 0. To be able 
to use the images copied by OpenNebula, change also the user and group under which the libvirtd is run to “oneadmin”.
</code></pre>

<p>然后去<strong>/etc/libvirt/qemu.conf</strong>把user改成oneadmin,group改成cloud（顺便说下oneadmin也加了一个cloud的group),瞬间就起起来了！</p>

<p>然后，我把oneimage换了一下，把</p>

<pre><code>NAME          = "debian_new"
PATH          = /var/lib/one/datastores/ubuntu.11-10.x86-64.20111013.qcow2
加了三行：
TYPE          = OS
PERSISTENT    = YES
DRIVER        = qcow2
</code></pre>

<p>然后就起来了。。。其实我也不知道为什么，可能.qcow2结尾的镜像就是要qcow2的driver才能起起来吧</p>

<hr />

<p>之后配host2的时候还会碰到一个问题就是/var/run/libvirt/libvirt-sock和/var/tmp/one目录下的permission denied，对于前者，给oneadmin再加一个libvirtd的group，对于后者，把/var/tmp/one chown一下就好了</p>

<h2>NFS</h2>

<h3>On front</h3>

<pre><code>$ vi /etc/hosts
203.95.3.3 host1
203.95.3.4 host2

$ vi /etc/exports
/var/lib/one/datastores/0       host1(rw,no_root_squash)   #0是system datastore的编号，是opennebula自带的
/var/lib/one/datastores/104     host1(rw,no_root_squash)   #104是file system datastore的编号，由onedatastore自动创建的
</code></pre>

<h3>On host</h3>

<pre><code>$ cd
$ mkdir datasdores
$ mkdir datastores/0
$ mkdir datastores/104
$ sudo mount 203.95.3.5:/var/lib/one/datastores/104 /var/lib/one/datastores/104
$ sudo mount 203.95.3.5:/var/lib/one/datastores/0 /var/lib/one/datastores/0
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[progit reading 2]]></title>
    <link href="http://ytliu.github.com/blog/2012/09/21/progit-reading-2/"/>
    <updated>2012-09-21T16:50:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/09/21/progit-reading-2</id>
    <content type="html"><![CDATA[<p>上章介绍了git internal的内容，接下里会从git更接近用户的角度来说。</p>

<hr />

<h1>git basic</h1>

<p>git中的文件有以下几种状态，而所有的命令也就是对于这几种状态的查看和转换：</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-4.png" title="git file status" alt="git file status" /></p>

<p>一般情况下，在新建一个文件后，需要<em>git add</em>将其变成tracked file，如果修改了一个该文件，则同样需要使用<em>git add</em>将其变成staged file，只有staged的文件才会在<em>git commit</em>的时候commit成功。</p>

<p><strong>git status</strong></p>

<p>这个可以用来查看当前文件的状态。如果我们在commit的参数中加上<em>-a</em>，就可以自动将tracked file变成staged file了。当然也可以忽略一些文件，这些都是写在.gitignore文件下的，那么，如何unstage一个文件呢？其实在你使用<em>git stage</em>命令的时候就会有提示:</p>

<pre><code>$ git reset HEAD &lt;file&gt;
</code></pre>

<p>同样的，我们也可以把一个modified file变成unmodified file:</p>

<pre><code>$ git checkout -- &lt;file&gt;
</code></pre>

<p><strong>git diff</strong></p>

<p>由于<em>git status</em>只能告诉我们哪些文件被修改了，而不能告诉我们都修改了哪些具体内容，所以有一个<em>git diff</em>命令来补充这个功能。</p>

<p><em>git diff</em>显示的是changed but not staged的文件，而<em>git diff &#8211;cached</em>显示的是staged的文件</p>

<p><strong>git commit</strong></p>

<p>这个就是将stage area里面的东西进行提交，在提交的时候需要指定<em>-m</em>参数。另外还有一个比较有用的命令叫*git commit &#8211;amend**用来返回到最近的一次commit之前，然后加一些其它文件，然后再自动提交一遍，这样就不会有两个相似的commit了。</p>

<p><strong>git rm</strong></p>

<p>如果只是简单地用<em>rm</em>命令，那么它还是处于unstage的状态，用<em>git rm</em>会将其变成untrack状态。另外，如果你加了参数<em>-f</em>则可以将其从index中删除，这样如果之前没有commit这个文件的话之后也就无法恢复了。</p>

<p>还有一个比较有用的命令是:</p>

<pre><code>$ git rm --cached &lt;file&gt;
</code></pre>

<p>这个命令可以在硬盘上保留file，但是将其从working tree中删除。比如说你忘记把file添加到.gitignore文件中的话就可以用这个命令。</p>

<p>同样，这个命令也支持正则表达式。</p>

<p><strong>git mv</strong></p>

<p>在git中，如果你用<em>git mv</em>命令，在git history中应该是没有renaming这个记录的，那么为什么还有mv这个命令呢？在git中：<em>git mv file_from file_to</em>这一个命令相当于</p>

<pre><code>$ mv file_from file_to
$ git rm file_from
$ git add file_to
</code></pre>

<p>这三条命令。</p>

<p><strong>git log</strong></p>

<p>用来查看git commit history，有许多有用的参数，比如<em>&#8211;stat</em>可以查看一些简略的信息，<em>-p -2</em>可以列出最近的两条entris，<em>&#8211;pretty=oneline</em>可以将history简略成一行，同样可以指定format——<em>&#8211;pretty=format:&#8221;%h - %an, %ar : %s</em>，而这些参数的意义如下:</p>

<pre><code>Option  Description of Output
%H  Commit hash
%h  Abbreviated commit hash
%T  Tree hash
%t  Abbreviated tree hash
%P  Parent hashes
%p  Abbreviated parent hashes
%an  Author name
%ae  Author e-mail
%ad  Author date (format respects the –date= option)
%ar  Author date, relative
%cn  Committer name
%ce  Committer email
%cd  Committer date
%cr  Committer date, relative
%s  Subject
</code></pre>

<p>另外还有<em>&#8211;graph</em>用来列出一个history graph，还有一些和时间相关的log，比如<em>&#8211;since=2.weeks</em>，列出两周内的commit信息&#8230;</p>

<pre><code>Option  Description
-(n)  Show only the last n commits
--since, --after  Limit the commits to those made after the specified date.
--until, --before  Limit the commits to those made before the specified date.
--author  Only show commits in which the author entry matches the specified string.
--committer  Only show commits in which the committer entry matches the specified strin
</code></pre>

<p><strong>git tag</strong></p>

<p>这个先不说了，感觉用不太到&#8230;</p>

<p><strong>git remote</strong></p>

<p>主要就7个命令：</p>

<pre><code>$ git remote add local_name url
$ git remote -v
$ git remote show local_name
$ git fetch [local_name | url]
$ git push [local_name | url] [branch_name]
$ git remote rename old_name new_name
$ git remote rm local_name
</code></pre>

<p><strong>tips and tricks</strong></p>

<p><em>git aliases</em>: 可以将很多命令缩写，比如:</p>

<pre><code>$ git config --global alias.co checkout
......
$ git config --global alias.unstage 'reset HEAD --'
$ git config --global alias.last 'log -1 HEAD'
</code></pre>

<h1>git branch</h1>

<p>git branch的抽象是这样子的，每次commit都会产生一个commit object:</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-5.png" title="commit object" alt="commit object" /></p>

<p>而一个branch则有一个个commit object通过pointer串起来的:</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-6.png" title="branch" alt="branch" /></p>

<p>在整个git目录中有一个很特别的index叫做HEAD，它指向了当前的branch:</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-7.png" title="current branch" alt="current branch" /></p>

<p>之后，就是对branch的一些操作:</p>

<pre><code>$ git checkout -b new_branch
</code></pre>

<p>这个等价于:</p>

<pre><code>$ git branch new_branch
$ git checkout new_branch
</code></pre>

<p><strong>merge</strong></p>

<p>merge需要先指定base的branch，然后再和一个新的branch进行合并：</p>

<pre><code>$ git checkout base_branch
$ git merge another_branch
</code></pre>

<p>如果两个branch不在一个history中(如图所示):</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-8.png" title="merge branch 1" alt="merge branch 1" /></p>

<p>则会找到一个common ancestor，之后创建一个新的commit object，它的parents为两个branch，</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-9.png" title="merge branch 2" alt="merge branch 2" /></p>

<p>如果两个branch有conflic，则需要通过diff工具进行merge，merge完之后用<em>git add</em>和<em>git commit</em>进行确认。</p>

<p><strong>delete branch</strong></p>

<p>删除一个branch的命令为:</p>

<pre><code>$ git branch -d branch_name
</code></pre>

<p><strong>remote branch</strong></p>

<p>主要是个命令的使用:</p>

<pre><code>$ git clone url
$ git fetch local_name
$ git push local_name branch_name
$ git checkout --track local_name/branch_name   # set up a tracking branch
$ git checkout -b new_branch_name local_name/branch_name
$ git push local_name :branch_name  # delete a remote branch from the server
</code></pre>

<p><strong>rebasing</strong></p>

<p>和merge不同，rebase是将一个branch的改动replay到另一个branch上，比如说，一个简单的例子:</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-10.png" title="rebase branch 1" alt="rebase branch 1" /></p>

<p>以experiment为current branch，<em>git merge master</em>的结果是这样的:</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-11.png" title="rebase branch 2" alt="rebase branch 2" /></p>

<p>而以experiment为current branch，<em>git rebase master</em>的结果是这样的:</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-12.png" title="rebase branch 3" alt="rebase branch 3" /></p>

<p>它的过程是这样的：先找到一个common ancestor，将两个branch的diff结果保存到一个文件里面，将当前的branch重新设成新的branch，之后将这些diff都应用到这个branch中。</p>

<p>对于rebase，有一点要注意的:</p>

<blockquote><p>Do not rebase commits that you have pushed to a public repository.</p></blockquote>


<p>否则会造成很多你意想不到的结果。</p>

<h1>git distribution</h1>

<p>/<em> fix me </em>/</p>

<h1>git tools</h1>

<p><strong>revision selection</strong></p>

<p>主要是几条命令:</p>

<pre><code>$ git log --abbrev-commit --pretty=oneline
$ git rev-parse topic1 
ca82a6dff817ec66f44342007202690a93763949
$ git reflog
$ git log -g branch     # see reflog of master
$ git show HEAD^    # see the parent commit of HEAD
$ git show HEAD~2   # see the grandparent commit of HEAD...
</code></pre>

<p>另外也可以看commit range，比如如图所示:</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-13.png" title="commit range" alt="commit range" /></p>

<p>branch1..branch2的意思是: all commits reachable by branch2 that aren&#8217;t reachable by branch1。</p>

<p>branch1&#8230;branch2的意思是: all commits that are reachable by either of two references but not by both of them。</p>

<p>所以:</p>

<pre><code>$ git log master..experiment
D 
C

$ git log experiment..master
F
E

$ git log master...experiment
F
E
D
C
</code></pre>

<p>另外下面三个命令是等价的:</p>

<pre><code>$ git log refA..refB
$ git log ^refA refB
$ git log refB --not refA
</code></pre>

<p><strong>interactive staging</strong></p>

<p>如果为<em>git add</em>加一个<em>-i</em>选项，则可以进入interactive的模式，之后会有几个命令让你选择:</p>

<pre><code>Commands * 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help 
</code></pre>

<p>之后就可以交互式地stage每个文件，同时，还可以stage文件的一部分（5：patch），很方便。</p>

<p><strong>stashing</strong></p>

<p>stashing的作用是将当前目录的状态（不管是modified还是staged的文件）都保存起来，然后做其它的工作，在之后可以从中恢复过来。</p>

<p>另外，可以用<em>git stash list</em>列出当前被stash的内容，之后用<em>git stash apply</em>来应用某个，或者<em>git stash drop</em>来丢弃某个，或者直接用<em>git stash pop</em>将最近的一个apply然后drop。</p>

<p>还有一种比较牛逼但比较用不到的场景，你apply了一个stash，do some work，然后想unapply之前的工作（指originally come from the stash），可以用这个命令:</p>

<pre><code>$ git stash show -p stash@{0} | git apply -R
</code></pre>

<p><strong>rewriting history</strong></p>

<p>之前有说过<em>git commit &#8211;amend</em>，这里要注意的是这个命令就像一个小的rebase，如果你已经push到remote的话最后就不要用这条命令了。</p>

<p>如果你想要改之前的commit，那么就需要用<em>git rebase</em>了，加上<em>-i</em>选项:</p>

<pre><code>$ git rebase -i HEAD~3
</code></pre>

<p>之后会有几个选项让你选:</p>

<pre><code>p, pick = use commit
r, reword = use commit, but edit the commit message
e, edit = use commit, but stop for amending
s, squash = use commit, but meld into previous commit
f, fixup = like "squash", but discard this commit's log message
x, exec = run command (the rest of the line) using shell
</code></pre>

<p>这里我遇到一个问题: 在退出编辑器的时候报错——could not execute editor，解决的办法是:</p>

<pre><code>$ git config --global core.editor "/usr/bin/vim"
</code></pre>

<p>总的来说这是一个很强大的功能，可以修改commit message，可以reordering commit，可以squashing commit，也可以splitting commit，还有一个非常牛逼的filter-branch功能，可以用来把一个文件从每次的commit中删除。在这里就不详细介绍了。</p>

<p><strong>debugging with git</strong></p>

<p>/<em> fix me </em>/</p>

<p><strong>submodules</strong></p>

<p>submodule的作用是将某段代码目录作为子目录导入你的主工程中，让别人可以下载，另外，由于这个子工程可能是别人开发的，所以需要分开来commit。</p>

<p>可以通过以下命令来建立submodule:</p>

<pre><code>$ git submodule add url local_module_name
</code></pre>

<p>但是如果你直接用<em>git clone</em>是不会把这个submodule下下来的，需要运行以下两个命令:</p>

<pre><code>$ git submodule init
$ git submodule update
</code></pre>

<p><strong>subtree merging</strong></p>

<p>/<em> fix me </em>/</p>

<h1>git customization</h1>

<p><strong>git configuration</strong></p>

<p>一般，git的配置参数在/etc/gitconfig和~/.gitconfig两个文件里面。</p>

<p>git可以设置默认的commit message:</p>

<pre><code>$ git config --global commit.template &lt;file&gt;
</code></pre>

<p>还有其它的:</p>

<pre><code>$ git config --global core.pager [more | less | '']
$ git config --global help.autocorrect [0 | 1]
$ git config --global color.ui [true | false]
$ git config --global color.branch [true | false | always]
$ git config --global color.diff [true | false | always]
......
</code></pre>

<p><strong>git attributes</strong></p>

<p>可以在.gitattributes中加入<em><em>.b binary</em>来表示以b结尾的文件都是binary file，这样在</em>git diff<em>的时候就不会diff它了，还可以通过</em>*.doc diff=word*来表示用word来进行diff，而word可以通过:</p>

<pre><code>$ git config diff.word.textconv strings
</code></pre>

<p>来进行设置。</p>

<p><strong>git hooks</strong></p>

<p>这是一个很强大的工具，你可以将所有可执行脚本通过合法的命名方式放在.git/hooks目录下，主要分为client-side和server-side的hooks，比如在client-side中，可以规定在commit之前运行一个脚本进行检查&#8230;</p>

<p>这是一个蛮有趣的话题，我会单独写一篇文章来说明下~</p>

<hr />

<p>以上基本上就是progit的全部内容，还有一些我觉得暂时还用不到就没有详细写，有一些我可能还会再单独更详细地描述。</p>

<p>总之，git真的是一个很神奇的用于提高开发效率和可靠性的工具，如果能熟练地掌握它的用法将能极大地提高工作效率。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[progit reading 1]]></title>
    <link href="http://ytliu.github.com/blog/2012/09/16/progit-reading-1/"/>
    <updated>2012-09-16T22:54:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/09/16/progit-reading-1</id>
    <content type="html"><![CDATA[<p>花了大概两周的时间吧，把《progit》那本书看完了（我看书实在是比较慢，特别是这种英文书）。发觉git实在是一个太强大的工具了，以至于我看完了一遍又把前面所说的功能忘记了。。。orz。。。于是乎决定花一周时间重新回顾一下，顺便把一些牛逼的地方记下来。</p>

<h2>Plumbing &amp; Porcelain</h2>

<p>因为这是progit的最后一章，也是我刚刚看完的一章，还比较有印象。更重要的是这是git的internal的机制，对于深入理解git有很大的帮助，所以想先把这章啃下来。</p>

<p>porcelain是瓷器的意思，在这里是指git中比较user-friendly的命令，比如文中介绍的将近30条git命令，包括checkout, brance, commit, 以及所有的remote命令等等。而plumbing是水管的意思，和porcelain相对的，指的是一些和unix style类似的low-level的可以直接在脚本中执行的命令（其实我也没搞懂为什么要交porcelain和plumbing两个名字，感觉没什么关系啊？）。事实上，如果我没有理解错的话，porcelain在git中应该就是由一系列plumbing命令组成的。比如git commit命令就是由一个叫做“git commit-tree”的plumbing命令完成的，至于什么是commit-tree，以及这个tree是怎么形成的，这个会再接下来慢慢解释。</p>

<p>首先来看下.git目录下都有些什么。</p>

<pre><code>$ ls .git
HEAD
config
description
hooks/
index
info/
objects/
refs/
</code></pre>

<p>这些是在<em>git init</em>的时候初始化就默认产生的，其中description现在还不需要考虑，config主要用来配置一些program-specific的参数选项，info是一个目录，包含了一些需要被ignore的文件模式，而hooks定义了一些client或server端用于用户进行脚本定制的功能，这会在接下来详细介绍。而在这一节中主要描述了以下四个对象：<strong>HEAD</strong>，<strong>index</strong>，<strong>objects</strong>，<strong>refs</strong>。这是git最internal的部分。</p>

<h2>git objects</h2>

<p>object主要由两种组成：<em>tree object</em>和<em>commit object</em>，在介绍这两个object之前首先要说明下git的文件系统，git是一个content-addressable文件系统，换句话来说，对于git的核心存储来说仅仅是一个key-value数据库，你能向里面插入任何数据，并得到一个相对应的hash值用于之后的访问。这里有两个plumbing命令<em>hash-object</em>和<em>cat-file</em>，比如在新建的git仓库中输入以下命令；</p>

<pre><code>$ echo 'test content' | git hash-object -w --stdin
</code></pre>

<p><strong>-w</strong>表示对该object进行存储，将会返回：</p>

<pre><code>d670460b4b4aece5915caf5c68d12f560a9fe3e4
</code></pre>

<p>这个时候你查看.git/objects目录下的内容将会看到：</p>

<pre><code>$ find .git/objects -type f
  .git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
</code></pre>

<p>其中d6是这个hash值的前两个数字，如果运行<em>cat-file</em>将会得到该object：</p>

<pre><code>$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
  test content
</code></pre>

<p><strong>-p</strong>表示把里面的内容打印出来，而另一个参数<strong>-t</strong>这是将该object的类型打印出来：</p>

<pre><code>$ git cat-file -t d670460b4b4aece5915caf5c68d12f560a9fe3e4
  blob
</code></pre>

<p>注意这里的<em>blob</em>是一种type，它是属于整个<em>tree object</em>的叶子节点的类型，而那些中间节点都可以叫做tree。于是现在就可以详细来说说<em>tree object</em>了：</p>

<h3>tree object</h3>

<p>首先我们来运行以下的命令：</p>

<pre><code>$ vi test1
$ vi test2
$ find .git/objects/ -type f
$ git add .
$ find .git/objects/ -type f
  .git/objects//18/0cf8328022becee9aaa2577a8f84ea2b9f3827
  .git/objects//9f/71d140ff7712ec3a6dda42c09078fd290a3a61
$ git ci -m "first commit"
$ find .git/objects/ -type f
  .git/objects//18/0cf8328022becee9aaa2577a8f84ea2b9f3827
  .git/objects//92/bfc1480834507340a9bb30ac05fb4965785875
  .git/objects//9f/71d140ff7712ec3a6dda42c09078fd290a3a61
  .git/objects//dc/7a09861107e178fa0016fb48300b569de5c64c
$ git cat-file -p 92bf
  tree dc7a09861107e178fa0016fb48300b569de5c64c
  author ytliu &lt;mctrain016@gmail.com&gt; 1347865347 +0800
  committer ytliu &lt;mctrain016@gmail.com&gt; 1347865347 +0800

  first commit
$ git cat-file -p dc7a
  100644 blob 9f71d140ff7712ec3a6dda42c09078fd290a3a61 test1
  100644 blob 180cf8328022becee9aaa2577a8f84ea2b9f3827 test2
$ git cat-file -t dc7a
  tree
</code></pre>

<p>到目前为止，在first commit之后，整个数据存储的树结构是这样的：</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-1.png" title="tree object 1" alt="tree object 1" /></p>

<p>记下来我们新建一个目录dir，并再次commit一次：</p>

<pre><code>$ mkdir dir
$ vi dir/test3
$ git add .                 
$ find .git/objects/ -type f
  .git/objects//18/0cf8328022becee9aaa2577a8f84ea2b9f3827
  .git/objects//92/bfc1480834507340a9bb30ac05fb4965785875
  .git/objects//9f/71d140ff7712ec3a6dda42c09078fd290a3a61
  .git/objects//dc/7a09861107e178fa0016fb48300b569de5c64c
  .git/objects//df/6b0d2bcc76e6ec0fca20c227104a4f28bac41b
$ git ci -m "second commit" 
$ find .git/objects/ -type f
  .git/objects//18/0cf8328022becee9aaa2577a8f84ea2b9f3827
  .git/objects//41/77687db29c641515b10f13536dd70fae4ed142
  .git/objects//84/ddd13670be5f3636586915421cd98035ad9c66
  .git/objects//92/bfc1480834507340a9bb30ac05fb4965785875
  .git/objects//9f/71d140ff7712ec3a6dda42c09078fd290a3a61
  .git/objects//c5/04b82867a9a4104974edd54c56f01856d9426b
  .git/objects//dc/7a09861107e178fa0016fb48300b569de5c64c
  .git/objects//df/6b0d2bcc76e6ec0fca20c227104a4f28bac41b
$ git cat-file -t 4177      
  tree
$ git cat-file -p 4177
  040000 tree c504b82867a9a4104974edd54c56f01856d9426b dir
  100644 blob 9f71d140ff7712ec3a6dda42c09078fd290a3a61 test1
  100644 blob 180cf8328022becee9aaa2577a8f84ea2b9f3827 test2
$ git cat-layoutfile -p 84dd
  tree 4177687db29c641515b10f13536dd70fae4ed142
  parent 92bfc1480834507340a9bb30ac05fb4965785875
  author ytliu &lt;mctrain016@gmail.com&gt; 1347865426 +0800
  committer ytliu &lt;mctrain016@gmail.com&gt; 1347865426 +0800

second commit
$ git cat-file -p c504
  100644 blob df6b0d2bcc76e6ec0fca20c227104a4f28bac41b test3
</code></pre>

<p>可以看出，现在多了两个<em>tree object</em>，当前的树结构是这样的：</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-2.png" title="tree object 2" alt="tree object1 2" /></p>

<p>也就是说在新建一个dir的时候会新建一个<em>tree object</em>，而它指向的是这个dir下的blob或其它tree，另外，在进行一次commit的时候也会新建一个<em>tree object</em>，其包含的内容是staging area里面的所有东西。另外，git也提供了和<em>tree object</em>相关的plumbing命令：<em>write-tree</em>和<em>read-tree</em>。<em>write-tree</em>用于新建一个tree，把staging area里面的object就涵盖进来，而<em>read-tree</em>则是将一个tree读入staging area，比如运行以下命令：</p>

<pre><code>$ git write-tree
  4177687db29c641515b10f13536dd70fae4ed142
$ git cat-file -p 4177
  040000 tree c504b82867a9a4104974edd54c56f01856d9426b dir
  100644 blob 9f71d140ff7712ec3a6dda42c09078fd290a3a61 test1
  100644 blob 180cf8328022becee9aaa2577a8f84ea2b9f3827 test2
$ git read-tree --prefix=bak 4177
$ git write-tree
  389a980f31bfb78f9bf7e41d85fb3a1736a54f8c
$ git cat-file -p 389a
  040000 tree 4177687db29c641515b10f13536dd70fae4ed142 bak
  040000 tree c504b82867a9a4104974edd54c56f01856d9426b dir
  100644 blob 9f71d140ff7712ec3a6dda42c09078fd290a3a61 test1
  100644 blob 180cf8328022becee9aaa2577a8f84ea2b9f3827 test2
$ ls                  
  dir test1 test2
</code></pre>

<p>可以看出<em>write-tree</em>新建了一个<em>tree object</em>，并通过read-tree被标为bak，成为另一个tree的subtree，但是我们通过<strong>ls</strong>并不能显示出来这个tree——bak。</p>

<h3>commit object</h3>

<p>在之前的cat-file命令中可以看到有另一类object</p>

<pre><code>$ git cat-file -p 84dd
  tree 4177687db29c641515b10f13536dd70fae4ed142
  parent 92bfc1480834507340a9bb30ac05fb4965785875
  author ytliu &lt;mctrain016@gmail.com&gt; 1347865426 +0800
  committer ytliu &lt;mctrain016@gmail.com&gt; 1347865426 +0800

  second commit
$ git cat-file -t 84dd
  commit
</code></pre>

<p>这就是一个<em>commit object</em>，是在每一次commit的时候产生的。可以看到，它所指向的<em>tree object</em>为4177，即：</p>

<pre><code>$ git cat-file -p 4177
  040000 tree c504b82867a9a4104974edd54c56f01856d9426b dir
  100644 blob 9f71d140ff7712ec3a6dda42c09078fd290a3a61 test1
  100644 blob 180cf8328022becee9aaa2577a8f84ea2b9f3827 test2
</code></pre>

<p>这个很好理解，当然了，相应与<em>write-tree</em>，同样也有一个<em>commit object</em>相关的plumbing命令：<em>commit-tree</em>，用法大概是这样的：</p>

<pre><code>$ echo 'first commit' | git commit-tree 4177
  d8c7554eb5ee1a0eca359f3d58b99529ac94529c
$ echo 'second commit' | git commit-tree 389a -p d8c7 
  fc45c76849a24fe3e6b98fec5f17194c0c5f52a3
......
</code></pre>

<p>具体的就不详说了，前面的echo是commit message，<strong>-p</strong>选项表示parent。这个时候如果你运行git log:</p>

<pre><code>$ git log
  commit 84ddd13670be5f3636586915421cd98035ad9c66
  Author: ytliu &lt;mctrain016@gmail.com&gt;
  Date:   Mon Sep 17 15:03:46 2012 +0800

  second commit

  commit 92bfc1480834507340a9bb30ac05fb4965785875
  Author: ytliu &lt;mctrain016@gmail.com&gt;
  Date:   Mon Sep 17 15:02:27 2012 +0800

  first commit
</code></pre>

<p>它只显示了之前commit的记录，那么新commit的third commit和fourth commit呢？原因很简单，因为我在commit-tree third commit的时候并没有指定<strong>-p</strong>，所以它并没有接着second commit下去，而是自己新开了一个：</p>

<pre><code>$ git log fc45
  commit fc45c76849a24fe3e6b98fec5f17194c0c5f52a3
  Author: ytliu &lt;mctrain016@gmail.com&gt;
  Date:   Mon Sep 17 16:20:10 2012 +0800

  fourth commit

  commit d8c7554eb5ee1a0eca359f3d58b99529ac94529c
  Author: ytliu &lt;mctrain016@gmail.com&gt;
  Date:   Mon Sep 17 16:18:13 2012 +0800

  third commit
</code></pre>

<p>当然，我也没有指定它们属于那个branch，所以它现在是属于一个没有被记录的detached HEAD状态，不属于任何一个branch。如果需要为它加一个branch，可以用：</p>

<pre><code>$ git co fc4f -b new_branch
</code></pre>

<p>到目前为止，整个git仓库的objects的关系可以用下图来表示：</p>

<p><img src="http://ytliu.github.com/images/2012-09-16-3.png" title="object 1" alt="object 1" /></p>

<h2>git references</h2>

<p>其实.git/refs的目的主要是为了更方便用户记忆object，而不用每次都用一个那么长的SHA-1，比如：</p>

<pre><code>$ cat .git/refs/heads/master 
  84ddd13670be5f3636586915421cd98035ad9c66
</code></pre>

<p>这个就是传说中的master是怎么被关联到最新的commit的。你可以用git提供的plumbing命令<em>update-ref</em>来更新不同的ref：</p>

<pre><code>$ git update-ref refs/heads/master fc45
</code></pre>

<p>这个时候master就指向fourth commit了。当然你也可以用这个命令新建ref：</p>

<pre><code>$ git update-ref refs/heads/test 84dd
$ git co test
$ git log
  commit 84ddd13670be5f3636586915421cd98035ad9c66
  Author: ytliu &lt;mctrain016@gmail.com&gt;
  Date:   Mon Sep 17 15:03:46 2012 +0800

  second commit

  commit 92bfc1480834507340a9bb30ac05fb4965785875
  Author: ytliu &lt;mctrain016@gmail.com&gt;
  Date:   Mon Sep 17 15:02:27 2012 +0800

  first commit
</code></pre>

<p>还有一种reference是remote <em>reference</em>，可以用remote add来添加：</p>

<pre><code>$ git remote add origin git@github.com:something.git
</code></pre>

<p>然后吧本地的master分支push上去。</p>

<pre><code>$ git push origin master
</code></pre>

<p>然后你就可以在refs/remotes/origin/master下看到当前最新的分支情况了~</p>

<h2>HEAD</h2>

<p>HEAD其实就是一个reference指向当前branch的引用：</p>

<pre><code>$ cat .git/HEAD
  ref: refs/heads/test
</code></pre>

<p>我们可以直接修改这个文件，也可以用git提供的命令<em>symbolic-ref</em>来修改：</p>

<pre><code>$ git symbolic-ref HEAD refs/heads/test
$ cat .git/HEAD
  ref: refs/heads/test
</code></pre>

<h2>packfiles</h2>

<p>接下来是一个很重要的概念——packfile。具体的场景是这样的：</p>

<p>假设我们有一个很大的文件largefile，它的hash是fb699e017d85f1f0d037f0417a7e17a449533ecc：</p>

<pre><code>$ git cat-file -s fb69
  132480
</code></pre>

<p><strong>-s</strong>表示object的大小，这个时候我们对其进行了一个小小的修改，并重新commit：</p>

<pre><code>$ echo "modify a little" &gt;&gt; largefile
$ git add largefile
$ git ci -m "modify largefile"
</code></pre>

<p>这个时候largefile的hash就变成了084d9fa99e4558d38cba7006e3b28f6c87a8fd86；</p>

<pre><code>$ git cat-file -s 084d
  132496
</code></pre>

<p>可以看出，在git里面存了两个基本差不多的largefile的object，这样是非常浪费空间的。其实git在disk上存的object是一种叫做<em>loose object</em>的格式，而在一段时间之后git会将这些<em>loose object</em>打包。当然这种情况一般会在两种情况下发生: 执行<em>git gc</em>命令，以及push到remote server：</p>

<pre><code>$ git gc
$ find .git/objects/ -type f
  .git/objects//1e/f02bee3de76100febdefb8c55bf99fcfbdf714
  .git/objects//45/699e25f45a743e08c0909ce1925641f9c03e2e
  .git/objects//info/packs
  .git/objects//pack/pack-4ba1c4a110a95c95d7fc1a33d0c5916bb4c10a34.idx
  .git/objects//pack/pack-4ba1c4a110a95c95d7fc1a33d0c5916bb4c10a34.pack
</code></pre>

<p>可以看到，现在只剩下5行了，若我们用plumbing命令verify-pack来查看的话可以看到：</p>

<pre><code>$ git verify-pack -v .git/objects/pack/pack-4ba1c4a110a95c95d7fc1a33d0c5916bb4c10a34.pack 
  eb5efdaed6e57b4356a6758e77c998f1efd009ed commit 221 151 12
  5a937dca309316f541a433e624868dfe5196c165 commit 218 150 163
  fc45c76849a24fe3e6b98fec5f17194c0c5f52a3 commit 218 149 313
  84ddd13670be5f3636586915421cd98035ad9c66 commit 218 149 462
  d8c7554eb5ee1a0eca359f3d58b99529ac94529c commit 43 53 611 1 84ddd13670be5f3636586915421cd98035ad9c66
  92bfc1480834507340a9bb30ac05fb4965785875 commit 169 119 664
  902c38d7fbadea10287a581b9c557fea63d8b00c tree   133 131 783
  c504b82867a9a4104974edd54c56f01856d9426b tree   33 44 914
  df6b0d2bcc76e6ec0fca20c227104a4f28bac41b blob   6 15 958
  084d9fa99e4558d38cba7006e3b28f6c87a8fd86 blob   132496 316 973
  9f71d140ff7712ec3a6dda42c09078fd290a3a61 blob   7 16 1289
  180cf8328022becee9aaa2577a8f84ea2b9f3827 blob   6 15 1305
  f5adadb9b7cf88c0aa57bc4c810d5c2a68d93c5c tree   133 131 1320
  fb699e017d85f1f0d037f0417a7e17a449533ecc blob   13 22 1451 1 084d9fa99e4558d38cba7006e3b28f6c87a8fd86
  389a980f31bfb78f9bf7e41d85fb3a1736a54f8c tree   126 126 1473
  4177687db29c641515b10f13536dd70fae4ed142 tree   96 98 1599
  dc7a09861107e178fa0016fb48300b569de5c64c tree   66 70 1697
  non delta: 15 objects
  chain length = 1: 2 objects
  .git/objects/pack/pack-4ba1c4a110a95c95d7fc1a33d0c5916bb4c10a34.pack: ok
</code></pre>

<p>原来第一个largefile的object fb69 现在指向了084d，而其大小也变成了13，而084d作为修改过的largefile，大小还是132496。另外，git还把其它的一些类似的object进行了pack，更充分地缩减了空间。</p>

<h2>refspec</h2>

<p>这个是和remote branch相关的，即当你运行了<em>git remote add</em>命令后，在.git/config下面会有一个诸如：</p>

<pre><code>[remote "origin"]
url = git@github.com:something.git
fetch = +refs/heads/*:refs/remotes/origin/*
</code></pre>

<p>的entry，其中origin是remote端在本地的reference，url是remote端的地址，fetch是你在执行fetch命令时的操作，格式为(+)src:dst，其中src是remote side的匹配模式，dst是local side的匹配模式，+为可选，表示即使不是fast-forward也要更新reference。当然你也可以在每次fetch的时候手动指定。另外对于push同样有这种模式，只需要在config中加上一个push行就行了。</p>

<h2>remove object</h2>

<p>最后一个想讲的是如何真正地删除一个object。比如你有一个很大的object，你用<em>git rm</em>把他删除了，但是你并没有真正地把它从怎个历史中删除，任何一个其他人要fetch你的git仓库，都会把这个很大的object也一起fetch过去。那么，要如何才能真正意义上地删除一个大的object呢？</p>

<p>/<em> fix me </em>/</p>

<hr />

<p>接下来我会从头开始回顾：<em>git basic</em>, <em>git branch</em>, <em>git distribution</em>, <em>git tools</em>, 以及<em>git customization</em>。</p>
]]></content>
  </entry>
  
</feed>
