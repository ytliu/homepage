<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Android | Mctrain's Blog]]></title>
  <link href="http://ytliu.github.com/blog/categories/android/atom.xml" rel="self"/>
  <link href="http://ytliu.github.com/"/>
  <updated>2012-12-09T13:39:43+08:00</updated>
  <id>http://ytliu.github.com/</id>
  <author>
    <name><![CDATA[Liu Yutao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ASLR in android]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/09/aslr-in-android/"/>
    <updated>2012-12-09T11:07:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/09/aslr-in-android</id>
    <content type="html"><![CDATA[<p>这两篇看了两篇文章分析<a href="https://blog.duosecurity.com/2012/02/a-look-at-aslr-in-android-ice-cream-sandwich-4-0/" title="asli in 4.0">aslr in androi4.0</a>和<a href="https://blog.duosecurity.com/2012/07/exploit-mitigations-in-android-jelly-bean-4-1/" title="aslr in 4.1">android 4.1</a>，觉得蛮有趣的，这里简单介绍下。</p>

<h3>ASLR with Liux Kernel</h3>

<p>首先介绍下linux中的ASLR，ASLR可以对任意内存进行随机化：</p>

<ul>
<li>stack：The userspace stack mapping set up by the kernel during exec(2) should be sufficiently randomized. Stack randomization is performed by the randomize_stack_top() function.</li>
<li>Heap：The heap location returned by the brk(2) system call when a program is first exec’ed should be randomized. Heap randomization is performed by the arch_randomize_brk() function.</li>
<li>Libs and mmap：After NX was introduced, static library mapping led to the popularity of ret-to-libc and more generic ret-to-lib attacks. The location of libraries and other mmap’ed regions should be randomized.</li>
<li>Exec：Even if you’re randomized the mapping of all the shared libaries that an executable uses, you still need to randomize the location of the executable itself when it is mapped into the address space. Otherwise, the executable mapping can be used as a source for ROP gadgets.</li>
<li>Linker：On most Linux systems, the ld.so dynamic linker provided by glibc can self-relocate itself, so its mapping is randomized. However, as we’ll see, this isn’t the case for all linkers.</li>
<li>VDSO(Virtual Dynamically-linked Shared Object)：an executable mapping of a virtual shared library provided by the kernel for syscall transitions. However, most Android devices run on the ARM architecture, which doesn’t use a VDSO.</li>
</ul>


<h3>ASLR in Android 2.x</h3>

<p>在Android 2.x开始，唯一对ASLR支持的是stack（这可以通过多次查看/proc/pid/maps来发现），其通过load_elf_binary()函数调用randomize_stack_top()来实现：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">ifndef</span> <span class="n">STACK_RND_MASK</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">define</span> <span class="n">STACK_RND_MASK</span> <span class="p">(</span><span class="mh">0x7ff</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="mi">12</span><span class="p">))</span> <span class="o">/&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="mi">8</span><span class="n">MB</span> <span class="n">of</span> <span class="n">VA</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;/&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">endif</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">randomize_stack_top</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_top</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">random_variable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">flags</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">PF_RANDOMIZE</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span>
</span><span class='line'>            <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">personality</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">ADDR_NO_RANDOMIZE</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">random_variable</span> <span class="o">=</span> <span class="n">get_random_int</span><span class="p">()</span> <span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span> <span class="n">STACK_RND_MASK</span><span class="p">;</span>
</span><span class='line'>        <span class="n">random_variable</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">ifdef</span> <span class="n">CONFIG_STACK_GROWSUP</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack</span><span class="err">\</span><span class="n">_top</span><span class="p">)</span> <span class="o">+</span> <span class="n">random_variable</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="k">else</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack</span><span class="err">\</span><span class="n">_top</span><span class="p">)</span> <span class="o">-</span> <span class="n">random_variable</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="n">endif</span><span class="o">&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h3>ASLR in Android 4.0</h3>

<p>而在4.0，即其所谓的支持ASLR的版本上，其实ASLR也仅仅增加了对libc等一些shared libraries进行了随机化，而对于heap, executable和linker还是static的。</p>

<p>对于heap的随机化来说，可以通过</p>

<pre><code>echo 2 &gt; /proc/sys/kernel/randomize_va_space
</code></pre>

<p>来开启。</p>

<p>而对于executable的随机化，由于大部分的binary没有加GCC的-pie -fPIE选项，所以编译出来的是EXEC，而不是DYN这种shared object file，因此不是PIE（Position Independent Executable），所以没有办法随机化；</p>

<p>同样的linker也没有做到ASLR。</p>

<h3>ASLR in Android 4.1</h3>

<p>终于，在4.1 Jelly Bean中，Android终于支持了所有内存的ASLR。在第二个对4.1ASLR介绍中，作者列出了从Android 1.5开始用到的安全加强机制：</p>

<h5>Android 1.5+</h5>

<ul>
<li>ProPolice to prevent stack buffer overruns (-fstack-protector)</li>
<li>safe_iop to reduce integer overflows</li>
<li>Extensions to OpenBSD dlmalloc to prevent double free() vulnerabilities and to prevent chunk consolidation attacks. Chunk consolidation attacks are a common way to exploit heap corruption.</li>
<li>OpenBSD calloc to prevent integer overflows during memory allocation</li>
</ul>


<h5>Android 2.3+</h5>

<ul>
<li>Format string vulnerability protections (-Wformat-security -Werror=format-security)</li>
<li>Hardware-based No eXecute (NX) to prevent code execution on the stack and heap</li>
<li>Linux mmap_min_addr to mitigate null pointer dereference privilege escalation (further enhanced in Android 4.1)</li>
</ul>


<h5>Android 4.0+</h5>

<ul>
<li>Address Space Layout Randomization (ASLR) to randomize key locations in memory</li>
</ul>


<h5>Android 4.1+</h5>

<ul>
<li>PIE (Position Independent Executable) support</li>
<li>Read-only relocations / immediate binding (-Wl,-z,relro -Wl,-z,now)</li>
<li>dmesg_restrict enabled (avoid leaking kernel addresses)</li>
<li>kptr_restrict enabled (avoid leaking kernel addresses)</li>
</ul>


<p>在Android 4.1中，基本上所有binary都被编译和连接成了PIE模式（可以通过readelf查看其Type）。所以，相比于4.0，4.1对Heap，executable和linker都提供了ASLR的支持。</p>

<p>另外，4.1还增加了几个小的安全加强机制：</p>

<ul>
<li>大部分系统binary都添加了RELRO和BIND_NOW的编译flag，起作用主要是将GOT表设置成只读，防止之前出现过的<a href="http://jon.oberheide.org/files/bsides11-dontrootrobots.pdf" title="don't root robot">Gingerbreak</a>攻击。</li>
<li>另外，对dmesg_restrict / kptr_restrict的sysctl的利用，有效防止了一些低权限的用户从dmesg/klogctl中读取一些敏感信息，或者读取一些kernel内存中的敏感数据（比如很多/proc下的接口）。</li>
</ul>


<h3>What's next</h3>

<p>之后作者还提到一些还需要继续努力的事：</p>

<ul>
<li>ASLR的弱点 - 32-bit，容易破解</li>
<li>一些安全的libc调用，比如FORTIFY_SOURCE</li>
<li>PaX Hardening，虽然很多不适合手机，但是也可以cherry pick一些啦</li>
<li>MAC/RBAC，其实这个现在也已经有了，比如SEAndroid...</li>
<li>Mandatory Code Signing，向IPhone学习吧</li>
</ul>


<p>另外，作者还提到一个Zygote的问题，为了性能问题，现在Android上所有的进程都是Zygote fork出来的，也就是说很多的地址空间在fork出来后是固定不变的，这样也就出现了一种可能性：a malicious app on a victim’s device leaks address mappings from its own process off to an attacker to assist in exploiting another process (eg. the browser) that might have higher privilege or valuable data.</p>

<p>当然，作者认为这种场景可能性比较小，所以还不算一个大问题。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[get root in my android]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/08/get-root-in-my-android/"/>
    <updated>2012-12-08T16:28:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/08/get-root-in-my-android</id>
    <content type="html"><![CDATA[<p>首先申明，这其实并不是一篇android root教程，因为我并没有用什么exploit的方法，也没有用CWM等这些第三方ROM，而是该了ASOP，然后把它刷到机子上，然后对其进行所谓的root，装了一个dSploit和busybox。</p>

<p>具体的做法是这样的：</p>

<ul>
<li>更新到ASOP的最新版 - 4.2.4</li>
<li>lunch full-maguro, make</li>
<li>fastboot to smartphone</li>
<li>把手机连到电脑上，通过adb shell上去，进入su模式</li>
<li>通过<a href="http://www.cypherpunk.at/2011/10/08/manual-rooting-android-on-linux-2/" title="manual rooting">这里</a>的方法进行root</li>
</ul>


<p>即：</p>

<ul>
<li>mount -o remount,rw /dev/block/.../system /system</li>
<li>mv path/to/modified/su /system/xbin/su</li>
<li>mount -o remount,ro /dev/block/.../system /system</li>
</ul>


<p>但是发现失败了，我怀疑是su这个文件不兼容，于是，我想了一个更贱的方法：</p>

<ul>
<li>把ASOP代码中的/system/extras/su/su.c该掉，把检查的部分全部去掉</li>
<li>然后刷机</li>
</ul>


<p>这样就直接root了！不过这只能用于我的测试机啦，正常的手机千万不敢那么做，太危险了！</p>

<hr />

<p>另外，我用了两款软件，<a href="https://github.com/evilsocket/dsploit" title="dsploit">dSploit</a>和<a href="github.com/mwrlabs/mercury" title="mercury">Mercury</a>，而且都有源码，准备之后两周研究下，学习下android编程和如何进行penetration</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[connect smartphone to android emulator]]></title>
    <link href="http://ytliu.github.com/blog/2012/12/01/connect-smartphone-to-android-emulator/"/>
    <updated>2012-12-01T15:37:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/12/01/connect-smartphone-to-android-emulator</id>
    <content type="html"><![CDATA[<p>这两天碰到一个难题，如何让手机中的某应用程序通过网络连接PC中的android emulator里面的服务。</p>

<p>即我在emulator里面开启了一个服务，该服务通过socket监听2012端口，那么在我的手机中，如何通过socket连接到这个服务中，也就是说，我的IP要设为什么，端口号要设为什么？</p>

<p>这个问题在于PC为emulator分配了一个端口号（这里为5554），所以在PC中可以很方便地和emulator进行交互，但是emulator并没有一个对外可见的IP地址。</p>

<p>在<a href="http://stackoverflow.com,%20stackoverflow">stackoverflow</a>上查了好久，有一个说<a href="http://stackoverflow.com/questions/7108326/how-can-we-change-the-ip-of-android-emulator">如何连接两个emulator的</a>，还有一个<a href="http://stackoverflow.com/questions/7108326/how-can-we-change-the-ip-of-android-emulator">介绍了一个非常复杂但经过我的测试有效的方法</a>。这里简单介绍一下：</p>

<h3>两个emulator相连</h3>

<p>为了两个emulator能进行网络相连，首先必须满足一下三个条件：</p>

<ul>
<li>A为PC</li>
<li>B为运行在A中的一个emulator，端口为5554</li>
<li>C为运行在A中的另一个emulator，端口为5556</li>
</ul>


<p>是不是很废话...好了，进入正题，我们要做的就是一下三步：</p>

<p>在B中起一个server，可以让C进行连接</p>

<pre><code>B listening on 10.0.2.15:80
</code></pre>

<p>telnet到B的console里面对端口进行重定向：</p>

<pre><code>$ telnet localhost 5554
# redir add tcp:8080:90
</code></pre>

<p>在C中连接10.0.2.2:8080就可以和B进行交互了。</p>

<p>这里补充一下，你如果进入adb shell在里面查看自己的IP会发现其为10.0.2.15，其通过10.0.2.2和PC进行连接。redir相当于将到达PC的8080端口的信息全部重定向到5554端口emulator的80端口。这样就完成而来emulator之间的连接了。</p>

<hr />

<h3>手机和emulator相连</h3>

<p>照理来说按照上面的说法，手机和emulator的连接应该也很简单，只需要将手机连接到PC的ip加上一个端口P1，然后将P1重定向到emulator中server监听的端口P2就可以了。</p>

<p>但是显示总是残酷的，包括redir和adb forwarding（功能似乎和redir是一样的）都只能将PC自己向端口P中写的信息forward到emulator里面的端口，而不能把其它地方从端口进来的forward。</p>

<p>于是在<a href="http://stackoverflow.com/questions/7108326/how-can-we-change-the-ip-of-android-emulator%20question">这个问题</a>的回答中提到一种方法，在中间再加一个proxy，接下来我来介绍下这种方法：</p>

<p>这是现在的框架：</p>

<p><img src="http://ytliu.github.com/images/2012-12-01-1.png" title="framework of smartphone and emulator" alt="framework" /></p>

<p>原理和两个模拟器相连很像，但是中间加了一个proxy：</p>

<ul>
<li>首先在emulator中server监听2012端口</li>
<li>在PC上通过<em>adb forward</em>命令将PC上的2012端口forward到emulator中的2012端口（<em>adb forward tcp:2012 tcp:2012</em>）</li>
<li>在proxy中将从外面来的2013端口forward到2012端口</li>
<li>而在手机端则直接向PC的2013端口发送数据</li>
</ul>


<p>经过尝试这样是可行的。</p>

<hr />

<h3>tap/tun</h3>

<p>虽然说上面的方法是可行的，但是并没有很好地解决这个问题，因为如果是通过这种方法，则我的emulator没开启一个server，都要起一个相应的proxy，这样就显得很废。有没有什么一劳永逸的方法呢？</p>

<p>听斌哥说之前他在配qemu的时候通过tap/tun的技术来配置qemu的网络，于是我也尝试着配置tap/tun，不过虽然已经将其在PC中启动好了，但是由于对其原理还是不清楚，所以还是没有搞明白要如何使得emulator有一个自己独立的对外可见的IP，这块内容可能会等自己完全搞明白了再写吧。</p>

<p>这里推荐下wikibook中对qemu networking的配置：</p>

<p>http://en.wikibooks.org/wiki/QEMU/Networking</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Android Partition Explaination]]></title>
    <link href="http://ytliu.github.com/blog/2012/11/12/android-partition-explaination/"/>
    <updated>2012-11-12T21:16:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/11/12/android-partition-explaination</id>
    <content type="html"><![CDATA[<p>这两天看了AndroidForums上的一个Thread，主要是介绍Android Partition的，感觉写的非常好，很有必要做个简单的笔记。</p>

<p>具体的信息在以下两个链接地址中：</p>

<p>http://androidforums.com/evo-4g-all-things-root/278898-android-partitions-kernels-explained.html</p>

<p>http://androidforums.com/evo-4g-all-things-root/279261-more-information-about-android-partitions.html</p>

<p>这个thread由两个人来写，<a href="http://androidforums.com/members/novox77.html">novox77</a>主要介绍了下android中partition的大概组织结构，<a href="http://androidforums.com/members/akazabam.html">akazabam</a>则详细地介绍了android partition的内部机制和原理，以及如何利用其来将application从RAM中移到sdcard上。</p>

<p>以下做一些节选和注释吧：</p>

<hr />

<h4>Android partitions, kernels explained</h4>

<pre><code>Here are the standard partitions on an Android phone:

/misc     - not sure what this is for.
/boot     - bootloader, kernel
/recovery - holds the recovery program (either clockworkmod or RA recovery for a rooted Evo)
/system   - operating system goes here: Android, Sense, boot animation, Sprint crapware, busybox, etc
/cache    - cached data from OS usage
/data     - user applications, data, settings, etc.

The below partitions are not android-specific. They are tied to the hardware of the phone, but the kernel may have code allowing Android to interact with said hardware.

/radio - the phone's radio firmware, controls cellular, data, GPS, bluetooth.
/wimax - firmware for Sprint's flavor of 4G, WiMax.

During the rooting process, a critical piece of the process is disabling a security system built into the bootloader that protects these partitions 
from accidental (or intentional) modification. This is what's referred to as "unlocking NAND." 
The security system can be set to active or inactive. S-ON means the security is in place (NAND locked). 
S-OFF means the security is off (NAND unlocked). When S-OFF, you have the ability to modify all partitions. 
With S-ON, you only have write access to /cache and /data. Everything else is read-only.
</code></pre>

<p>也就是说root的过程就是NAND unlock，使得partition可以被任意修改。否则你只能修改/cache和/data文件夹，而不能修改更为关键的/system</p>

<pre><code>When you flash a custom ROM, that ROM typically includes a kernel and an OS. That means the /boot and /system partitions will be modified at a minimum.
</code></pre>

<p>在这里作者把kernel和OS区别开来，在我看来，它这里的kernel主要是一些boot的信息，而OS则指framework和传统意义上的kernel？</p>

<pre><code>When you do a factory reset (AKA: wipe, hard reset, factory wipe, etc.), you are erasing the /data and /cache partitions. 
Note that a factory reset does NOT put your phone back to its factory state from an OS standpoint. 
If you've upgraded to froyo, you will stay on froyo, because the OS lives in /system, and that is not touched during a factory reset. 
</code></pre>

<p>所以所谓的"factory reset"并不是真正意义上的reset，而是"data reset"。只有root了才有可能做到真正的reset吧？</p>

<pre><code>The SD card can also be partitioned to include a section dedicated to storing user apps. To create the partition, your SD card needs to be formatted. 
</code></pre>

<p>这个会在后来akazabam的文章中详细的描述。</p>

<pre><code>Onto kernels....
</code></pre>

<p>之后novox77扯了点关于kernel的东西，这里就不讲了，具体的可以看原贴。</p>

<hr />

<h4>More information about Android partitions</h4>

<h5>The Basics</h5>

<pre><code>Linux/UNIX type systems have one top level file structure. The top level is called root, and is designated by /. 
There are no drive letters, and the files and folders under / are not necessarily all stored in the same physical location. 

From this point on, the root of the file system will just be referred to as /. There really isn't much under / by itself. 
It's generally a small partition. In order to use other partitions, Android must make these partitions available under /. 
There is a special directory called /dev. In order to use partitions found in /dev, the system must mount them under /. 
</code></pre>

<p>也就是说，不过我们mount哪一个设备，它都把mount point作为它自己文件系统的root，即"/"。</p>

<h5>Mounting</h5>

<pre><code>There are two very important conclusions:
1) The system mounts and unmounts partitions at boot and shutdown. 
If you pull the battery out while the system is running or use a poorly written app to reboot the phone, partitions are still mounted, 
and if the system is writing to them, you could easily corrupt something. 
Granted, sometimes this is necessary if the phone becomes unresponsive. It's more likely to be a problem if repeatedly done.
2) Ever wonder why you cannot access the sdcard while the phone is connected to a computer as a disk drive? 
It's because the computer is mounting the sdcard partition so that you can see it there. What does that mean? 
It means Windows, Linux, etc. (whatever OS you have on your computer) has direct access to that physical media. 
No two operating systems can have direct control over physical media at the same time. It would result in massive data corruption. 
You may be wondering how it's possible to share drives or partitions in the networking world. 
You can do so because the Computer that has the physical media is still the only host that can physically read and write to the media. 
Sharing of the data is done at a much higher level and is controlled by the operating system.
</code></pre>

<p>第一点告诉我们，不能随便插拔电池，做多了会有问题的。第二点解释了为什么通常我们在把手机插到电脑上时在手机上就没办法访问sdcard上的数据了：因为这时候sdcard被mount在了电脑上，而一个设备不可能被同时mount在两个系统上。</p>

<h5>Mount Options</h5>

<pre><code>Linux based systems have a file called fstab. That file is a mapping of physical partitions and their mountpoints, 
along with options it needs to know when mounting said partitions. It uses this file to mount partitions at boot time. 
So, the fact that you don't have to mount /system, /boot, /data, etc. yourself is because the system does it for you. 
</code></pre>

<p>这段话解释了我们linux系统上的fstab，系统在启动的时候会自动在这个文件中查找需要mount的设备和mountpoint，并自动帮我们mount了该mount的东西。</p>

<pre><code>The partition mounted as /data is mounted as rw. It has to be, otherwise the system would be all but unusable. 
You wouldn't be able to install apps, change settings, etc. 
Do not confuse this with file permissions. That is a different discussion for a different time, but at least understand this - 
file and directories have certain permissions that allow the file owner, the group the file owner belongs to, 
and everyone else specific access to said file. 
The point is that a partition must be mounted as rw in order for write permissions to work. 
If you have permission to write to a file on a partition, but it is mounted as ro, it will not work.
</code></pre>

<p>这个区分了mount option和file permission之间的关系。这是两种不同的限制方式，mount option是针对整个文件系统的，而file permission只针对一个文件或是文件夹。也就是说，即使你某个文件有write权限，如果整个文件系统的mount option是ro，那么文件也是不可写的。</p>

<h5>The System Partition</h5>

<pre><code>The partition mounted as /system is automatically mounted as read only. It's like this because, even with root 
(the unlocked ability to make changes to the partition mounted as /system) it's dangerous to make changes there 
if you do not know what you are doing. When you flash a ROM from recovery, it wipes that partition, and writes new contents to it. 
Recovery scripts, however, are smart enough to mount this partition in rw mode. 
If you are going to make changes to /system while booted up in Android, you must have /system mounted as rw. 
Otherwise, you will just get permission errors even thought you have root level permissions.
</code></pre>

<p>所以说在android系统中，/system分区是默认mount为ro的，对于那种刷机的程序它可以通过某些tricky的手段将其设为rw模式，然后将里面的数据覆盖掉。</p>

<pre><code>To do this, you must remount the partition under /system as rw. There are many ways of doing this. 
All of them are system-wide. What that means is, if you use an app to remount /system as rw, 
the entire system and any other app will see it such until you reboot the phone or remount it as ro. 
Root explorer, for example, has an option in the top right corner to mount whatever file system you are currently browsing 
as either rw or ro depending on what it's currently mounted as. Basically, it toggles between rw and ro. 
There is also an app in the marketplace called "Mount /system (rw /ro)", which will do that as well if you don't have root explorer. 
Let's look at it in a little more detail, though.
</code></pre>

<p>一般来说，如果你要将/system分区remount成rw的话，一般是要有root权限的，上文中说有一个app叫"Mount /system (rw /ro)"的不要root explorer，这个我没有搞太清楚。</p>

<pre><code>Should you want to remount the partition mounted under /system as rw using the command line from a terminal emulator, you would run this:

$ su mount -o remount,rw -t yaffs2 /dev/block/mtdblock4 /system
</code></pre>

<p>这里解释下几个参数：</p>

<pre><code>-o is the option used to specify certain special mount options. 
a comma separated list following -o are the options you want to specify for mounting.

remount means that the file system you are mounting is already mounted, and you want to specify some other options. 

rw means that you want /system to be mounted in read/write mode. 

-t yaffs2 is the filesystem type of the partition. 

/dev/block/mtdblock4 is the logical location of the partition itself under /dev as previously explained. 

/system is the location under / where the files belonging to the mtdblock4 partition will be made accessible. 
</code></pre>

<p>当用户可以用root权限的账户在模拟器上执行完以上操作，这/system分区就被remount了。这个root权限是指你前面的su，或者某个可以运行root用户的app。</p>

<h5>Current Mounts</h5>

<pre><code>To see how /system is currently mounted:

$ mount | grep /system

You will see something like:

/dev/block/mtdblock4 /system yaffs2 ro 0 0

Having an understanding of how this works will help you determine ways of saving space and making the most of your available storage. 
The three major partitions are /data, /system, and /cache. A majority of your 1 GB of internal storage is used by these. 
The partitions sizes are set when the partitions are created. By default, this is how they are partitioned:

/system – 350 MB
/data – 430 MB
/cache – 160 MB

As you can see, you only have 430 MB for apps and data. That’s less than half of the advertised space. 
There are numerous apps on the market that will display the free space available on each partition, 
but it can be done from the command line as well by typing this:

$ df -h

You will probably notice that both /system and /cache have a lot of free space. As it turns out, 
most of that free space rarely gets used, and cannot be used by you for apps, at all. It’s wasted space. 
Cache, of course, will show mostly free space, but it’s necessary for things like OTAs, which will download to that directory. 
It does need to be somewhat large, but not that big. In any case, there are ways of having more space available than just 430 MB. 
The best place to start is a2sd.
</code></pre>

<p>现在的系统中，如果我们有1G的内存，那么它会将大于一半的分给/system和/cache分区，而真正给应用程序使用的只有很少的一部分。而大部分时候我们是不需要那么多分区的。那么怎么办呢，接下来介绍的a2sd可以部分地解决这些个问题：</p>

<h5>A2sd, Apps2sd, and File System Types</h5>

<pre><code>With all of this knowledge in mind, you can probably get a better understanding of how something like a2sd works. 
A2sd is a system devised to move all installed applications to the sdcard. This is by no means the same thing as the built-in froyo apps2sd.
</code></pre>

<p>说白了，a2sd就是将一些应用程序移到sdcard上，而不要占用少量的/data分区，但是它和froyo内置的apps2sd又有很大的区别：</p>

<pre><code>With Froyo apps2sd:
The developer of a certain app specify that it is allowed to be moved to the sdcard.
Even when it is, if the app has widgets, those widgets will not be available once the app is on the sdcard. 
Why? Because the sdcard is unmounted once the phone is connected to a computer as a disk drive. 
If widgets belonging to such an app were on the homescreen at that time, they would stop working. 
Google designed Android to avoid such a case by just making those widgets unavailable.
</code></pre>

<p>如果我们把一部分应用通过apps2sd移动到sdcard上，有时候是会有问题的，比如如果这个app有widgets，那么如果我们把手机连接到电脑上，这个时候sdcard就被mount到电脑上了，但那些widgets还在屏幕中，这样就会有问题。为了防止这些问题，google会直接将那些个widgets禁掉。</p>

<pre><code>Only a part of the app is moved, not the entire thing. 
If you've ever looked at at an app that has been moved to the sdcard in manage applications, 
you will see that it still is taking up space on internal storage (in /data). 
The reason this happens goes back to file system types.
</code></pre>

<p>另一个更关键的问题是用apps2sd只能将应用的一部分移到sdcard上，而很大一部分会留下来，这是有文件系统类型决定的：</p>

<pre><code>Linux based systems have a certain number of file system types that it can use. 
Windows has its own as well. The sdcard needs to be formatted in a file system that is basically universal. 
This means that no matter what kind of computer you plug the phone into, plus the phone itself, 
you need to be able to view/modify the contents of the card. That file system is fat32. 
Both Linux and Windows can view/modify said contents. BUT, Linux (Android) can't execute anything off of a fat32 partition. 
Its use of it is somewhat limited. That being said, Android cannot move an entire app to the sdcard in its stock condition, 
as it would be moving it to a fat32 file system, where it would not be able to execute it.
</code></pre>

<p>因为一个手机上的sdcard可能会被mount在不同的系统中（比如windows, mac, linux），所以sdcard上的文件系统必须得足够universal。所以sdcard的文件系统一般是fat32，因为它可以被linux和windows都看到，但它有一个很大的限制就是不能再上面运行任何东西。也就是说应用程序运行的部分是不能被移到sdcard上的，否则它就无法被运行了。</p>

<pre><code>A2sd has none of these issues, and gets around them in a fairly creative way. 
The sdcard, in stock state, has one partition, which is this fat32 partition. 
You still need a majority of the card to have this fat32 partition for the purpose of using it normally, 
but a2sd must use a partition type that is native to Linux. 
So, the first thing you must do to use a2sd is partition the card into two separate partitions. 
This can be done in recovery. Once it is done partitioning, it formats the two partitions using a particular file system. 
The bigger partition, which the user will continue to see as /sdcard and keep all of there data, remains fat32. 
The smaller partition (usually made between 512 MB and 1 GB) is formatted in the ext3 file system. 
This ext3 file system type is native to Linux. What does this mean? 
It means that Android can use that partition on the sdcard the exact same way it could internal storage.
</code></pre>

<p>a2sd的原理是这样的，它将sdcard分成了两个区，一个比较大的继续当fat32用，存放正常数据，另一个将其格式化为ext3格式，就可以达到所谓的"native to linux"了。</p>

<pre><code>Doesn't Android have to mount this new ext3 partition just like it does internal storage partitions and the normal fat32 sdcard partition? 
Why, yes it does. It mounts the partition just like any other partition, but it makes the mount point /system/sd. 
Once you've created the ext3 partition, you can browse /system/sd. It will look just like a directory in internal storage, 
but since it's a mountpoint, when you view it, you're looking on the sdcard, just in the smaller, ext3 partition. 
Having done this, you've basically fooled the system into thinking you have more internal storage. 
The issue is that Android will look for apps in two main places - /data/app and /system/app. 
if you just stuck an apk (Android application) in /system/sd, Android system would never find it, as it will never look there. 
For those interested in seeing how the sdcard partitions are mounted, run these two commands:

$ mount | grep /sdcard
$ mount | grep /system/sd

The output for /system/sd, for example, looks like:

/dev/block/mmcblk0p2 on /system/sd type ext3 (rw,noatime,nodiratime,errors=continue,data=writeb ack)

Both of those commands, though, will show how the fat32 sdcard partition is mounted (/mnt/sdcard) and 
how the ext3 sdcard partition is mounted (/system/sd). As you can see, mmcblk0p2 is the ext partition, 
while the majority of the card (the fat32 partition) is mmcblk0p1. 
Another quick important point is that /system/sd is mounted as rw so that you can make changes. 
Remember this - if a partition is mounted as ro (/system) but a directory under it is used as a mountpoint (/system/sd) 
you will still be able to write to whatever is mounted under that second directory as long as the partition is mounted as rw. 
That being said, you can leave /system mounted as ro, and still always make changes to /system/sd.
</code></pre>

<p>所以，sdcard被分出来的那个区被mount在了/system/sd上，虽然/system是ro模式的，但并不影响它下面的子目录是可写的。但是有一个问题，android一般是在/data/app和/system/app中查找有没有应用，我们将其mount到/system/sd上就算有应用也不能被发现啊？</p>

<pre><code>The first thing a2sd does is move all applications from /data/app and /data/app-secure to /system/sd/app and /system/sd/app-secure. 
Remember that with just this step, the system would not see apps anymore. At this point, a2sd makes use of something called a symlink. 
a2sd removes the /data/app and /data/app-secure directories, then creates symlinks (shortcuts) called /data/app and /data/app-secure 
that point to directories in /system/sd for apps. This means that the system will continue to look in /data/app and /data/app-secure for apps, 
but will be directed to /system/sd. Basically, the system doesn't care where files actually are. 
It only cares that it can find them where it knows to look.
</code></pre>

<p>这里就用了symbol link的方式将/data/app和/system/app链接到/system/sd/app和/system/sd/app-secure上，这样就解决了上面说的问题了。</p>

<pre><code>A2sd can also be used to move dalvik cache to the sdcard. It does this in exactly the same manner as moving apps. 
Dalvik cache is normally stored in /data/dalvik-cache. A2sd creates a directory in /system/sd for dalvik-cache, 
then creates a /data/dalvik-cache symlink that points to the real location.
</code></pre>

<p>同样也可以用同样的方法将dalvik-cache移到sdcard上。</p>

<pre><code>As dalvik cache is stored in /data by default, it takes up your usable storage, needlessly. 
That is why it can be moved to the sdcard ext3 partition. If you choose to, though, it can also be moved to the /cache partition. 
/cache is normally just unused space on internal storage that is way bigger than it needs to be. 
Thus, dalvik cache can be moved there instead, too. The idea is the same, but it doesn't use symlinks. 
It does some creative work with the mount command to make the system look there for it. 
</code></pre>

<p>dalvik-cache也可以被移到/cache里面，虽然cache需要留一些空间，但是当前系统留的大于它需要的。而且移到/cache里就不需要用symbolic-link了。</p>

<h5>Other Space Saving Options</h5>

<pre><code>Some people do not want to use a2sd, as they do not have good enough sdcards and are not interested in buying a new one. 
A2sd will not work well with a slower card, such as the one that comes stock with the Evo. 
However, it is possible to reclaim some of the unusable internal storage. 
If you remember, /data, /system, and /cache make up a majority of your internal storage. They can be resized with this mod. 
</code></pre>

<p>很显然，将app移到sdcard上必然会减慢app的运行速度，特别是如果你的sdcard很弱的话。不过把一些程序从/data移到/system或/cache倒是一个可行的方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[getSystemService() in android]]></title>
    <link href="http://ytliu.github.com/blog/2012/11/11/getsystemservice-in-android/"/>
    <updated>2012-11-11T20:18:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/11/11/getsystemservice-in-android</id>
    <content type="html"><![CDATA[<p>在之前研究了那么久的bindService()这个API，一直没搞清楚一个问题：</p>

<p>为什么我看到的基本上都是和AMS相关的代码，而之前所学到说如果application要和service打交道都是需要通过ServiceManager获得某个service的binder才可以。那么AMS和ServiceManager到底是什么关系呢？如果AMS是通过ServiceManager获得的service binder，那么相关的代码又是在哪里呢？</p>

<p>这个问题困扰了我很久，直到我看到一个<a href="http://blog.csdn.net/windskier/article/details/6625883" title="杜文涛的专栏">博客</a>，我才发现其实我把一个很重要的概念混起来了：</p>

<p>Android中主要通过2种方法来获得service binder：</p>

<ul>
<li>通过一些API如bindService，来获得application service的binder。因为app service都是直接和AMS注册的，AMS运行在system_server进程；</li>
<li>通过ServiceManager.getService(String Descriptor)来获得Service Manager管理的service的binder，ServiceManager运行在servicemanager进程。</li>
</ul>


<p>也就是说，尼玛bindService只是用来bind application level的service！！！</p>

<p>而我们更在意的system service应该是由ServiceManager.getService()来获得的！！！</p>

<p>发现这个问题之后我整个人都有些凌乱了。。。不过静下来想想其实自己从bindService这里入手也学到很多东西，也就不纠结了！</p>

<p>那么现在的问题是，应用程序到底是如何获得system service的binder的？</p>

<p>在这个问题的探索过程初期，我又一次惊奇地发现android.os.ServiceManager竟然是@hide的！！！！</p>

<p>尼玛hide的啊！！！也就是如果不是和framework一起编译的话是找不到的啊！我在网上看到一个很无语的<a href="http://www.oschina.net/question/54100_32232?sort=time" title="隐藏类的使用">解决方案</a>，但是，我还是不知道应用程序到底是怎么调用system service的啊？总不可能每个人都懂得什么变态的“隐藏类的使用”吧？</p>

<p>后来不知道是怎么回事，我突然发现在android里面竟然有一个API叫getSystemService()！我问了下乃正，他竟然和我说“你们干嘛不问我，这不是很显然的吗？应用里面就是调用这个获得system service的啊”！尼玛伤不起啊，一个没写过android应用程序的还要研究android framework的人伤不起啊！！</p>

<hr />

<h3>getSystemService()</h3>

<p>好了，还是言归正传吧，到底getSystemService()是如何得到system service的呢？其实这个也没有想象的那么好理解。而且我查了下网上的资料，大部分还是讲ServiceManager.getService()是如何得到system service的，而基本上都没有涉及到getSystemService()是怎么和ServiceManager.getService()搭上关系的。</p>

<p>于是经过一番研究，我终于搞清楚了这里面所涉及的种种“复杂而又充满基情”的关系，请听我娓娓道来：</p>

<hr />

<p>在一个月黑风高的夜晚，一个郁郁不得志的少年Activity调用了一个具有扭转乾坤概率的大API---getSystemService()。</p>

<p>算了，没有写小说的潜质。。。还是老实点正常写着吧。。。早点写完早点洗洗睡吧。。。</p>

<p>在调用Activity.getSystemService()之后，就进入ContextImpl.getSystemService()。</p>

<p>至于是怎么进来的，其实也很简单，Activity继承ContextThemeWrapper，再继承ContextWrapper。里面会调用mBase.getSystemService()。这个mBase是一个ContextImpl实例变量，于是就调到了。</p>

<p>于是在ContextImpl.getSystemService()是这样的：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Override</span>
</span><span class='line'><span class="kd">public</span> <span class="n">Object</span> <span class="nf">getSystemService</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ServiceFetcher</span> <span class="n">fetcher</span> <span class="o">=</span> <span class="n">SYSTEM_SERVICE_MAP</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span><span class='line'><span class="k">return</span> <span class="n">fetcher</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="kc">null</span> <span class="o">:</span> <span class="n">fetcher</span><span class="o">.</span><span class="na">getService</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>话说这个SYSTEM_SERVICE_MAP是怎么来的呢？这就要扯得远点了：</p>

<p>在每个Activity启动的时候都要运行一大段的static的代码（在android.app.ContextImpl.java）里面：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">static</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">registerService</span><span class="o">(</span><span class="n">ACCESSIBILITY_SERVICE</span><span class="o">,</span> <span class="k">new</span> <span class="n">ServiceFetcher</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">getService</span><span class="o">(</span><span class="n">ContextImpl</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">AccessibilityManager</span><span class="o">.</span><span class="na">getInstance</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}});</span>
</span><span class='line'>
</span><span class='line'><span class="n">registerService</span><span class="o">(</span><span class="n">ACCOUNT_SERVICE</span><span class="o">,</span> <span class="k">new</span> <span class="n">ServiceFetcher</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">createService</span><span class="o">(</span><span class="n">ContextImpl</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">IBinder</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ServiceManager</span><span class="o">.</span><span class="na">getService</span><span class="o">(</span><span class="n">ACCOUNT_SERVICE</span><span class="o">);</span>
</span><span class='line'>    <span class="n">IAccountManager</span> <span class="n">service</span> <span class="o">=</span> <span class="n">IAccountManager</span><span class="o">.</span><span class="na">Stub</span><span class="o">.</span><span class="na">asInterface</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">AccountManager</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="n">service</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}});</span>
</span><span class='line'>
</span><span class='line'><span class="n">registerService</span><span class="o">(</span><span class="n">ACTIVITY_SERVICE</span><span class="o">,</span> <span class="k">new</span> <span class="n">ServiceFetcher</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Object</span> <span class="nf">createService</span><span class="o">(</span><span class="n">ContextImpl</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="k">new</span> <span class="nf">ActivityManager</span><span class="o">(</span><span class="n">ctx</span><span class="o">.</span><span class="na">getOuterContext</span><span class="o">(),</span> <span class="n">ctx</span><span class="o">.</span><span class="na">mMainThread</span><span class="o">.</span><span class="na">getHandler</span><span class="o">());</span>
</span><span class='line'>    <span class="o">}});</span>
</span><span class='line'>
</span><span class='line'><span class="o">...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>它会在自己的SYSTEM_SERVICE_MAP为每一个系统服务注册一个ServiceFetcher的类，在这个类中，大部分的服务为重写一个函数叫<em>createService(ContextImpl)</em>，这个方法之后会用到，现在只需要知道我们从SYSTEM_SERVICE_MAP获得了某个服务的ServiceFetcher对象fetcher，并通过fetcher.getService(this)获得了该服务的对象。</p>

<p>fetcher.getService(ContextImpl):</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Object</span> <span class="nf">getService</span><span class="o">(</span><span class="n">ContextImpl</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ArrayList</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Object</span><span class="o">&amp;</span><span class="n">gt</span><span class="o">;</span> <span class="n">cache</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">.</span><span class="na">mServiceCache</span><span class="o">;</span>
</span><span class='line'><span class="n">Object</span> <span class="n">service</span><span class="o">;</span>
</span><span class='line'><span class="kd">synchronized</span> <span class="o">(</span><span class="n">cache</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'><span class="k">if</span> <span class="o">(</span><span class="n">cache</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// Initialize the cache vector on first access.</span>
</span><span class='line'>    <span class="c1">// At this point sNextPerContextServiceCacheIndex</span>
</span><span class='line'>    <span class="c1">// is the number of potential services that are</span>
</span><span class='line'>    <span class="c1">// cached per-Context.</span>
</span><span class='line'>    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span> <span class="n">sNextPerContextServiceCacheIndex</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">cache</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">service</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">mContextCacheIndex</span><span class="o">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">service</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="n">service</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="n">service</span> <span class="o">=</span> <span class="n">createService</span><span class="o">(</span><span class="n">ctx</span><span class="o">);</span>
</span><span class='line'><span class="n">cache</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">mContextCacheIndex</span><span class="o">,</span> <span class="n">service</span><span class="o">);</span>
</span><span class='line'><span class="k">return</span> <span class="n">service</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>也就是说每个Activity都有一个mServiceCache，它cache了所有用到的service的ServiceFetcher类。如果hit了，那么直接返回该对象，否则会调用这个fetcher的createService()方法，这也就是我们刚才提到的每一个ServiceFetcher在注册的时候会重写的那个方法。</p>

<p>可以看到，大部分重写的方式都是类似于这样的：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="n">Object</span> <span class="nf">createService</span><span class="o">(</span><span class="n">ContextImpl</span> <span class="n">ctx</span><span class="o">)</span> <span class="o">{&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">IBinder</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ServiceManager</span><span class="o">.</span><span class="na">getService</span><span class="o">(</span><span class="n">XXX_SERVICE</span><span class="o">);</span>
</span><span class='line'><span class="n">IXXXManager</span> <span class="n">service</span> <span class="o">=</span> <span class="n">IXXXManager</span><span class="o">.</span><span class="na">Stub</span><span class="o">.</span><span class="na">asInterface</span><span class="o">(</span><span class="n">b</span><span class="o">);</span>
</span><span class='line'><span class="k">return</span> <span class="k">new</span> <span class="nf">XXXManager</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="n">service</span><span class="o">);</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}});</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
于是乎，getSystemService()就在这里和ServiceManager.getService()无缝地结合在了一起！</p>

<hr />

<p>对于ServiceManager.getService()，在网上有很多关于它的说明和讨论，这里推荐其中两篇：</p>

<p>在<a href="http://blog.csdn.net/Luoshengyang" title="老罗的android之旅">老罗</a>的博客中两篇，</p>

<p>第一篇是<a href="http://blog.csdn.net/luoshengyang/article/details/6642463" title="java API">这篇文章</a>，主要介绍了怎么从java里面的ServiceManager.getService()开始的流程；</p>

<p>还有一篇是<a href="http://blog.csdn.net/luoshengyang/article/details/6633311" title="getService">这篇文章</a>，深入介绍了在C++和driver层是如何调用getService的</p>
]]></content>
  </entry>
  
</feed>
