<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Network | Mctrain's Blog]]></title>
  <link href="http://ytliu.github.com/blog/categories/network/atom.xml" rel="self"/>
  <link href="http://ytliu.github.com/"/>
  <updated>2013-04-14T21:03:32+08:00</updated>
  <id>http://ytliu.github.com/</id>
  <author>
    <name><![CDATA[Liu Yutao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Netfilter学习笔记（二）]]></title>
    <link href="http://ytliu.github.com/blog/2013/03/29/netfilterxue-xi-bi-ji-%28er-%29/"/>
    <updated>2013-03-29T20:26:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/03/29/netfilterxue-xi-bi-ji-(er-)</id>
    <content type="html"><![CDATA[<p>之前讲了关于netfilter和iptables的一些简单的原理和用法，对于iptables来说，如果只能对封包进行DROP、ACCEPT操作，那么就显得太弱了，其实在我看来iptables里面filter表中最牛逼的就在于QUEUE（NFQUEUE）这个target了。</p>

<p>那么当iptables将封包插入QUEUE后，用户态又能用什么方法才能读到queue中的数据呢？</p>

<p>这里介绍两种方法，一种是C语言中使用的<code>libipq</code>，一种是python中使用的<code>nfqueue</code>。</p>

<h3>libipq</h3>

<p><code>libipq</code>是一个对开发者提供的用于读取iptables queue的C库，具体的用法可以参看<a href="http://linux.die.net/man/3/libipq">linux man page</a>和<a href="http://www.imchris.org/projects/libipq.html">这里</a>的用法，需要注意的是在我的机器中必须得再加三个头文件：</p>

<pre><code>#include &lt;netinet/in.h&gt;
#include &lt;linux/ip.h&gt;
#include &lt;linux/tcp.h&gt;
</code></pre>

<p>另外编译出来的文件必须得用<code>sudo</code>执行！！！</p>

<p>这里主要用了一个数据结构</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">ipq_handle</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">h</span> <span class="o">=</span> <span class="n">ipq_create_handle</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">PF_INET</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>另外需要设置一个模式，这里是<code>IPQ_COPY_PACKET</code>，即是将queue中的封包的payload和header一起拷贝到用户空间：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">status</span> <span class="o">=</span> <span class="n">ipq_set_mode</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">IPQ_COPY_PACKET</span><span class="p">,</span> <span class="n">BUFSIZE</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>之后通过：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">status</span> <span class="o">=</span> <span class="n">ipq_read</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFSIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>将queueu中的封包一个一个拷贝到用户空间，由用户进行操作，用户可以通过：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">ipq_message_type</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>得到包的类型，可能是<code>NLMSG_ERROR</code>，也有可能是<code>IPQM_PACKET</code>，如果是后者，即为一个正常的封包，可以通过类似于如下的代码对封包进行操作：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">case</span> <span class="n">IPQM_PACKET</span>: <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ipq_packet_msg_t</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">ipq_get_packet</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">iphdr</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">iphdr</span><span class="o">*</span><span class="p">)</span> <span class="n">m</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">payload</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">tcphdr</span> <span class="o">*</span><span class="n">tcp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">tcphdr</span><span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">m</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">payload</span> <span class="o">+</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">ip</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">ihl</span><span class="p">));</span>
</span><span class='line'>
</span><span class='line'><span class="kt">int</span> <span class="n">port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">tcp</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">dest</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="n">status</span> <span class="o">=</span> <span class="n">ipq_set_verdict</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">m</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">packet_id</span><span class="p">,</span> <span class="n">NF_ACCEPT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>    <span class="n">die</span><span class="p">(</span><span class="n">h</span><span class="p">);</span>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>上段代码的意思是先从<code>buf</code>中获得整个封包m，之后可以通过<code>struct iphdr</code>和<code>struct tcphdr</code>获得ip包头和tcp包头，最后有一个最关键的代码：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">status</span> <span class="o">=</span> <span class="n">ipq_set_verdict</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">packet_id</span><span class="p">,</span> <span class="n">NF_ACCEPT</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这里的意思相当于原来在规则中target设为ACCEPT，当然也可以设置成<code>NF_DROP</code>等。</p>

<p>在这里我有一个疑问，就是这里除了获得<code>struct tcphdr</code>之外，我没有找到和TCP的payload相关的结构，不知道该如何获得。</p>

<hr />

<h3>nfqueue</h3>

<p>和C的libipq比起来，支持python的nfqueue会显得强大很多，特别是和<a href="http://www.secdev.org/projects/scapy/">scapy</a>结合起来用的时候。</p>

<p>首先需要说明的是在iptables中的target除了之前提到的五项（ACCEPT，DROP，RETURN，QUEUE，other_chain）之外，还有一个叫<code>NFQUEUE</code>，它是QUEUE的扩展。相比于QUEUE，它可以由用户指定不同的queue number。</p>

<p>在使用nfqueue之前，需要安装如下的包：</p>

<pre><code>$ sudo aptitude install libnetfilter-queue-dev
$ sudo aptitude install nfqueue-bindings-python
$ sudo aptitude install python-scapy
</code></pre>

<p>之后就可以采用python对NFQUEUE进行操作了。</p>

<p>假设我们将封包从主机A（<code>192.168.1.1</code>）传输到主机B（<code>192.168.1.2</code>）时，需要对封包进行分析，如果是TCP协议的包，并且其flags为 ACK|PSH 的话，则将其payload进行修改（比如替换成“hack”）：</p>

<p>首先，需要先在主机A中对iptables进行操作：</p>

<pre><code>$ sudo iptables -A OUTPUT -d 192.168.1.2 -p tcp -j NFQUEUE
</code></pre>

<p>然后利用下面的代码：</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span><span class="nn">sys</span><span class="o">,</span><span class="nn">nfqueue</span><span class="o">,</span><span class="nn">socket</span>
</span><span class='line'><span class="kn">from</span> <span class="nn">scapy.all</span> <span class="kn">import</span> <span class="o">*&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">ch_payload_and_send</span><span class="p">(</span><span class="n">pkt</span><span class="p">):</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">pkt</span><span class="p">[</span><span class="n">TCP</span><span class="p">]</span><span class="o">.</span><span class="n">payload</span> <span class="o">==</span> <span class="s">&quot;hack&quot;</span>
</span><span class='line'><span class="n">send</span><span class="p">(</span><span class="n">pkt</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">payload</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
</span><span class='line'><span class="n">pkt</span> <span class="o">=</span> <span class="n">IP</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="c"># Check if TCP flags is ACK|PSH</span>
</span><span class='line'><span class="k">if</span> <span class="n">pkt</span><span class="p">[</span><span class="n">TCP</span><span class="p">]</span><span class="o">.</span><span class="n">flags</span> <span class="o">==</span> <span class="mi">24</span><span class="p">:</span>
</span><span class='line'>    <span class="c"># Dropping the packet</span>
</span><span class='line'>    <span class="n">payload</span><span class="o">.</span><span class="n">set_verdict</span><span class="p">(</span><span class="n">nfqueue</span><span class="o">.</span><span class="n">NF_DROP</span><span class="p">)</span>
</span><span class='line'>    <span class="n">ch_payload_and_send</span><span class="p">(</span><span class="n">pkt</span><span class="p">)</span>
</span><span class='line'><span class="k">else</span><span class="p">:</span>
</span><span class='line'>    <span class="c"># Accepting the packet</span>
</span><span class='line'>    <span class="n">payload</span><span class="o">.</span><span class="n">set_verdict</span><span class="p">(</span><span class="n">nfqueue</span><span class="o">.</span><span class="n">NF_ACCEPT</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">def</span> <span class="nf">main</span><span class="p">():</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">q</span> <span class="o">=</span> <span class="n">nfqueue</span><span class="o">.</span><span class="n">queue</span><span class="p">()</span>
</span><span class='line'><span class="n">q</span><span class="o">.</span><span class="n">open</span><span class="p">()</span>
</span><span class='line'><span class="n">q</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">)</span>
</span><span class='line'><span class="n">q</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">)</span>
</span><span class='line'><span class="n">q</span><span class="o">.</span><span class="n">set_callback</span><span class="p">(</span><span class="n">process</span><span class="p">)</span>
</span><span class='line'><span class="n">q</span><span class="o">.</span><span class="n">create_queue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">try</span><span class="p">:</span>
</span><span class='line'>    <span class="n">q</span><span class="o">.</span><span class="n">try_run</span><span class="p">()</span>
</span><span class='line'><span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
</span><span class='line'>    <span class="k">print</span> <span class="s">&quot;Exiting...&quot;</span>
</span><span class='line'>    <span class="n">q</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span><span class="p">)</span>
</span><span class='line'>    <span class="n">q</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</span><span class='line'>    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">main</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这里用到了<code>scapy</code>这个非常牛逼的模块，它可以直接通过如<code>IP()</code>，<code>TCP()</code>等直接对包进行解释和操作，非常方便，具体的可以参看它的<a href="http://www.secdev.org/projects/scapy/doc/">文档</a>。这里只是说明下它的安装方式：</p>

<pre><code>$ wget scapy.net
$ mv index.html scapy-latest.zip
$ chmod +x scapy-latest.zip
$ mv scapy-latest.zip /usr/local/bin/scapy
</code></pre>

<p>然后就可以运行：</p>

<pre><code>$ sudo scapy
</code></pre>

<p>直接开启scapy的交互模式了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Netfilter学习笔记（一）]]></title>
    <link href="http://ytliu.github.com/blog/2013/03/29/netfilterxue-xi-bi-ji-%28yi-%29/"/>
    <updated>2013-03-29T18:39:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2013/03/29/netfilterxue-xi-bi-ji-(yi-)</id>
    <content type="html"><![CDATA[<p>这两天在学习<code>iptables</code>，感觉这个东西实在是太牛逼！想用两篇博文来介绍一番。</p>

<p>第一篇会介绍下netfilter和iptables的关系，以及iptables的原理；第二篇希望通过<code>libipq</code>和<code>nfqueue-bindings-python</code>来介绍下user态如何利用C和Python来调用iptables的接口获得封包的信息。</p>

<h3>netfilter</h3>

<p>简单地说，netfilter是一套在计算机网络栈中过滤和修改封包的框架，它的做法是在Linux Kernel中插入了一系列的hook，并允许kernel在不同层的网络栈中注册回调函数，这些回调函数会在封包进入相应的hook的时候被调用到。</p>

<p>网络栈中对netfilter的支持如图所示：</p>

<p><img src="http://ytliu.github.com/images/2013-03-29-1.png" title="package flow in netfiter and general networking" alt="netfilter" /></p>

<p>可以看到在链路层和网络层中按照封包流的路径有五种类型的hooks: prerouting, input, forward, output, postrouting。这五种hooks会在封包到达之时按照封包流的顺序调用相应的回调函数，对四种类型的表中的chain（会在iptables中描述）进行过滤和修改：filter, nat, mangle, raw。而定义这些过滤的规则则是由一个用户态的命令<code>iptables</code>进行配置，也就是我接下来要详细描述的命令。</p>

<h3>iptables</h3>

<p><a href="http://itzone.hk/article/index.php?tid=14">这里</a>有6篇系列的文章介绍iptables的，讲的挺清楚，蛮适合入门学习的。</p>

<p>前面说过iptables有四种类型的表：filter，nat，mangle，raw，这里只是对filter表进行介绍：</p>

<p>filter表主要用于对封包进行过滤，在该表中有三条默认的chain：INPUT，FORWARD，OUTPUT。</p>

<p>chain是做什么的呢？(转自<a href="http://itzone.hk/article/article.php?aid=200502091507054036">这里</a>)</p>

<blockquote><p>所謂chain就是一組封包過濾規則，您可以在INPUT chain中加入一條防止所有外界封包進入的規則；您可以在OUTPUT chain中加入一條防止用戶連接某網頁伺服器。準備進入網絡的封包，會順著chain內的過濾規則被稽核，若果該封包並不符合任何規則，則會直接進入網 內，因為INPUT和OUTPUT在Linux kernel裡被預設為ACCEPT，而FORWARD則被預設為DROP。</p></blockquote>

<p>比如说，如果要把发到某个地址（如192.168.1.2）的包丢弃，可以这样做：</p>

<pre><code>$ sudo iptables -A OUTPUT -d 192.168.1.2 -j DROP
</code></pre>

<p>这里<code>-A</code>指对OUTPUT这条链的规则进行修改，<code>-d</code>表示这个封包的destination，<code>-j</code>后加的是target，有五种选择：ACCEPT（不作任何操作，让封包流过），DROP（将封包丢弃），QUEUE（将封包插入队列，传递到用户态处理，这个会在第二篇中详细描述），RETURN（直接从该chain中返回，到前一个chain的下一条规则继续执行），以及自己定义的CHAIN，如下：</p>

<pre><code>$ sudo iptables -N SELF_CHAIN
</code></pre>

<p>也就是说我们可以按照不同的源地址、目标地址、端口、协议等规则分类，由不同的chain进行处理，可以更合理地对过滤条件进行管理。</p>

<p>另外，有几个常用的选项这里提一下：</p>

<pre><code>-A chain                # modify a chain
-D chain rulenum        # delete a specific rule of chain
-I chain rulenum rule   # insert rule in rulenum of chain
-R chain rulenum rule   # replace rule with rulenum of chain
-L [chain]              # list rules of chain
-F [chain]              # flush the rules of chain
-N chain                # new a chain
-X [chain]              # delete chain

-p protocol             # e.g., tcp, udp, icmp...
-s source address       # e.g., 192.168.1.22
-d destination address  # e.g., 192.168.1.13
-j target               # e.g., ACCEPT, DROP, RETURN, QUEUE, other-chain
-i in-interface         # e.g., eth0
-o out-interface        # e.g., eth0
</code></pre>

<hr />

<p>下一篇主要介绍当<code>iptables</code>的target是QUEUE或者NFQUEUE时，用户态要如何调用相关接口。</p>
]]></content>
  </entry>
  
</feed>
