<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 杂 | Mctrain's Blog]]></title>
  <link href="http://ytliu.github.com/blog/categories/杂/atom.xml" rel="self"/>
  <link href="http://ytliu.github.com/"/>
  <updated>2013-02-17T15:11:55+08:00</updated>
  <id>http://ytliu.github.com/</id>
  <author>
    <name><![CDATA[Liu Yutao]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[杂]]></title>
    <link href="http://ytliu.github.com/blog/2012/02/19/za/"/>
    <updated>2012-02-19T18:08:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2012/02/19/za</id>
    <content type="html"><![CDATA[<p>总的来说这周过得是比较颓废的，花了太多时间在金庸上，晚睡早起的，不过我并不后悔，没有什么好后悔的，做了就是做了，而且过程还挺开心的，好好制定接下来的计划并实行就好了。</p>

<p>看了射雕，真的很羡慕小说中人物的生活，很喜欢靖哥哥和蓉儿，有的时候我会想，如果真有一个那样子的世界，而我又身处其中，那又会怎么样呢？我也能像郭靖那样这么真诚地对待自己和他人吗？从一开始我就感觉很讨厌杨康，可是看完了回头想想杨康真的做的就完全不对吗？作为一个人多为自己考虑又哪里错了呢？喜欢郭靖还有很重要的原因是他功夫好，可是有时候又真的很为他担心，太过于坚持原则。说到底，我还是最喜欢蓉儿和后期的靖哥哥，真的真的好羡慕他们两人，我知道这是虚构，可是为什么就不能相信世界上真的有这样的一对呢~还有，我在想，在现实生活中，真的能像郭靖那样真诚地对待他人吗？路上看到需要帮助的人你能毫不犹豫地给予施舍？给别人的承诺就算再难也要实现？为了心爱的人能付出所有的一切，包括自己的生命？可是世间又是那么地充满不公，充盈着欺瞒与腐败，作为一个如此普通的人，没有拯救世界的能力，又何来如此真诚而无条件的信心呢？所以我有时憧憬着那些武林中的生活，固然世间充满着不公，固然人依然是如此的渺小，很多时候却更有可能单纯依靠努力改变一些什么。说不清楚什么，或许是虚拟世界的完美性的虚构带来的幻觉吧……</p>

<p>武林中的世界将要告一段落，回到现实生活中，这周主要的工作是两篇paper的rebuttal和依旧的读paper，从PC的review其实可以从一定程度上看出最后的结果了，不过依然带着些侥幸心理，还是要等到最后吧。在后来重新搭建CFIMon的时候发现虽然只是经过了短短2、3个月，很多东西依然忘记了，主要还是因为1.理解的不够深，2.没有很好地记录下来吧。比如那个禁止linux地址空间布局随机化的</p>

<pre><code>    echo 0 &gt; /proc/sys/kernel/randomize_va_space    
</code></pre>

<p>如果当时能记下来这次就能省去好多时间了。这就是为什么今年"记笔记"是我一个很大的计划的原因了。真的越来越感觉到自己记忆的易失和笔头的重要性了。</p>

<p>还有这周印象很深的是在讨论CFIMon处理signal的问题的时候，斌哥问我关于linux中对signal处理的问题，说来惭愧，当时在写这篇paper的时候我对这个还是一知半解的，甚至到现在还把signal的处理和interrupt的处理混起来了。希望能在这里把这东西说清楚:</p>

<p>当一个进程需要向另一个进程发送一个signal时，它是通知kernel产生这个signal，并将接受方进程的某个flag(ULK中说的是TIF_SIGPEDING)置好，当然这个时候并不是能马上告诉接受进程有signal需要处理，而是像ULK上说的：</p>

<pre><code>    The kernel checks for the existence of pending signals every time it finishes handling an interrupt or an exception.
</code></pre>

<p>也就是说只有在某个进程运行时需要处理中断或异常即将返回该进程执行时才会检查是否有未处理的signal，再对其进行处理。对于signal的处理主要有三种情况：</p>

<pre><code>    1，ignore
    2，the default action，通常是SIGSTOP
    3，用户注册的相对应的signal handler
</code></pre>

<p>对于前面两种情况很容易理解和实现，这里主要要说的是第三种情况，这个情况的麻烦在于它要先从kernel态切换到user态执行handler，之后再切回kernel态，直到回到进程在进入kernel之前的状态，而这些就要很仔细地考虑栈里面数据和进程状态的维护了。在ULK中用了一张图来表示整个过程：
<img src="http://ytliu.github.com/images/2012-02-19-1.jpg" title="The process of catching a signal from ULK" alt="Catching a Signal" /></p>

<p>简单来说整个流程是这样的：在处理完中断或异常将从kernel态回到用户态之前，kernel会调用do_signal()函数，在这个函数里面会调用handle_signal()函数，这个函数首先创建用户态所需要的栈环境，这个栈是长这样的：
<img src="http://ytliu.github.com/images/2012-02-19-2.jpg" title="the frame on the user mode stack from ULK" alt="Frame on the User Mode Stack" /></p>

<p>其实主要就是把return address改成用户自行定义的signal handler的入口，然后进入用户态，执行相应的代码，当执行结束之后，会根据栈顶的pretcode，调用一个sigreturn()或rt_sigreturn()系统调用，回到kernel态，执行流继续下去。其实这里面还有很多细节的，包括那些栈里面内容的含义，如何处理嵌套signal等等，这些需要更仔细地参阅相关资料了。</p>

<p>最后依然是写写这周看的paper，这周本来是想把Oakland'11扫一遍的，不过自己看paper的效率实在是低，加上觉得前面看的几篇确实都蛮有意思的，就多花了些时间，这个专题还是下周来写吧，另外这周给自己选的paper是6.858的preparation的第一篇，叫</p>

<pre><code>    Baggy Bounds Checking: An Efficient and Backwards-Compatible Defense against Out-of-Bounds Errors
</code></pre>

<p>是发在usenix security 2009上的，主要是因为它是课程的pre-reading，其实我自己本身对这方面不是很熟悉，也不是太感兴趣，在这里就简单介绍下吧：</p>

<p>这篇主要是做memory bounds checking，在文中首先提出要做bound checking主要要考虑两点，第一效率高，第二向后兼容性，这里先归纳下传统memory errors detection的方法：</p>

<pre><code>    static technique;
    dynamic technique (with or without source code);
    control flow integrity, taint trcking;
    system support (fat pointer, splay tree to map memory...)
</code></pre>

<p>这些方法按照作者的说法要不效率太低，要不需要改变整个系统指针结构的layout，不能向后兼容，要么检查的错误有限制（其实本文也有很大的限制啦）...而作者做这个Baggy bounds checker的最大的insight是，现在linux里面很流行的buddy allocator的特性，所有allocate出来的页的大小都是2的指数大小，于是对于内存区域size和allignment的限制能够很大程度地减小内存的利用，提高检察效率。举个例子，对于传统的保存pointer信息的结构，至少需要8个bytes的空间（4位保存pointer起始地址，4位保存pointer指向内存的大小）而对于baggy来说，只需要一个byte的大小（e = log2(size)）。至于pointer的起始地址，由于在baggy系统里内存被分为slot-size（implementation中是16-bytes)的一个个slots，于是</p>

<pre><code>    size = 1 &lt;&lt; e
    base = p &amp; ~(size-1)
</code></pre>

<p>而记录这个e的table是一个占用内存1/slot-size大小的array，每一个slot一个byte表示，于是举个例子：</p>

<pre><code>    对于指针运算：p' = p + i
    bound的检查：size = 1 &lt;&lt; table[p&gt;&gt;slot_size]
                 base = p &amp; ~(size-1)
                 p' &gt;= base &amp;&amp; p' - base &lt; size
    检查的优化：（p~p')&gt;&gt;table[p&gt;&gt;slot_size] == 0
</code></pre>

<p>这个优化也很好理解，对于计算出的指针p'，如果它不越界，当且仅当它和p的不同只发生在e least significant bits上。这个baggy bounds checker的整个流程是这样的：
<img src="http://ytliu.github.com/images/2012-02-19-3.png" title="Architecture" alt="Overall System Architecture" /></p>

<p>当然这中间还有很多细节，我不想一一列出来讲，而且说实话我也看的不是很懂，最后想提提这个paper的limitation，这个最后作者也有说到，除了它列出的几点：</p>

<pre><code>    arithemtic on integers holding addresses is unchecked
    does not address temporal memory safety violations
    cannot protect from memory errors in subobjects such as structure fields
</code></pre>

<p>我还有几点不是很确定算不算，第一个，在它的实现中slot-size为16bytes，也就是说所有memory allocator出来的内存大小都要大于16bytes（否则会有两个objects指在同一个slot里面），那么对于比如integer指针，岂不是很浪费？padding过多会造成大量的内存浪费，当然按照作者的说法这个可以做一个权衡，但是如何权衡或许用户并不是很清楚。第二，对于non-instrumented的第三方library的checking，按照作者的说法将默认size设为2<sup>31，我不懂这样做会不会有很大的副作用，另外，只能在修改过的应用程序中检查memory</sup> bounds violation，对于library中的指针运算依然没办法，而library的code我想应该比用户自己的application多出很多吧，也不见得vulnerability会少啊。</p>

<p>另外在MIT 6.858的lecture-2里面也是讲相关知识的，这里想补充一些"How to prevent buffer overflows"</p>

<pre><code>    Approach 0: use a type-save language (Java, C#, Python..)
    Approach 1: try to find bugs (analysis tools, fuzzers)
    Approach 2: canaries (StackGuard, gcc's SSP)
    Approach 3: bounds checking
    Approach 4: non-executable memory (AMD's NX bit, Windows DEP, W^X...)
    Approach 5: randomized memory address (ASLR, stack randomization...)
</code></pre>

<p>下周打算把Oakland'11完成，至于其它任务吗，还没想好咯。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[开篇仪式]]></title>
    <link href="http://ytliu.github.com/blog/2011/12/21/kai-pian-yi-shi/"/>
    <updated>2011-12-21T15:58:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2011/12/21/kai-pian-yi-shi</id>
    <content type="html"><![CDATA[<p>其实很早就一直在想要写博客了，之前也尝试过（<a href="http://blog.csdn.net/microtrain016" title="microtrain016's blog">一只小小小鸟</a>），但是最后还是没有坚持下来。   <br/>
昨天看了鹏老大的一篇博文 - <a href="http://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">《怎样花两年时间去面试一个人》</a>，真的很有感触，其实我不能算一个geek，技术其实也挺一般的，在自己看来离人才还差得远，但是里面提到的"书单计划"和"github计划"应该是一个慢慢积累的过程，我还有半年的本科生涯，之后还有至少五年的博士，我没有要急于找工作的负担，为什么不趁这个最最珍贵的时间来积累呢？我一直相信于"厚积薄发"，还记得本科的时候看着自己与其他人的距离我写下"时间会拉近人与人之间的差距"，三年过去我觉得自己做到了一些，超过了一些当时在我心目中的牛人。但当我进入PPI，当我开始要考虑自己的博士生涯的时候发现，自己又成了一个更高层次的弱者，我为此感到兴奋，我未来的生活又可以在这种激情中度过，只是在这慢慢的积累中我希望看到一点一滴的进步，我很清楚自己在发散思维上的弱势，我急需一些方法提高。</p>

<p>我写博客是希望将自己在这个学习的过程中的感悟、收获以一种相比于记忆更不会消逝的方式记录下来，如果还能引起别人带来那么一丁点儿的共鸣那再好不过了，我从不祈求于自己能写出多么牛逼的技术文章，任何技术上的收获、生活中的感悟我都会记录下来，我从不认为文字分所谓的"贫贱贵富"，只要是自己的就是最真实的。</p>

<p>至于为什么要用Octopress+Github，是因为我们实验室的两个大牛（<a href="http://blog.yxwang.me">zellux</a>和<a href="http://chenyufei.info">ChenYufei</a>）都开始尝试着用了它，而且我也想感受用vi写博文的感觉所以就尝试写段时间，我希望这个尝试能一直进行下去。也希望能从中得到那些我希望得到的东西。</p>

<p>开篇结束，坚持是未来最大的挑战！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown语法测试]]></title>
    <link href="http://ytliu.github.com/blog/2011/12/21/markdownyu-fa-ce-shi/"/>
    <updated>2011-12-21T15:17:00+08:00</updated>
    <id>http://ytliu.github.com/blog/2011/12/21/markdownyu-fa-ce-shi</id>
    <content type="html"><![CDATA[<p><a href="http://ytliu.github.com">http://ytliu.github.com</a></p>

<p>[mctrain](http://ytliu.github.com "mctrain's blog")  <br/>
<a href="http://ytliu.github.com" title="mctrain's blog">mctrain</a>  <br/>
<a href="http://ytliu.github.com" title="mctrain's blog">mctrain-2</a></p>

<pre><code>    ![pic](http://ytliu.github.com/images/search.png "pic")
</code></pre>

<p><img src="http://ytliu.github.com/images/search.png" title="pic" alt="pic" /></p>

<pre><code>    #title1
</code></pre>

<h1>title1</h1>

<pre><code>    ##title2
</code></pre>

<h2>title2</h2>

<pre><code>    ###title3
</code></pre>

<h3>title3</h3>

<pre><code>    ####title4
</code></pre>

<h4>title4</h4>

<pre><code>    #####title5
</code></pre>

<h5>title5</h5>

<pre><code>    ######title6
</code></pre>

<h6>title6</h6>

<pre><code>    *italic*
</code></pre>

<p><em>italic</em></p>

<pre><code>    **bold**
</code></pre>

<p><strong>bold</strong></p>

<pre><code>    ***italic&amp;bold***
</code></pre>

<p><strong><em>italic&amp;bold</em></strong></p>

<pre><code>    &gt;highlight
</code></pre>

<blockquote><p>highlight</p></blockquote>

<pre><code>    &lt;html&gt; *a* &lt;/html&gt;
</code></pre>

<p><html> <em>a</em> </html></p>

<ul>
<li>1</li>
<li>2</li>
<li><p>3</p></li>
<li><p>first</p></li>
<li>second</li>
<li>third</li>
<li>fourth</li>
</ul>


<p>hr-high</p>

<hr />

<p>hr-below</p>

<blockquote><p>highlight</p>

<blockquote><p>highlight again</p></blockquote></blockquote>

<p>{% codeblock %}
Awesome code snippet
{% endcodeblock %}</p>

<p>{% codeblock tang:objc %}
[rectangle setX: 10 y: 10 width: 20 height: 20];
{% endcodeblock %}</p>

<p>{% codeblock Javascript Array Syntax lang:js http://j.mp/pPUUmW MDN Documentation %}
var arr1 = new Array(arrayLength);
var arr2 = new Array(element0, element1, ..., elementN);
{% endcodeblock %}</p>

<p>中文测试
这个测试中有很多很多很多字符
{% blockquote %}
"C"是系统默认的locale，"POSIX"是"C"的别名。所以当我们新安装完一个系统时，默认的locale就是C或POSIX。</p>

<p>在Debian中安装locales的方法如下：</p>

<p>· 通过apt-get install locales命令安装locales包
· 安装完成locales包后，系统会自动进行locale配置，你只要选择所需的locale，可以多选。最后指定一个系统默认的locale。这样系统就会帮你自动生成相应的locale和配置好系统的locale。</p>

<p>· 增加新的locale也很简单，用dpkg-reconfigure locales重新配置locale即可。</p>

<p>· 我们也可手动增加locale，只要把新的locale增加到/etc/locale.gen文件中，再运行locale-gen命令即可生成新的locale。再通过设置上面介绍的LC_*变量就可设置系统的locale了。下是一个locale.gen文件的样例。</p>

<p>UB的核心过程了。该过程之所以区分stage1.5和stage2，主要原因是GRUB和GRUB2的区别。在GRUB2中，将stage1.5过程集成到了stage2的过程中，所以stage1.5过程仅仅是针对GRUB的。下面将会分别介绍两种GRUB版本的两种过程。</p>

<p>4.1 GRUB中stage1.5过程</p>

<p>Stage1.5过程很无辜，它的作用很单一，但是非常关键。它的主要功用就是构造一个boot分区系统对应的文件系统，这样可以通过文件系统的路径（/boot/grub/）寻找stage2过程需要的core.img，进而加载到内存中开始执行。</p>

<p>Stage1.5存在于0面0道3扇区开始的地方，并一直延续十几k字节的区域，具体的大小与相应的文件系统的大小有关（文中涉及到了0面0道1-3+x扇区，这部分扇区为保留扇区，BIOS不会放置任何数据。正因为如此如果转换到GPT分区形式，系统将不能被正确引导，如上文所示，MBR后面的扇区都被其他内容所占据）。Stage1.5过程被构建成多种不同类型，但是功能类似，下面简单介绍一下基本的stage1.5过程的文件系统。e2fs_stage1_5（针对ext2fs，可引导ext2和ext3文件系统）、fat_stage1_5（针对fat文件系统，可引导fat32和fat16）、ffs_stage1_5、jfs_stage1_5、minix_stage1_5、reiserfs_stage1_5、vstafs_stage1_5和xfs_stage1_5，这些文件被称为stage1.5过程，这些文件每个至少都在11k以上。除此之外还有两个比较特殊的文件，分别为nbgrub和pxegrub，这两个文件主要是在网络引导时使用，只是格式不同而已，他们很类似与stage2，只是需要建立网络来获取配置文件。</p>

<p>由于stage1.5过程中会涉及到多个文件系统对应的文件，因此本文中主要以ext2fs为例进行说明，其他文件系统与此类似，可以同样进行分析理解。</p>

<p>对于ext2fs文件系统，用于生成该文件系统的stage1.5过程文件（e2fs_stage1_5）的代码为stage2/fsys_ext2fs.c文件。</p>

<p>在stage2/filesys.h文件中定义了每个文件系统对外的接口，用于上层调用，作为stage2过程寻找核心代码使用，文件系统一般被定义的接口主要就是三个函数，分别是mount、read和dir函数。对应ext2fs，其定义的函数为：</p>

<h1>ifdef FSYS_EXT2FS</h1>

<h1>define FSYS_EXT2FS_NUM 1</h1>

<p>int ext2fs_mount (void);
int ext2fs_read (char <em>buf, int len);
int ext2fs_dir (char </em>dirname);</p>

<h1>else</h1>

<h1>define FSYS_EXT2FS_NUM 0</h1>

<h1>endif</h1>

<p>针对ext2fs有如上的函数名称，每个函数将具体在stage2/fsys_ext2fs.c文件中被定义，这里面没有包含任何的写的过程，对于bootloader而言仅仅读就可以完成任务了，没必要对其系统进行写操作。其中ext2fs_mount函数用于检查文件系统类型，并将superblock读入到内存中；ext2fs_read函数和ext2fs_dir函数用于对文件系统具体的操作。在stage2/fsys_ext2fs.c文件中除了需要对这三个函数的定义之外，还需要文件系统的属性的数据结构（superblock、inode和group结构，这些结构最初被定义在include/linux/ext2_fs.h文件中），通过这些数据结构描述一个文件系统。</p>

<p>如果读者有兴趣可以试着创建新的文件系统的支持，可以参照目前存在的一些文件系统的模板（实例）编写。</p>

<p>4.2 GRUB中stage2过程</p>

<p>GRUB中的核心过程也就是stage2过程了，该过程主要是在文件系统建立以后选择合适的操作系统进行加载并转交控制权，达到最后引导操作系统的目标。由于GRUB属于multi boot loader，因此在引导的时候要进行选择，选择哪种操作系统来运行。在GRUB内部主要包括两种方式，首先是从menu.list中读取显示到屏幕让用户选择，其次是通过grub-shell中定义的命令手动进行启动。本文将在后面介绍这两种方式如何运行，接下来先介绍一下stage2的具体的执行过程。</p>

<p>在上面一节中介绍过，stage1.5过程中将boot分区的文件系统加载了，之后又做了一件事情，就是将控制权转交给stage2，而stage2入口的地方就是stage2/asm.S文件。Stage2/asm.S文件属于汇编代码，主要作用是初始化C语言的运行环境，为下面执行C语言的函数做好准备，在准备好之后，将执行init_bios_info(stage2/common.c)函数。init_bios_info函数的作用是执行一些底层的函数，然后跳转到cmain执行，cmain函数位于stage2/stage2.c文件中。cmain函数内部进行一个死循环，在循环内部首先加载配置文件，显示给用户，在这同时循环一个内层循环，在内层循环中，获取配置文件中的命令，并解析执行。过程中如果没有可用的配置文件，那么进入命令行模式（enter_cmdline函数），如果找到可用的menu，那么开始执行menu的对应的内容（run_menu函数）。</p>

<p>对于enter_cmdline（stage2/stage2.c）函数，将调用find_command（stage2/cmdline.c），进而执行相应命令的函数。</p>

<p>对于run_menu（stage2/stage2.c）函数，将调用stage2/cmdline.c文件中的run_script函数，进而调用find_command，执行相应命令的函数。</p>

<p>这两种方式虽然经过了不同的过程，对用户输入的行为进行分析和处理，最终调用的函数为find_command，在该函数中顺序循环比较“输入”的命令是否与系统内部定义的相同，如果相同转到执行该函数。在这个比较的过程中包含了一个全局的数据结构为struct builtin（stage2/shared.h），由该数据结构组成了一个table类型（stage2/builtins.c），将命令与相对应的builtin结构对应一起并进行串联。下面描述一下builtin结构的定义：</p>

<p>struct builtin</p>

<p>{</p>

<p>/<em> 命令名称，重要，是搜索命令时的依据</em>/</p>

<pre><code>char *name;

/* 命令函数，重要，是搜索匹配后调用的函数*/

int (*func) (char *, int);

/* 功能标示，一般未用到. */

int flags;

/* 简短帮助信息*/

char *short_doc;

/* 完整帮助信息*/

char *long_doc;
</code></pre>

<p>};</p>

<p>struct builtin *builtin_table[]；</p>

<p>有兴趣的读者可以对上面的内容进行扩展，形成自己的命令，主要在stage2/builtins.c文件中按照预定的格式更新，并添加到builtin_table中即可。</p>

<p>在上面打开配置文件的过程中，主要是通过一些文件操作函数（被定义在stage2/disk_io.c中）完成。这些文件操作函数主要包括：grub_open、grub_read、grub_seek和grub_close等，这些函数属于grub对外的上层接口，具体的函数内部将调用前文中提到的boot分区对应的文件系统的相应的函数完成，这个过程主要是通过回调函数来完成。该过程整体思路类似于面向对象过程，通过对象操作具体的函数。关于用C语言实现面向对象的编程思路，可以参考一本书——《Object-oriented Programming with ANSI-C》。</p>

<p>4.3))}))))</p>
]]></content>
  </entry>
  
</feed>
