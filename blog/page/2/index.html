
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Mctrain's Blog</title>
  <meta name="author" content="Liu Yutao">

  
  <meta name="description" content="寒假回来就要开始执行新年的计划了~首先是每周的一篇blog。 今天看了阮一峰最新的一篇博客计算机是如何启动的，感觉写得很好，又清楚又简单。虽然自己关于计算机启动这个过程从大三OS课的时候就陆陆续续地一直有了解，但是都没有一个系统的了解，或者了解了又忘了， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://ytliu.github.com/blog/page/2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/stylesheets/data-table.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Mctrain's Blog" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Mctrain's Blog</a></h1>
  
    <h2>Security, Virtualization, Network, as well as life moments</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss email">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
    <li><a href="ytliu.cc@gmail.com" rel="subscribe-email" title="subscribe via email">Email</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:ytliu.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/02/17/%5B%28zhuan-%29%5D-ji-suan-ji-de-qi-dong/">【转】计算机的启动</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-02-17T14:24:00+08:00" pubdate data-updated="true">Feb 17<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>寒假回来就要开始执行新年的计划了~首先是每周的一篇blog。</p>

<p>今天看了<a href="http://www.ruanyifeng.com/blog/">阮一峰</a>最新的一篇博客<a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的</a>，感觉写得很好，又清楚又简单。虽然自己关于计算机启动这个过程从大三OS课的时候就陆陆续续地一直有了解，但是都没有一个系统的了解，或者了解了又忘了，希望通过这次记录把这点彻底弄清楚来并且记在脑子里。另外在评论中有另外一个小哥<a href="http://www.dalei.org/">大磊</a>把他的<a href="http://www.dalei.org/linux-unix-boot-process/">博客</a>也贴出来了，写得很详细，作为阮一峰的补充吧。</p>

<hr />

<p>以下是转来的文章，中间加上了大磊的补充，也没有区分哪句话是谁说的，具体的还是看之前提到的两篇博客吧：</p>

<h4>零、boot的含义</h4>

<p>先问一个问题，&#8221;启动&#8221;用英语怎么说？</p>

<p>回答是boot。可是，boot原来的意思是靴子，&#8221;启动&#8221;与靴子有什么关系呢？ 原来，这里的boot是bootstrap（鞋带）的缩写，它来自一句谚语：</p>

<pre><code>"pull oneself up by one's bootstraps"
</code></pre>

<p>字面意思是&#8221;拽着鞋带把自己拉起来&#8221;，这当然是不可能的事情。最早的时候，工程师们用它来比喻，计算机启动是一个很矛盾的过程：必须先运行程序，然后计算机才能启动，但是计算机不启动就无法运行程序！</p>

<p>早期真的是这样，必须想尽各种办法，把一小段程序装进内存，然后计算机才能正常运行。所以，工程师们把这个过程叫做&#8221;拉鞋带&#8221;，久而久之就简称为boot了。</p>

<p>计算机的整个启动过程分成四个阶段。</p>

<h4>一、第一阶段：BIOS</h4>

<p>上个世纪70年代初，&#8221;只读内存&#8221;（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-1.png" title="BIOS" alt="BIOS" /></p>

<p>这块芯片里的程序叫做&#8221;基本輸出輸入系統&#8221;（Basic Input/Output System），简称为BIOS。</p>

<h5>1.1 硬件自检</h5>

<p>BIOS中主要存放的程序包括：自诊断程序（通过读取CMOS RAM中的内容识别硬件配置，并对其进行自检和初始化）、CMOS设置程序（引导过程中，通过特殊热键启动，进行设置后，存入CMOS RAM中）、系统自动装载程序（在系统自检成功后，将磁盘相对0道0扇区上的引导程序装入内存使其运行）和主要I/O驱动程序和中断服务（BIOS和硬件直接打交道，需要加载I/O驱动程序）。</p>

<p>BIOS程序首先检查，计算机硬件能否满足运行的基本条件，这叫做&#8221;硬件自检&#8221;（Power-On Self-Test），缩写为POST。</p>

<p>如果硬件出现问题，主板会发出不同含义的蜂鸣，启动中止。如果没有问题，屏幕就会显示出CPU、内存、硬盘等信息。</p>

<h5>1.2 启动顺序</h5>

<p>硬件自检完成后，BIOS把控制权转交给下一阶段的启动程序。</p>

<p>这时，BIOS需要知道，&#8221;下一阶段的启动程序&#8221;具体存放在哪一个设备。也就是说，BIOS需要有一个外部储存设备的排序，排在前面的设备就是优先转交控制权的设备。这种排序叫做&#8221;启动顺序&#8221;（Boot Sequence）。</p>

<p>打开BIOS的操作界面，里面有一项就是&#8221;设定启动顺序&#8221;。</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-2.png" title="BIOS Sequence" alt="BIOS Sequence" /></p>

<h4>二、第二阶段：主引导记录</h4>

<p>BIOS按照&#8221;启动顺序&#8221;，把控制权转交给排在第一位的储存设备。即根据用户指定的引导顺序从软盘、硬盘或是可移动设备中读取启动设备的MBR，并放入指定的位置（0x7c000）内存中。</p>

<p>这时，计算机读取该设备的第一个扇区，也就是读取最前面的512个字节。如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给&#8221;启动顺序&#8221;中的下一个设备。</p>

<p>这最前面的512个字节，就叫做&#8221;主引导记录&#8221;（Master boot record，缩写为MBR）。</p>

<h5>2.1 主引导记录的结构</h5>

<p>&#8220;主引导记录&#8221;只有512个字节，放不了太多东西。它的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。</p>

<p>主引导记录由三个部分组成：</p>

<pre><code>（1） 第1-446字节：调用操作系统的机器码。
（2） 第447-510字节：分区表（Partition table）。
（3） 第511-512字节：主引导记录签名（0x55和0xAA）。
</code></pre>

<p>其中，第二部分&#8221;分区表&#8221;的作用，是将硬盘分成若干个区。</p>

<h5>2.2 分区表</h5>

<p>硬盘分区有很多好处。考虑到每个区可以安装不同的操作系统，&#8221;主引导记录&#8221;因此必须知道将控制权转交给哪个区。</p>

<p>分区表的长度只有64个字节，里面又分成四项，每项16个字节。所以，一个硬盘最多只能分四个一级分区，又叫做&#8221;主分区&#8221;。</p>

<p>每个主分区的16个字节，由6个部分组成：</p>

<pre><code>（1） 第1个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。
（2） 第2-4个字节：主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。
（3） 第5个字节：主分区类型。
（4） 第6-8个字节：主分区最后一个扇区的物理位置。
（5） 第9-12字节：该主分区第一个扇区的逻辑地址。
（6） 第13-16字节：主分区的扇区总数。
</code></pre>

<p>最后的四个字节（&#8221;主分区的扇区总数&#8221;），决定了这个主分区的长度。也就是说，一个主分区的扇区总数最多不超过2的32次方。</p>

<p>如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。再考虑到扇区的逻辑地址也是32位，所以单个硬盘可利用的空间最大也不超过2TB。如果想使用更大的硬盘，只有2个方法：一是提高每个扇区的字节数，二是增加扇区总数。</p>

<h4>三、第三阶段：硬盘启动</h4>

<p>这时，计算机的控制权就要转交给硬盘的某个分区了，这里又分成三种情况。</p>

<h5>3.1 情况A：卷引导记录</h5>

<p>上一节提到，四个主分区里面，只有一个是激活的。计算机会读取激活分区的第一个扇区，叫做&#8221;卷引导记录&#8221;（Volume boot record，缩写为VBR）。</p>

<p>&#8220;卷引导记录&#8221;的主要作用是，告诉计算机，操作系统在这个分区里的位置。然后，计算机就会加载操作系统了。</p>

<h5>3.2 情况B：扩展分区和逻辑分区</h5>

<p>随着硬盘越来越大，四个主分区已经不够了，需要更多的分区。但是，分区表只有四项，因此规定有且仅有一个区可以被定义成&#8221;扩展分区&#8221;（Extended partition）。</p>

<p>所谓&#8221;扩展分区&#8221;，就是指这个区里面又分成多个区。这种分区里面的分区，就叫做&#8221;逻辑分区&#8221;（logical partition）。</p>

<p>计算机先读取扩展分区的第一个扇区，叫做&#8221;扩展引导记录&#8221;（Extended boot record，缩写为EBR）。它里面也包含一张64字节的分区表，但是最多只有两项（也就是两个逻辑分区）。</p>

<p>计算机接着读取第二个逻辑分区的第一个扇区，再从里面的分区表中找到第三个逻辑分区的位置，以此类推，直到某个逻辑分区的分区表只包含它自身为止（即只有一个分区项）。因此，扩展分区可以包含无数个逻辑分区。</p>

<p>但是，似乎很少通过这种方式启动操作系统。如果操作系统确实安装在扩展分区，一般采用下一种方式启动。</p>

<h5>3.3 情况C：启动管理器</h5>

<p>在这种情况下，计算机读取&#8221;主引导记录&#8221;前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的&#8221;启动管理器&#8221;（boot loader），由用户选择启动哪一个操作系统。</p>

<p>Linux环境中，目前最流行的启动管理器是Grub。</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-3.png" title="Grub" alt="Grub" /></p>

<p>对于grub而言，在MBR中的446字节的引导程序属于GRUB的开始执行程序，通过这段程序，进一步执行stage1.5或是stage2的执行程序，将在下面详细介绍执行过程。</p>

<p>其中stage1.5或是stage2便属于阶段2引导的过程了，stage2过程也是作为GRUB kernel的核心代码出现。Stage1.5过程（对于GRUB而言存在stage1.5，GRUB2则不存在）的功能很单一，主要就是为了引导stage2过程服务。由于stage2过程的代码存放在文件系统下的boot分区目录中，因此stage1.5过程就是需要提供一个文件系统的环境，而该文件系统环境需要保证系统可以找到stage2过程的文件，那么stage1.5阶段提供的文件系统需要是boot文件系统所对应的，这个在执行grub install过程中就已经确定了。stage2过程中，主要会把系统切换到保护模式，设置好C运行时环境，找到config文件（事实上就是menulist文件），如果没有找到就执行一个shell，等待用户的执行。然后的工作就变成了输入命令->解析命令->执行命令的循环中。当然该阶段引导的最终状态就是执行boot命令，将内核和initrd镜像加载进入内存中，进而将控制权转交给内核。</p>

<h4>四、第四阶段：操作系统</h4>

<p>控制权转交给操作系统后，操作系统的内核首先被载入内存。</p>

<p>以Linux系统为例，先载入/boot目录下面的kernel。内核加载成功后，第一个运行的程序是/sbin/init。它根据配置文件（Debian系统是/etc/initab）产生init进程。这是Linux启动后的第一个进程，pid进程编号为1，其他进程都是它的后代。</p>

<p>然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。</p>

<p>至此，全部启动过程完成。</p>

<hr />

<p>另外在大磊的<a href="http://www.dalei.org/linux-unix-boot-process/">博客</a>中还有许多细节部分：</p>

<h4>BIOS启动细节：</h4>

<p>a) 按下电源开关，电源就开始向主板和其它设备供电；当芯片组检测到电源已经开始稳定供电了(当然从不稳定到稳定的过程只是一瞬间的事情)，它便撤去RESET信号(如果是手工按下计算机面板上的Reset按钮来重启机器，那么松开该按钮时芯片组就会撤去RESET信号)；CPU马上就从地址FFFF:0000H 处开始执行指令，放在这里的只是一条跳转指令，跳到系统BIOS中真正的启动代码处。</p>

<p>b) 系统BIOS的启动代码首先进行POST(Power－On Self Test，加电后自检)。POST的主要检测系统中一些关键设备是否存在和能否正常工作，例如内存和显卡等设备；由于POST是最早进行的检测过程，此时显卡还没有初始化，如果系统BIOS在进行POST的过程中发现了一些致命错误，例如没有找到内存或者内存有问题(此时只会检查640K常规内存)，那么系统BIOS就会直接控制喇叭发声来报告错误，声音的长短和次数代表了错误的类型；在正常情况下，POST过程进行得非常快，几乎无法感觉到它的存在。POST结束之后就会调用其它代码来进行更完整的硬件检测。</p>

<p>c) 接下来系统BIOS将查找显卡的BIOS。前面说过，存放显卡BIOS的ROM芯片的起始地址通常设在C0000H处，系统BIOS在这个地方找到显卡BIOS之后就调用它的初始化代码，由显卡BIOS来初始化显卡。此时多数显卡都会在屏幕上显示出一些初始化信息，介绍生产厂商、图形芯片类型等内容，不过这个画面几乎是一闪而过。系统BIOS接着会查找其它设备的BIOS程序，找到之后同样要调用这些BIOS内部的初始化代码来初始化相关的设备。</p>

<p>d) 查找完所有其它设备的BIOS之后，系统BIOS将显示出它自己的启动画面，其中包括有系统BIOS的类型、序列号和版本号等内容。</p>

<p>e) 接着系统BIOS将检测和显示CPU的类型和工作频率，测试所有的RAM，并同时在屏幕上显示内存测试的进度。可以在CMOS设置中自行决定使用简单耗时少或者详细耗时多的测试方式。</p>

<p>f) 内存测试通过之后，系统BIOS将开始检测系统中安装的一些标准硬件设备，包括硬盘、CD-ROM、串口、并口和软驱等设备，另外绝大多数较新版本的系统BIOS在这一过程中还要自动检测和设置内存的定时参数、硬盘参数和访问模式等。</p>

<p>g) 标准设备检测完毕后，系统BIOS内部支持即插即用的代码将开始检测和配置系统中安装的即插即用设备。每找到一个设备之后，系统BIOS都会在屏幕上显示出设备的名称和型号等信息，同时为该设备分配中断、DMA通道和I/O端口等资源。</p>

<p>h) 到这一步为止，所有硬件都已经检测配置完毕了，多数系统BIOS会重新清屏并在屏幕上方显示出一个表格，其中概略地列出了系统中安装的各种标准硬件设备，以及它们使用的资源和一些相关工作参数。</p>

<p>i) 接下来系统BIOS将更新ESCD(Extended System Configuration Data，扩展系统配置数据)。ESCD是系统BIOS用来与操作系统交换硬件配置信息的一种手段，这些数据被存放在CMOS(一小块特殊的RAM，由主板上的电池来供电)之中。通常ESCD数据只在系统硬件配置发生改变后才会更新，所以不是每次启动机器时都能够看到“Update ESCD… Success”这样的信息。不过，某些主板的系统BIOS在保存ESCD数据时使用了与Windows 9x不相同的数据格式，于是Windows 9x在它自己的启动过程中会把ESCD数据修改成自己的格式。但在下一次启动机器时，即使硬件配置没有发生改变，系统BIOS也会把ESCD的数据格式改回来。如此循环，将会导致在每次启动机器时，系统BIOS都要更新一遍ESCD，这就是为什么有些机器在每次启动时都会显示出相关信息的原因。</p>

<p>j) ESCD更新完毕后，系统BIOS的启动代码将进行它的最后一项工作：即根据用户指定的启动顺序从软盘、硬盘或光驱启动MBR。在这个过程中会按照启动顺序顺序比较其放置MBR的位置的结尾两位是否为0xAA55，通过这种方式判断从哪个引导设备进行引导。在确定之后，将该引导设备的MBR内容读入到0x7C00[1]的位置，并再次判断其最后两位，当检测正确之后，进行阶段1的引导。</p>

<h4>EFI启动细节</h4>

<p>与传统MBR相比，GPT采用了不同的分区方式。</p>

<p>对于传统MBR，其结构主要如下：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-4.png" title="BIOS Graph" alt="BIOS Graph" /></p>

<p>上图即对上文中所述的很形象的说明，在图中看到MBR被分成三个部分，分别是：Bootloader、分别表以及Magic Number。其中Bootloader部分为stage1中被执行的起始部分。</p>

<p>相反，对于EFI系统中所采用的GPT分区方式，则采用了不同于MBR分区方式的形式，从下图中可以发现：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-5.png" title="EFI Graph" alt="EFI Graph" /></p>

<p>如上图所示，GPT分区表主要包括：保护MBR、首要GPT头、首要GPT、备用GPT、备用GPT头和磁盘数据区。保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表。首要GPT头包含了众多信息，具体内容如下：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-6.png" title="EFI Table" alt="EFI Table" /></p>

<p>分区表头定义了硬盘的可用空间以及组成分区表的项的大小和数量。分区表头还记录了这块硬盘的GUID，记录了分区表头本身的位置和大小（位置总是在LBA1）以及备份分区表头和分区表的位置和大小（在硬盘的最后）。它还存储着它本身和分区表的CRC32校验。固件、引导程序和操作系统在启动时可以根据这个校验值来判断分区表是否有错误，如果出错了，可以使用软件从硬盘最后的备份GPT分区表恢复整个分区表，如果备份GPT也校验错误，那么磁盘将不可用，系统拒绝启动。</p>

<p>接下来主要是128个分区表项，GPT分区表使用简单而直接的方式表示分区。一个分区表项的前16字节是分区类型GUID。例如，EFI系统分区的GUID类型是{C12A7328-F81F-11D2-BA4B-00A0C93EC93B} 。接下来的16字节是该分区的唯一的GUID（这个指的是该分区本身，而之前的GUID指的是该分区的类型）。在接下来是分区其实和末尾的64位LBA编号，以及分区的名字和属性。具体结构如下表：</p>

<p><img src="http://ytliu.github.com/images/2013-02-17-7.png" title="EFI Table2" alt="EFI Table2" /></p>

<h4>MBR引导</h4>

<p>接下来开始真正的引导过程了，主要说明GRUP的引导。总体上GRUB更像是一个mini os，只不过这个mini os的作用只是加载其他的操作系统，在GRUB中包括stage1、stage1.5（可选）和stage2，其中stage1和stage1.5属于boot loader，stage2属于mini os的内核部分。GRUB中stage1过程主要位于MBR的前446字节中（对于支持GPT分区的磁盘，同样有最开始的512字节作为保护MBR，保护MBR与正常的MBR区别不大，主要是分区表上的不同，在保护MBR中只要一个表示为0xEE的分区，以此来表示这块硬盘使用GPT分区表，不能识别GPT硬盘的操作系统通常会识别出一个未知类型的分区，并且拒绝对硬盘进行操作），之后的64字节为硬盘的分区表，最后两个字节为MBR结束标志位（0xAA55）。</p>

<p>stage1部分占用了446字节，其代码文件是源码目录下stage1/stage1.S文件，汇编后生成一个512字节的boot.img，被写在硬盘的0面0道1扇区中，作为硬盘的MBR。stage1的工作很简单，就是加载0面0道2扇区上的512字节到0×8000，然后跳转到0×8000执行。</p>

<p>在0面0道2扇区上的512字节内容为<code>stage1/start.S</code>文件汇编后生成。该扇区上的内容的作用是加载stage1.5或是stage2过程，并将控制权转交。</p>

<h4>Grub引导</h4>

<p>在start过程将控制权转交后，接下来就是GRUB的核心过程了。该过程之所以区分stage1.5和stage2，主要原因是GRUB和GRUB2的区别。在GRUB2中，将stage1.5过程集成到了stage2的过程中，所以stage1.5过程仅仅是针对GRUB的。下面将会分别介绍两种GRUB版本的两种过程。</p>

<p>4.1 GRUB中stage1.5过程</p>

<p>Stage1.5过程很无辜，它的作用很单一，但是非常关键。它的主要功用就是构造一个boot分区系统对应的文件系统，这样可以通过文件系统的路径（/boot/grub/）寻找stage2过程需要的core.img，进而加载到内存中开始执行。</p>

<p>Stage1.5存在于0面0道3扇区开始的地方，并一直延续十几k字节的区域，具体的大小与相应的文件系统的大小有关（文中涉及到了0面0道1-3+x扇区，这部分扇区为保留扇区，BIOS不会放置任何数据。正因为如此如果转换到GPT分区形式，系统将不能被正确引导，如上文所示，MBR后面的扇区都被其他内容所占据）。Stage1.5过程被构建成多种不同类型，但是功能类似，下面简单介绍一下基本的stage1.5过程的文件系统。e2fs_stage1_5（针对ext2fs，可引导ext2和ext3文件系统）、fat_stage1_5（针对fat文件系统，可引导fat32和fat16）、ffs_stage1_5、jfs_stage1_5、minix_stage1_5、reiserfs_stage1_5、vstafs_stage1_5和xfs_stage1_5，这些文件被称为stage1.5过程，这些文件每个至少都在11k以上。除此之外还有两个比较特殊的文件，分别为nbgrub和pxegrub，这两个文件主要是在网络引导时使用，只是格式不同而已，他们很类似与stage2，只是需要建立网络来获取配置文件。</p>

<p>由于stage1.5过程中会涉及到多个文件系统对应的文件，因此本文中主要以ext2fs为例进行说明，其他文件系统与此类似，可以同样进行分析理解。</p>

<p>对于ext2fs文件系统，用于生成该文件系统的stage1.5过程文件（e2fs_stage1_5）的代码为<code>stage2/fsys_ext2fs.c</code>文件。</p>

<p>在<code>stage2/filesys.h</code>文件中定义了每个文件系统对外的接口，用于上层调用，作为stage2过程寻找核心代码使用，文件系统一般被定义的接口主要就是三个函数，分别是mount、read和dir函数。对应ext2fs，其定义的函数为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#ifdef FSYS_EXT2FS</span>
</span><span class='line'><span class="cp">#define FSYS_EXT2FS_NUM 1</span>
</span><span class='line'><span class="kt">int</span> <span class="n">ext2fs_mount</span> <span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">ext2fs_read</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">);</span>
</span><span class='line'><span class="kt">int</span> <span class="n">ext2fs_dir</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dirname</span><span class="p">);</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'><span class="cp">#define FSYS_EXT2FS_NUM 0</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>针对ext2fs有如上的函数名称，每个函数将具体在<code>stage2/fsys_ext2fs.c</code>文件中被定义，这里面没有包含任何的写的过程，对于bootloader而言仅仅读就可以完成任务了，没必要对其系统进行写操作。其中ext2fs_mount函数用于检查文件系统类型，并将superblock读入到内存中；ext2fs_read函数和ext2fs_dir函数用于对文件系统具体的操作。在<code>stage2/fsys_ext2fs.c</code>文件中除了需要对这三个函数的定义之外，还需要文件系统的属性的数据结构（superblock、inode和group结构，这些结构最初被定义在<code>include/linux/ext2_fs.h</code>文件中），通过这些数据结构描述一个文件系统。</p>

<p>如果读者有兴趣可以试着创建新的文件系统的支持，可以参照目前存在的一些文件系统的模板（实例）编写。</p>

<p>4.2 GRUB中stage2过程</p>

<p>GRUB中的核心过程也就是stage2过程了，该过程主要是在文件系统建立以后选择合适的操作系统进行加载并转交控制权，达到最后引导操作系统的目标。由于GRUB属于multi boot loader，因此在引导的时候要进行选择，选择哪种操作系统来运行。在GRUB内部主要包括两种方式，首先是从menu.list中读取显示到屏幕让用户选择，其次是通过grub-shell中定义的命令手动进行启动。本文将在后面介绍这两种方式如何运行，接下来先介绍一下stage2的具体的执行过程。</p>

<p>在上面一节中介绍过，stage1.5过程中将boot分区的文件系统加载了，之后又做了一件事情，就是将控制权转交给stage2，而stage2入口的地方就是<code>stage2/asm.S</code>文件。<code>Stage2/asm.S</code>文件属于汇编代码，主要作用是初始化C语言的运行环境，为下面执行C语言的函数做好准备，在准备好之后，将执行init_bios_info(<code>stage2/common.c</code>)函数。init_bios_info函数的作用是执行一些底层的函数，然后跳转到cmain执行，cmain函数位于<code>stage2/stage2.c</code>文件中。cmain函数内部进行一个死循环，在循环内部首先加载配置文件，显示给用户，在这同时循环一个内层循环，在内层循环中，获取配置文件中的命令，并解析执行。过程中如果没有可用的配置文件，那么进入命令行模式（enter_cmdline函数），如果找到可用的menu，那么开始执行menu的对应的内容（run_menu函数）。</p>

<p>对于enter_cmdline（<code>stage2/stage2.c</code>）函数，将调用find_command（<code>stage2/cmdline.c</code>），进而执行相应命令的函数。</p>

<p>对于run_menu（<code>stage2/stage2.c</code>）函数，将调用<code>stage2/cmdline.c</code>文件中的run_script函数，进而调用find_command，执行相应命令的函数。</p>

<p>这两种方式虽然经过了不同的过程，对用户输入的行为进行分析和处理，最终调用的函数为find_command，在该函数中顺序循环比较“输入”的命令是否与系统内部定义的相同，如果相同转到执行该函数。在这个比较的过程中包含了一个全局的数据结构为struct builtin（<code>stage2/shared.h</code>），由该数据结构组成了一个table类型（<code>stage2/builtins.c</code>），将命令与相对应的builtin结构对应一起并进行串联。下面描述一下builtin结构的定义：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="n">builtin</span> <span class="p">{</span>
</span><span class='line'>  <span class="cm">/* 命令名称，重要，是搜索命令时的依据*/</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/* 命令函数，重要，是搜索匹配后调用的函数*/</span>
</span><span class='line'>  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span><span class='line'>  <span class="cm">/* 功能标示，一般未用到. */</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/* 简短帮助信息*/</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">short_doc</span><span class="p">;</span>
</span><span class='line'>  <span class="cm">/* 完整帮助信息*/</span>
</span><span class='line'>  <span class="kt">char</span> <span class="o">*</span><span class="n">long_doc</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span><span class='line'>
</span><span class='line'><span class="k">struct</span> <span class="n">builtin</span> <span class="o">*</span><span class="n">builtin_table</span><span class="p">[]</span><span class="err">；</span>
</span></code></pre></td></tr></table></div></figure>


<p>有兴趣的读者可以对上面的内容进行扩展，形成自己的命令，主要在<code>stage2/builtins.c</code>文件中按照预定的格式更新，并添加到builtin_table中即可。</p>

<p>在上面打开配置文件的过程中，主要是通过一些文件操作函数（被定义在<code>stage2/disk_io.c</code>中）完成。这些文件操作函数主要包括：grub_open、grub_read、grub_seek和grub_close等，这些函数属于grub对外的上层接口，具体的函数内部将调用前文中提到的boot分区对应的文件系统的相应的函数完成，这个过程主要是通过回调函数来完成。该过程整体思路类似于面向对象过程，通过对象操作具体的函数。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/12/qiao-bang-zhu-chuan-you-gan/">乔帮主传有感</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-12T20:34:00+08:00" pubdate data-updated="true">Jan 12<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这几周花了晚上的时间把乔帮主的传记给看完了。在我的记忆中我已经很久很久（或许久到甚至都不记得）没有看过什么名人传记，或许我本身就没有资格评论别人，而且由于自己的孤陋寡闻，也从来没有什么自己所谓的偶像。从乔帮主的传记中我惊叹于原来一个人可以那么真实地出现在这个世界中，通过他的创造力改变这个世界；居然存在一个让人看起来那么“讨厌”的人却有着别人无法逃脱的魅力；通过自己的意志让真正强大的人做到自己从未想过做到原本也确实无法做到的事，用他那强大到无法抗拒的“现实扭曲力场“来改变别人甚至使自己相信原本不存在的现实；他是一个自私到不行的非主流痞子，从不会设身处地地为周围的人考虑全凭自己一厢情愿去判定事物的好坏，去赞扬别人，去不惜代价地辱骂对方，但当面对全世界时，却毫不吝啬地为她着想，甚至去赌博这个世界未来的样子；或许没有一个人能像他那样将艺术和科技如此无缝地结合，让这个社会的普通人类去感受一个由它个人，以及一个伟大的公司所创造的更高的品味，即使是在即将离开人世的时候还在专注于此。他尽自己全力经营并留下的那个公司，由他物色、培养并使之无比强大的那些富有激情和创造力的人们，必将继续为我们大众带来一件件跨时代的产品，而他的一生一世，所经历的、所遭受的、所创造的、所改变的，留给世人一个神话般的存在，所有的这些遗产，不仅伟大，而且永恒。</p>

<p>当我看完上面这段文字，我都怀疑自己是否也进入的乔帮主的”现实扭曲力场“，被他的成就所折服，甚至忽略了他的一切令人厌恶的性格抑或缺点。在看书的过程中，他的太多做法使我无法理解，甚至强烈地抵抗，但却又有另一些让我毫无迹象地被其魅力和强大所折服，以至于甚至对他的偏激、阴暗面、对身边人的残酷、强大到无与伦比的控制欲、以及极其简单却让人无法理解的二元论，都带着一种幽默的嘲弄的态度，甚至会自发地将其归为其不可或缺的成功因子。当这种人出现，我又有什么资历，又怎么忍心去批判他，还带着无法忍受的态度去看待他呢？或许我的这些所想并非被逼迫，而是完全地心甘情愿吧？我敬重他、崇拜他、信任他、感激他，感动于他之所为，并发自内心地希望他一路走好。</p>

<p>尽管如此，虽然还仅仅是作为一个挣扎在毕业路上的IT学生，一方面，我无比愉悦而满怀感激地使用乔帮主为我们带来的ipad/iphone/air/icloud&#8230;，享受着它强烈的控制欲下设计且实现的近乎完美的端到端一体化系统和服务，一方面，我又在内心深处弱弱地支持着黑客精神，支持着用户对自己所拥有的一切（包括软件）的所有权和完全自由控制权。我毫无保留地信奉着开放对这个世界带来的绝对远胜于封闭，我信奉黑客世界中的自由而不作恶，我崇尚google文化，崇尚Linux等所有开源社区文化，崇尚git等这些为开源、开放所做出贡献的软件和组织。</p>

<p>我使用苹果的产品并热衷于此，但我却又无条件地支持开放与开源，而且我确信这样的人绝对不止我一个，而应该会是千千万万，那么这又是因为什么呢？</p>

<p>就在刚才我突然冒出来一个想法，或许是一个很显然和一目了然的想法，但是我发现我却刚刚才发现它，而且为此兴奋了好一阵子就如同我发现了一个真理一般。我想尝试着解答为什么，而且我相信这是唯一合理的解释。</p>

<h4>开放 &amp; 封闭</h4>

<p>我支持开放，因为我是一个开发者，是这个计算机世界中本应该创建规则的人，当这个世界中存在的规则开放了，才能更快地让这个世界不停滞地前进，试想如果每一个希望改进某个系统的人还需要重新再实现一个这个系统的话，每时每分每秒又能有多少所谓的创新呢？当这个世界的所有规则都是封闭的，又有多少人能进入这个世界而为此奉献自身呢？或许你可以说我们有点自私，希望用自己的方便换来单纯用户的更差体验，或许你可以说开放只是为了我们这些所谓的开发者更方便而简单地进行抄袭。发自内心地说，这些并不是没有道理，而且大量存在于现实社会中，但是这种现象不会长久，甚至会很容易由于其匮乏的核心竞争力迅速埋没，而创新的力量则会比原来任何时候都强大，况且封闭并不意味着没有抄袭，只是增加了难度而已，并非杜绝；而难道你又能否认封闭的windows没有从开放的linux里面借鉴些什么东西吗？开放使得我们创新于我们自己的东西，而不是纠结于已经存在于世的技术，而封闭只能将更多的人无情地拒之门外，或是浪费大量毫无价值的时间。</p>

<p>用户更喜欢苹果的产品（至少从目前的趋势来看），因为他们并不在意谁创造了苹果，并不在意这个世界的创新与前进出现在哪个公司，由那个hacker所推动。用户只在意于体验，在意于现在拿在我手中的产品是否满足于我的喜好，是否从品味上来看更优于其它。对于他们来说，封闭系统的创新总归可以由那些封闭系统的公司解决，因为不管是哪个封闭的系统总是由个人或公司开发的，只要最后结果符合需求，其它那些被封闭系统拒之门外或浪费大量时间的开发者又会有那个用户去care呢？苹果的优势在于他知道用户的心理，而由其强势控制的端到端一体化封闭系统是一个能够走在这条道路上的最可靠而又迅速的捷径。再加上苹果公司有着其它公司所缺乏的艺术与科技融合的本领以及其对未来电子产品的前瞻能力，于是他能在用户体验这个领域做出别人所无法比拟的成功，使得竞争对手甚至无法复制。而用户在乎的不就在于体验以及产品的品味吗？</p>

<p>而对于我来说，尽管我是一个开发者，我支持开放，但我同时也是一个不择不扣的用户，从一个普通用户的心态去评判产品时，苹果总能以它无以伦比的核心竞争力打败其它公司而被我选中。我没有Cory Doctorow那样”为什么我不会买ipad“这样的决心和霸气，因为一方面苹果的产品是无害的，而我也没有对我的手机具有完全控制能力的需求，而另一方面，苹果的电脑对于开发者的友好有时甚至优于linux等其它系统，只要我没有对这个系统本身做出修改或者控制的需求。</p>

<h4>我和计算机</h4>

<p>还记得在”我的梦想“这篇博文中我提到自己以后不想做和计算机相关的事，但是渐渐地，随着看的书越来越多，我发现我却慢慢喜欢上了IT这个行业，并不是因为我发现我的技术水平提高了，而是因为我发现计算机带给我，以及我们的，不仅仅是掌握了编程能力以至于挣口饭吃不至于饿死那么简单，它带给我的，是使得我能从一个更不同的视角来看待这个世界，而从这个角度中看到的世界，是一群人们所谓的书呆子，所谓的不谙世事的geek在用自己的方式改变世界、创造世界。是啊，我之前也说过我觉得自己没有创新的能力，没有那么的雄心壮志，但是渐渐地我发现，仅仅是默默地站在旁边，关注于这些时而微小时而不可思议的改变，仰望于这些可爱的geek们为这个我所生活的世界所带来的改变时，竟也如此的让我着迷。世界在无数个不同的领域进步着，被创造着价值，而真正的价值创造者们，不是那些或许站在公司最顶端的董事们、CEO等管理者们（更确切地说他们仅仅再为他们自己以及公司创造价值），也不是那些有着诡辩的口才每天产生收入的销售者们，而是这些真正地在创造着什么的工程师，或是人们所说的杰出的程序猿们！我没有渴望说我能创造出多大的价值，但是单单想着这些竟然也能让我兴奋，难道这个不是一种不一样的感觉吗？</p>

<p>我突然发现或许我该一直做下去，就算我像梦想中所说的从40岁开始开启一个新的生活，但是也不要放弃这项事业，或者更确切地说是这种生活，以一种程序员的角度来看待这个世界，感受它的变化，感受价值的创造和创造的过程，去亲手参与到这一系列从历史长河中必定会让人们不可思议的成就，哪怕只有一点点，哪怕连所谓的一点点都没有，或者我能为我自己创造出些什么东西，以及为我周围的人。</p>

<hr />

<p>真的很惊讶而又感动于乔帮主的一生，哪怕就是感受这么一个传奇的故事也能使得全身感到兴奋，或许这就是他的魅力吧，或者一个纯粹的创造者的利益吧，无与伦比，而又无可忘怀！没有人能知道乔布斯带给我了些什么或是改变了我什么，甚至你让我说，我也说不出，道不明吧。可是那又怎样呢，我确实感觉到了自己思想中的那么一些不一样，这就够了！</p>

<p>The Journey is the Reward, 过程就是奖励，后来想想我还是蛮喜欢这句话的，比那句”那些疯狂到以为自己能够改变世界的人，才能真正改变世界“更喜欢，或许是因为它更符合我的性格吧？</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/01/06/base64bian-ma/">Base64编码</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-01-06T12:42:00+08:00" pubdate data-updated="true">Jan 6<span>th</span>, 2013</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这两天看<a href="http://www.csc.ncsu.edu/faculty/jiang/" title="Xuxian Jiang">Jiang</a>团队对<a href="http://www.csc.ncsu.edu/faculty/jiang/AnserverBot/" title="AnserverBot Malware">AnserverBot</a>的一篇详细的<a href="http://www.csc.ncsu.edu/faculty/jiang/pubs/AnserverBot_Analysis.pdf" title="AnserverBot Analysis">分析</a>中提到AnserverBot中对很多数据（比如C&amp;C server的url等）进行了Base64编码，于是，我对这种编码进行了了解，并根据他们实现的python解码脚本，写了一个ruby的解码脚本。</p>

<h4>Base64</h4>

<p>以下资料基本上来自于<a href="http://en.wikipedia.org/wiki/Base64" title="Base64">wiki</a></p>

<p>Base64用于对字符串进行编码，并将该编码通过网络传输出去，源于<code>MIME</code>内容（如邮件）的编码，用于防止内容在网络传输中被篡改。</p>

<p>接下来会通过一个示例进行说明：</p>

<p>首先我们会有一张Base64 index table:</p>

<p><img src="http://ytliu.github.com/images/2013-01-06-1.png" title="Base64 index table" alt="Base64 index table" /></p>

<p>该表记录了0-63（即000000-111111)对应的ASCII字符。</p>

<p>然后我们有一段需要翻译的字符串，一段从<a href="http://en.wikipedia.org/wiki/Thomas_Hobbes" title="Thomas Hobbes">Thomas Hobbes</a> <a href="http://en.wikipedia.org/wiki/Leviathan_book" title="Leviathan">Leviathan</a>的引用：</p>

<blockquote><p>Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.</p></blockquote>

<p>如果将每一个字母的ASCII码作为一个8-bit的二进制数展开的话会得到一个二进制串，比如我们<code>Man</code>的三个字母<code>M</code>、<code>a</code>、<code>n</code>的ASCII码分别为<code>77</code>、<code>97</code>、<code>110</code>，展开二进制并连起来既得到<code>010011010110000101101110</code>。然后我们将这个3x8的bit分成4x6，并将每6个bit组成的数字记下来，然后通过查询前面的那张<em>Base64 index table</em>即可得到四个字符<code>TWFu</code>，也就是<code>Man</code>的Base64表达形式。如下图所示：</p>

<p><img src="http://ytliu.github.com/images/2013-01-06-2.png" title="Base64 example" alt="Base64 example" /></p>

<p>当然这张<em>Base64 index table</em>可以采用任意的字母数字顺序，而不用按照这种顺序，只要解码的时候用同一张index table就可以了。</p>

<p>还有一点要注意的是如果字符的数目不是3的倍数该怎么办？也就是说最后一个block也有可能是1个字符或者2个字符。这个时候就需要在后面再加0来进行补齐了，然后再用Base64的规则进行转换，在编码后的base64文本后加上一个或两个<code>=</code>号，代表补足的字节数。也就是说，当最后剩余1个字符时，最后一个6位的base64字节块有四位是0值，最后附加上两个等号；如果最后剩余2个字符时，最后一个6位的base64字节块有两位是0值，最后附加一个等号。</p>

<h4>Base64 decode by Ruby</h4>

<p>在ruby中可以通过<code>requite 'base64'</code>来很方便地对Base64字符串进行解码，比如在AnserverBot中，采用了<code>STvJjktoVFZ9f0PGlicqy3xK7zH8ruXdn5WwDRIeb1UmEgOhYs2NpLC4QBa6AM+/_</code>的<em>index table</em>进行编码，于是ruby程序如下所示：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># decrypt str encoded by base64</span>
</span><span class='line'><span class="c1"># ARGV[0] translate command (0 for string, 1 for file)</span>
</span><span class='line'><span class="c1"># ARGV[1] translate string or file</span>
</span><span class='line'><span class="c1"># ARGV[2] my_base64chars if exist</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="nb">require</span> <span class="s1">&#39;base64&#39;</span>
</span><span class='line'>
</span><span class='line'><span class="k">BEGIN</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;Hello!</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">cmd</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="n">to_i</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="no">ARGV</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;</span> <span class="mi">2</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;Usage: ruby </span><span class="si">#{</span><span class="vg">$0</span><span class="si">}</span><span class="s2"> [0|1] [str|file] [base64chars]&quot;</span>
</span><span class='line'>  <span class="nb">exit</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">0</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'><span class="k">elsif</span> <span class="n">cmd</span> <span class="o">==</span> <span class="mi">1</span>
</span><span class='line'>  <span class="n">f</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>  <span class="n">s</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">translate string is:</span><span class="se">\n</span><span class="si">#{</span><span class="n">s</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">std_base64chars</span> <span class="o">=</span> <span class="s2">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span> <span class="o">!=</span> <span class="kp">nil</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="no">ARGV</span><span class="o">[</span><span class="mi">2</span><span class="o">].</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="mi">65</span><span class="p">)</span>
</span><span class='line'>  <span class="n">my_base64chars</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">my_base64chars</span>  <span class="o">=</span> <span class="s2">&quot;STvJjktoVFZ9f0PGlicqy3xK7zH8ruXdn5WwDRIeb1UmEgOhYs2NpLC4QBa6AM+/_&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">translate str according to </span><span class="si">#{</span><span class="n">my_base64chars</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">tr</span><span class="p">(</span><span class="n">my_base64chars</span><span class="p">,</span> <span class="n">std_base64chars</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">data</span> <span class="o">=</span> <span class="no">Base64</span><span class="o">.</span><span class="n">decode64</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">translated str is </span><span class="si">#{</span><span class="n">data</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">END</span> <span class="p">{</span> <span class="nb">puts</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Bye!&quot;</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中<code>s.tr(my_base64chars, std_base64chars)</code>是将自定义的<em>index table</em>和标准<em>index table</em>进行下转换，将字符串中的字符用标准<em>index table</em>中对应的字符进行替换，然后再通过<code>Base64.decode64(s)</code>进行解码。</p>

<p>整个过程还是很简单的。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/30/qemu-study-for-android-emulator/">Qemu Study for Android Emulator</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-30T19:10:00+08:00" pubdate data-updated="true">Dec 30<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这两天看了下android emulator的源代码，位置在<code>android-src/external/qemu</code>里面，</p>

<p>编译和启动的方式很简单；</p>

<pre><code>$ ./android-configure.sh
$ make
$ export ANDROID_SDK_ROOT=/path/to/androdi-sdk
$ emulator-arm @4.2
</code></pre>

<p>你可以对源码进行修改，然后重新编译、使用，而这里主要要讲的是qemu的运行原理，资料来源是<a href="http://lists.gnu.org/archive/html/qemu-devel/2011-04/pdfhC5rVdz7U8.pdf">Qemu detailed study</a>。要说明的一点是，android emulator原理基本上是和qemu一样的，只是加了一些android specific的东西在里面。</p>

<p>首先是qemu整体流程：</p>

<p><img src="http://ytliu.github.com/images/2012-12-30-1.png" title="qemu process" alt="qemu process" /></p>

<p>首先将guest code（这里即为arm code）被TCG（Tiny Code Generator)转换成一个中间表达，然后再转换成host code（这里即为x86 code），具体来说分为两步：</p>

<ul>
<li>一个TB（Translation Block）被翻译成TCG ops</li>
<li>TCG ops被翻译成host code</li>
</ul>


<p>我们先来看下qemu的code base：</p>

<p><img src="http://ytliu.github.com/images/2012-12-30-2.png" title="qemu code base" alt="qemu code base" /></p>

<ul>
<li><code>vl.c/vl-android.c</code>: 这个是整个qemu的入口函数，主要是初始化qemu环境，然后进入<code>main_loop</code>；</li>
<li><code>target-xyz/translate.c</code>: 将guest code翻译成TCG ops；</li>
<li><code>tcg/*/tcg-target.c</code>: 将TCG ops翻译成host code；</li>
<li><code>tcg/tcg.c</code>: TCG的主函数；</li>
<li><code>cpu-exec.c</code>: 寻找下一个TB（如果没找到则调用tcg.c生成TB），然后执行。</li>
</ul>


<p>在qemu中也很好地利用了locality，即没产生一段code（TCG ops或host code），就将其存在一个code cache中，然后用LRU进行替换。</p>

<h4>运行流程（code perspective）</h4>

<p>主要分为两部分： <em>代码生成</em>和<em>代码运行</em></p>

<h5>代码生成</h5>

<p>这是主要部分，流程是这样的：</p>

<p><img src="http://ytliu.github.com/images/2012-12-30-3.png" title="qemu process from code perspective" alt="qemu process from code perspective" /></p>

<p>其中函数<code>cpu_exec()</code>相当于主要的执行循环函数，它将TB第一次初始化，在两个嵌套无限for循环中通过<code>tb_find_fast()</code>来获得host code TB，然后通过<code>tcg_qemu_tb_exec()</code>来执行相应代码。</p>

<p><code>tb_find_fast</code>会首先查看code cache中是否有TB存在了，有则直接执行<code>tcg_qemu_tb_exec()</code>，否则通过<code>tb_find_slow()</code>来查找或者生成TB，后者通过一系列调用，最后到达<code>disas_insn()</code>，该函数执行了实际的guest code到TCG ops的翻译，并将其加入TCG ops的code buffer，最后调用<code>tcg_gen_code()</code>来生成host code。</p>

<h5>代码运行</h5>

<p>代码运行就是通过<code>tcg_qem_tb_exec()</code>来实现的，可以看到，其实这是一个宏，定义在<code>tcg/tcg.h</code>里面：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#define tcg_qemu_tb_exec(tb_ptr) \</span>
</span><span class='line'><span class="cp"> ((long REGPARM __attribute__ ((longcall)) (*)(void *))code_gen_prologue)(tb_ptr)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这是一个感觉非常复杂的调用，我们知道， <code>((long REGPARM (*)(void *))</code> 是一个指向函数的指针，<code>void *</code>是它的参数，返回值为<code>long</code>；而在这里 <code>REGPARAM(*)</code>是一个GCC选项，表示函数是通过寄存器传参而不是通过栈传参的。</p>

<p>而一个数组的名字表示的是指向这个数组的基地址，于是，<code>(function_pointer) array_name</code>则会将这个基地址cast成一个函数地址。</p>

<p>另外，一个函数可以通过<code>(*pointer_to_func)(args)</code>被调用，所以<code>((long REGPARM (*)(void *))code_gen_prologue)(tc_ptr)</code>进行了一次函数调用，似乎在这里少了一个<code>*</code>号，不过其实只要测试下可以发现 <code>(*pointer_to_func)(args)</code>和<code>(pointer_to_func)(args)</code>是一样的。</p>

<p>所以上面<code>tcg_qemu_tb_exec(tb_ptr)</code>翻译的宏可以表示为一个数组<code>code_gen_prologue</code>被cast成一个函数指针，参数为<code>tc_ptr</code>，返回值为<code>long</code>（指向下一个TB），并且被调用。其实，被<code>code_gen_prologue</code>指向的函数就是<code>Function Prologue</code>，将控制流转到<code>tc_ptr</code>指向的host code开头部分。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/20/ru-guo-ming-tian-shi-shi-jie-mo-ri/">如果明天是世界末日</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-20T21:44:00+08:00" pubdate data-updated="true">Dec 20<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>那我觉得今天过的好没意义啊。</p>

<p>早晨起床，刷牙，洗脸，拉尿，换衣服，滑轮滑去买了两个肉包，到实验室喝了杯蜂蜜水，写了两行related work，被叫去开组会，突然华为的人进来又听海波和他们讨论了一个上午，中午吃了碗和方便面长的一样但是比方便面难吃还要17块钱的“辛拉面”，回到实验室抄了两个小时的政治课笔记，莫名其妙地又待了一个小时写了几行related work，唯一还算比较有意义的就是晚上和实验室去吃了世界末日前最后一餐，回来被小呆众闺蜜调戏了一番，然后和“追梦的贱人们”聊了会儿天&#8230;然后等下又要冒着雨会寝室，洗脸洗脚，刷牙睡觉&#8230;</p>

<p>如果明天真的是世界末日的话，那这个就算我的遗嘱了吧&#8230;</p>

<p>算了，虽然懒，但是还是再加几句吧：</p>

<blockquote><p>很高兴认识你们（你们懂的），如果还有下辈子（我还是比较相信投胎一说的），我还是希望在另外一个星球遇到你们，然后和你们一起傻一起疯，一起度过最二逼的青春岁月。<br/>然后，我还要在初中遇到小呆，经过一段暧昧的光年，传递那么几封可以用来回忆当年青涩傻逼岁月的信，然后再来上那个霸气的短信“刘宇涛先生，要不我们不谈了，直接结婚吧”，再然后，度过一段充满思念的异地恋，最终在一起，每周都能见个面，开启个“相亲相爱”模式，或者偶尔听你哭一哭，安静地看着你流泪，然后来个强有力的男人的拥抱&#8230;<br/>至于读书嘛~就不读那么认真啦，多享受享受生活，把自己想做的事不管有钱没钱有时间没时间都一股脑儿挤出时间来做掉，省的又来个世界末日啥的。<br/>世界太危险，读博要谨慎啊&#8230;</p></blockquote>


<p>好了，就这些吧，让暴风雨来的更猛烈些，把这一切都冲毁吧，包括我以上那些无聊的YY&#8230;</p>

<p>还是回去早点洗洗睡了吧》》》</p>

<blockquote><p>就算世界没了，那又关我鸟事呢啦啦啦》》》</p></blockquote>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/15/dynamic-linker/">Dynamic Linker</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-15T13:03:00+08:00" pubdate data-updated="true">Dec 15<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在了解dynamic linker之前，得先对ELF文件有一个初步的了解：</p>

<p>在<a href="http://www.jollen.org/blog/2006/12/enabling_dynamic_loader_1.html" title="elf">jollen</a>的博客中有一断对ELF Session的表格:</p>

<p><img src="http://ytliu.github.com/images/2012-12-09-1.png" title="elf section" alt="elf section" /></p>

<p>很有参考价值。其中将会涉及到的sections有<em>.got</em>, <em>.plt</em>, <em>.interp</em>。</p>

<p>另外在<a href="http://www.bottomupcs.com/" title="computer science from bottom up">Computer Science from the Bottom Up</a>中有一章对dynamic linker进行了详细的说明。</p>

<p>以下的内容很多来自于该文档和俞甲子的《程序员的自我修养》一书第七章。</p>

<p>问题的产生是这样子的：当我们使用一段shared library的时候，它并没有指定说一定要把相应的代码放在哪个内存地址，而是由dynamic linker根据当前内存情况选择一段最合适的内存区域用于放置相应的code和data。那么dynamic linker是怎么做的呢？我们举一个很简单的例子来说明；</p>

<p>首先，我们编写并编译一段动态链接库lib.c, lib.h：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;lib.h&quot;;</span>
</span><span class='line'>
</span><span class='line'><span class="kt">void</span> <span class="nf">test</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;in dynamic lib, i is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">Char</span> <span class="o">*</span><span class="n">dylib</span> <span class="o">=</span> <span class="s">&quot;Test Dynamic Linker String&quot;</span><span class="p">;</span>
</span><span class='line'><span class="kt">void</span> <span class="n">test</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后将其编译为动态连接库libtest.so</p>

<pre><code>$ gcc -fPIC -shared -o libtest.so lib.c
</code></pre>

<p>这里 &#8220;-shared&#8221;表示产生共享对象，&#8221;-fPIC&#8221;表示地址无关代码，这在后面会说。</p>

<p>然后我们编写一段程序dytest.c来利用libtest.so:</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#include &quot;lib.h&quot;;</span>
</span><span class='line'>
</span><span class='line'><span class="k">extern</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dylib</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello, %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dylib</span><span class="p">);</span>
</span><span class='line'>    <span class="n">test</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</span><span class='line'>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后对其进行编译：</p>

<pre><code>$ gcc -o dytest dytest.c ./libtest.so
$ ./dytest
Hello, Test Dynamic Linker String
in dynamic lib, i is 5
</code></pre>

<p>就这么一段简单的测试代码中，动态链接是怎么完成的呢？它和静态链接有什么不同呢？</p>

<p>在静态链接中，整个程序只有一个可执行文件，在这个可执行文件中，所有变量和函数的地址都已经固定好了（这是由linker在链接时从静态链接的文件中读出来并进行地址重定位），而在动态链接中，这些地址并不会进行地址重定位。那么，链接器怎么知道一个地址是静态符号还是动态符号呢？其实在我们编译dytest的时候也将libtest.so加进去进行编译了，而在libtest.so中保存了完整的符号信息，从而linker可以知道该符号是一个动态符号。</p>

<p>既然动态链接库主要用于共享，那么有一个问题：共享对象在编译时不应该假设自己在进程虚拟地址空间中的位置。一种解决的方法是采用“装载时重定位”，但是这样有一个缺点，因为它要在程序装载时对指令部分进行修改，所以就无法使得指令部分在多个进程中共享，这样就失去了共享库的优势，另一种就是地址无关代码，它的基本想法就是把指令中那些需要修改的部分分离出来，和数据放在一起。</p>

<p>我们把地址引用分为4个部分</p>

<ul>
<li>模块内部函数调用</li>
<li>模块内部数据访问</li>
<li>模块外部数据访问</li>
<li>模块外部函数调用</li>
</ul>


<p>第一种情况应该是最简单的，因为在模块内部函数与调用者的位置是相对的，可以采取相对地址调用。</p>

<p>第二种情况同样采用相对地址的访问，这里有一个trick，就是如何得到数据地址和当前地址的相对值，俞子甲的书中介绍了一种方法(7.3节)。另外，在处理共享库的全局变量的时候，编译器都把它当作定义在其它模块的全局变量，相当于后面讲的类型三，使用GOT表。</p>

<p>第三种情况就复杂一点了，因为它要等到装载时才能决定。这里就要用到GOT（Global Offset Table）表了，ELF在数据段中建立一个指向相关地址的指针数组。对于数据变量a，在GOT表中有一个4bytes的地址项与之对应，在程序装载时，链接器会找到这个变量的地址，并将该项进行修改。</p>

<p>第四种情况和第三种类似，只是地址为函数地址。</p>

<p>其实还有第五中情况，就是模块间的全局变量，比如下面这个例子：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">extern</span> <span class="kt">int</span> <span class="n">global</span><span class="p">;</span>
</span><span class='line'><span class="kt">int</span> <span class="nf">foo</span><span class="p">()</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="n">global</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果一个定义在共享模块内部的全局变量，编译器并不知道它是否会被其它模块使用，所以当前编译器在遇到这种全局变量的时候都会把其当做定义在其它模块中的全局变量，即上面的第三种情况，使用GOT表进行访问。</p>

<p>这里还要注意一点的是，在产生地址无关代码的时候参数-fpic和-fPIC的区别，-fpic产生的代码相对较小，而且较快，但是对于一些硬件平台有一些限制。另外，它也可以被用在可执行代码上，这时，就被称为PIE（using -fPIE or -fpie）。</p>

<p>这里需要澄清的一点是，对于一个共享库lib.so来说，它在不同的进程中都有自己独立的副本，而在同个进程不同线程中则是共享的。而对于多进程共享全局变量使用的是“共享数据段”，而多线程访问不同全局变量则被称为“线程私有存储”。</p>

<p>还有，对于数据段的绝对地址引用，可以用到装载时重定位的方法来解决，即对于共享对象来说，如果数据段中有绝对地址引用，如static int *p = &amp;a，编译器和链接器会产生一个重定位表，当动态链接器装载共享对象时若发现有重定位入口，则对其进行重定位。</p>

<h4>延迟绑定（PLT）</h4>

<p>在动态链接的程序开始运行的时候都会通过动态链接器寻找并装载共享对象，但是有些函数其实可能并不会被调用。为了增加性能，会采用一种被称为PLT（Procedure Linkage Table）的方式，它的基本思想就是当函数第一次被用到时才进行绑定。它采用了一些很精巧的指令来完成:</p>

<p>每个外部函数都有一个在PLT对应的项（bar@plt)</p>

<pre><code>bar@plt:
jmp *(bar@GOT)
push n
push moduleID
jmp _dl_runtime_resolve
</code></pre>

<p>在这里第一条指令跳转到bar在GOT中的项，该项中的初始地址即为这里第二条指令（push n）的地址，相当于没有效果，然后将bar的信息和其所在模块的信息压入栈，最后调用_dl_runtim_resolve将bar真正对的地址填入到bar@GOT中，当下次真正调用bar的时候就会跳转到真正的函数地址，并返回到调用者，而不会回到<em>push n</em>的地址了。</p>

<p>ELF将GOT分成了两个表“.got&#8221;和&#8221;.got.plt&#8221;, &#8220;.got&#8221;用来保存全局变量引用地址，&#8221;.got.plt&#8221;用来保存函数引用的地址，在&#8221;.got.plt&#8221;中前三项是有特殊意义的：</p>

<ul>
<li>第一项保存&#8221;.dynamic&#8221;段的地址，这个段描述了本模块动态链接相关的信息；</li>
<li>第二项保存的是本模块的ID；</li>
<li>第三项保存的是_dl_runtime_resolve()的地址。</li>
</ul>


<p>而&#8221;.got.plt&#8221;的其余项分别对应每个外部函数的引用。</p>

<h4>动态链接相关结构</h4>

<p>在动态链接的情况下，在装载完可执行文件之后，操作系统会将控制权转交给动态链接器，动态链接器的路径在&#8221;.interp&#8221;下指定。</p>

<p>和动态链接相关的段比如说：</p>

<h5>.dynamic</h5>

<p>动态链接器中最重要的结构就是&#8221;.dynamic&#8221;段，它就像动态链接下ELF文件的”文件头“。</p>

<h5>.dynsym</h5>

<p>&#8220;.dynsym&#8221;段是为了表示模块间动态链接相关符号的导入导出关系的，当然，和&#8221;.symtab&#8221;段类似，它也需要一些辅助的表，如&#8221;.dynstr&#8221;动态符号字符串表，&#8221;.hash&#8221;符号哈希表。</p>

<h5>动态链接重定位表</h5>

<p>&#8220;rel.dyn&#8221;和&#8221;rel.plt&#8221;相当于静态链接中的&#8221;rel.data&#8221;和&#8221;rel.text&#8221;。&#8221;rel.dyn&#8221;是对数据引用的修正，它所修正的位置即&#8221;.got&#8221;以及数据段，而&#8221;.rel.plt&#8221;则是对函数引用的修正，即&#8221;.got.plt&#8221;段。</p>

<h4>动态链接的步骤和实现</h4>

<p>主要分为三步：</p>

<h5>动态链接器自举</h5>

<p>这里有两个条件：</p>

<ul>
<li>本身不可以依赖于其它任何共享对象</li>
<li>本身所需要的全局和静态变量的重定位工作由其本身完成——即“自举”</li>
</ul>


<h5>装载共享变量</h5>

<p>从全局符号表中开始寻找其所依赖的共享变量，即&#8221;.dynamic&#8221;段中一个DT_NEEDED类型，将里面提到的所有共享对象的名字放入一个装载集合中，然后从集合中一个个读取共享变量名字，找到相对应的文件，读取里面的ELF文件头和&#8221;.dynamic&#8221;段，然后将相应的代码段和数据段映射到其地址空间中，并递归地做这件事。所以当所有共享变量都被装载进来后，全局符号表里面将包含所有动态链接所需要的符号。</p>

<h4>重定向和初始化</h4>

<p>装载完成后，链接器开始重新遍历可执行文件和每个共享对象的重定向表，将其GOT/PLT中需要重定向的进行修正，然后就将控制权转交给程序的入口了。由此，动态链接也就完成了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/09/aslr-in-android/">ASLR in Android</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-09T11:07:00+08:00" pubdate data-updated="true">Dec 9<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这两篇看了两篇文章分析<a href="https://blog.duosecurity.com/2012/02/a-look-at-aslr-in-android-ice-cream-sandwich-4-0/" title="asli in 4.0">aslr in androi4.0</a>和<a href="https://blog.duosecurity.com/2012/07/exploit-mitigations-in-android-jelly-bean-4-1/" title="aslr in 4.1">android 4.1</a>，觉得蛮有趣的，这里简单介绍下。</p>

<h3>ASLR with Liux Kernel</h3>

<p>首先介绍下linux中的ASLR，ASLR可以对任意内存进行随机化：</p>

<ul>
<li>stack：The userspace stack mapping set up by the kernel during exec(2) should be sufficiently randomized. Stack randomization is performed by the randomize_stack_top() function.</li>
<li>Heap：The heap location returned by the brk(2) system call when a program is first exec’ed should be randomized. Heap randomization is performed by the arch_randomize_brk() function.</li>
<li>Libs and mmap：After NX was introduced, static library mapping led to the popularity of ret-to-libc and more generic ret-to-lib attacks. The location of libraries and other mmap’ed regions should be randomized.</li>
<li>Exec：Even if you’re randomized the mapping of all the shared libaries that an executable uses, you still need to randomize the location of the executable itself when it is mapped into the address space. Otherwise, the executable mapping can be used as a source for ROP gadgets.</li>
<li>Linker：On most Linux systems, the ld.so dynamic linker provided by glibc can self-relocate itself, so its mapping is randomized. However, as we’ll see, this isn’t the case for all linkers.</li>
<li>VDSO(Virtual Dynamically-linked Shared Object)：an executable mapping of a virtual shared library provided by the kernel for syscall transitions. However, most Android devices run on the ARM architecture, which doesn’t use a VDSO.</li>
</ul>


<h3>ASLR in Android 2.x</h3>

<p>在Android 2.x开始，唯一对ASLR支持的是stack（这可以通过多次查看/proc/pid/maps来发现），其通过load_elf_binary()函数调用randomize_stack_top()来实现：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cp">#ifndef STACK\_RND\_MASK</span>
</span><span class='line'><span class="cp">#define STACK\_RND\_MASK (0x7ff &gt;&gt; (PAGE\_SHIFT - 12)) </span><span class="cm">/* 8MB of VA */</span><span class="cp"></span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">randomize</span><span class="err">\</span><span class="n">_stack</span><span class="err">\</span><span class="n">_top</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack</span><span class="err">\</span><span class="n">_top</span><span class="p">)</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">random_variable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_RANDOMIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>              <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">ADDR_NO_RANDOMIZE</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>            <span class="n">random_variable</span> <span class="o">=</span> <span class="n">get_random_int</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">STACK_RND_MASK</span><span class="p">;</span>
</span><span class='line'>            <span class="n">random_variable</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'><span class="cp">#ifdef CONFIG\_STACK\_GROWSUP</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack</span><span class="err">\</span><span class="n">_top</span><span class="p">)</span> <span class="o">+</span> <span class="n">random_variable</span><span class="p">;</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack</span><span class="err">\</span><span class="n">_top</span><span class="p">)</span> <span class="o">-</span> <span class="n">random_variable</span><span class="p">;</span>
</span><span class='line'><span class="cp">#endif</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>ASLR in Android 4.0</h3>

<p>而在4.0，即其所谓的支持ASLR的版本上，其实ASLR也仅仅增加了对libc等一些shared libraries进行了随机化，而对于heap, executable和linker还是static的。</p>

<p>对于heap的随机化来说，可以通过</p>

<pre><code>echo 2 &gt; /proc/sys/kernel/randomize_va_space
</code></pre>

<p>来开启。</p>

<p>而对于executable的随机化，由于大部分的binary没有加GCC的-pie -fPIE选项，所以编译出来的是EXEC，而不是DYN这种shared object file，因此不是PIE（Position Independent Executable），所以没有办法随机化；</p>

<p>同样的linker也没有做到ASLR。</p>

<h3>ASLR in Android 4.1</h3>

<p>终于，在4.1 Jelly Bean中，Android终于支持了所有内存的ASLR。在第二个对4.1ASLR介绍中，作者列出了从Android 1.5开始用到的安全加强机制：</p>

<h5>Android 1.5+</h5>

<ul>
<li>ProPolice to prevent stack buffer overruns (-fstack-protector)</li>
<li>safe_iop to reduce integer overflows</li>
<li>Extensions to OpenBSD dlmalloc to prevent double free() vulnerabilities and to prevent chunk consolidation attacks. Chunk consolidation attacks are a common way to exploit heap corruption.</li>
<li>OpenBSD calloc to prevent integer overflows during memory allocation</li>
</ul>


<h5>Android 2.3+</h5>

<ul>
<li>Format string vulnerability protections (-Wformat-security -Werror=format-security)</li>
<li>Hardware-based No eXecute (NX) to prevent code execution on the stack and heap</li>
<li>Linux mmap_min_addr to mitigate null pointer dereference privilege escalation (further enhanced in Android 4.1)</li>
</ul>


<h5>Android 4.0+</h5>

<ul>
<li>Address Space Layout Randomization (ASLR) to randomize key locations in memory</li>
</ul>


<h5>Android 4.1+</h5>

<ul>
<li>PIE (Position Independent Executable) support</li>
<li>Read-only relocations / immediate binding (-Wl,-z,relro -Wl,-z,now)</li>
<li>dmesg_restrict enabled (avoid leaking kernel addresses)</li>
<li>kptr_restrict enabled (avoid leaking kernel addresses)</li>
</ul>


<p>在Android 4.1中，基本上所有binary都被编译和连接成了PIE模式（可以通过readelf查看其Type）。所以，相比于4.0，4.1对Heap，executable和linker都提供了ASLR的支持。</p>

<p>另外，4.1还增加了几个小的安全加强机制：</p>

<ul>
<li>大部分系统binary都添加了RELRO和BIND_NOW的编译flag，起作用主要是将GOT表设置成只读，防止之前出现过的<a href="http://jon.oberheide.org/files/bsides11-dontrootrobots.pdf" title="don't root robot">Gingerbreak</a>攻击。</li>
<li>另外，对dmesg_restrict / kptr_restrict的sysctl的利用，有效防止了一些低权限的用户从dmesg/klogctl中读取一些敏感信息，或者读取一些kernel内存中的敏感数据（比如很多/proc下的接口）。</li>
</ul>


<h3>What&#8217;s next</h3>

<p>之后作者还提到一些还需要继续努力的事：</p>

<ul>
<li>ASLR的弱点 - 32-bit，容易破解</li>
<li>一些安全的libc调用，比如FORTIFY_SOURCE</li>
<li>PaX Hardening，虽然很多不适合手机，但是也可以cherry pick一些啦</li>
<li>MAC/RBAC，其实这个现在也已经有了，比如SEAndroid&#8230;</li>
<li>Mandatory Code Signing，向IPhone学习吧</li>
</ul>


<p>另外，作者还提到一个Zygote的问题，为了性能问题，现在Android上所有的进程都是Zygote fork出来的，也就是说很多的地址空间在fork出来后是固定不变的，这样也就出现了一种可能性：a malicious app on a victim’s device leaks address mappings from its own process off to an attacker to assist in exploiting another process (eg. the browser) that might have higher privilege or valuable data.</p>

<p>当然，作者认为这种场景可能性比较小，所以还不算一个大问题。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/08/get-root-in-my-android/">Get Root in My Android</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-08T16:28:00+08:00" pubdate data-updated="true">Dec 8<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>首先申明，这其实并不是一篇android root教程，因为我并没有用什么exploit的方法，也没有用CWM等这些第三方ROM，而是改了ASOP，然后把它刷到机子上，然后对其进行所谓的root，装了一个dSploit和busybox。</p>

<p>具体的做法是这样的：</p>

<ul>
<li>更新到ASOP的最新版 - 4.2.4</li>
<li>lunch full-maguro, make</li>
<li>fastboot to smartphone</li>
<li>把手机连到电脑上，通过adb shell上去，进入su模式</li>
<li>通过<a href="http://www.cypherpunk.at/2011/10/08/manual-rooting-android-on-linux-2/" title="manual rooting">这里</a>的方法进行root</li>
</ul>


<p>即：</p>

<ul>
<li>mount -o remount,rw /dev/block/&#8230;/system /system</li>
<li>mv path/to/modified/su /system/xbin/su</li>
<li>mount -o remount,ro /dev/block/&#8230;/system /system</li>
</ul>


<p>但是发现失败了，我怀疑是su这个文件不兼容，于是，我想了一个更贱的方法：</p>

<ul>
<li>把ASOP代码中的/system/extras/su/su.c该掉，把检查的部分全部去掉</li>
</ul>


<p>在这里，我把</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">myuid</span> <span class="o">!=</span> <span class="n">AID_ROOT</span> <span class="o">&amp;&amp;</span> <span class="n">myuid</span> <span class="o">!=</span> <span class="n">AID_SHELL</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="s">&quot;su: uid %d not allowed to su</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">myuid</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注释掉，另外，把</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">setgid</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span> <span class="o">||</span> <span class="n">setuid</span><span class="p">(</span><span class="n">uid</span><span class="p">))</span> <span class="p">{</span>
</span></code></pre></td></tr></table></div></figure>


<p>换成了</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">if</span><span class="p">(</span><span class="n">setgid</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="n">setuid</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>然后刷机</li>
</ul>


<p>这样就直接root了！不过这只能用于我的测试机啦，正常的手机千万不敢那么做，太危险了！</p>

<hr />

<p>另外，我用了两款软件，<a href="https://github.com/evilsocket/dsploit" title="dsploit">dSploit</a>和<a href="github.com/mwrlabs/mercury" title="mercury">Mercury</a>，而且都有源码，准备之后两周研究下，学习下android编程和如何进行penetration</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/12/01/connect-smartphone-to-android-emulator/">Connect Smartphone to Android Emulator</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-12-01T15:37:00+08:00" pubdate data-updated="true">Dec 1<span>st</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这两天碰到一个难题，如何让手机中的某应用程序通过网络连接PC中的android emulator里面的服务。</p>

<p>即我在emulator里面开启了一个服务，该服务通过socket监听2012端口，那么在我的手机中，如何通过socket连接到这个服务中，也就是说，我的IP要设为什么，端口号要设为什么？</p>

<p>这个问题在于PC为emulator分配了一个端口号（这里为5554），所以在PC中可以很方便地和emulator进行交互，但是emulator并没有一个对外可见的IP地址。</p>

<p>在<a href="http://stackoverflow.com,%20stackoverflow">stackoverflow</a>上查了好久，有一个说<a href="http://stackoverflow.com/questions/7108326/how-can-we-change-the-ip-of-android-emulator">如何连接两个emulator的</a>，还有一个<a href="http://stackoverflow.com/questions/7108326/how-can-we-change-the-ip-of-android-emulator">介绍了一个非常复杂但经过我的测试有效的方法</a>。这里简单介绍一下：</p>

<h3>两个emulator相连</h3>

<p>为了两个emulator能进行网络相连，首先必须满足一下三个条件：</p>

<ul>
<li>A为PC</li>
<li>B为运行在A中的一个emulator，端口为5554</li>
<li>C为运行在A中的另一个emulator，端口为5556</li>
</ul>


<p>是不是很废话&#8230;好了，进入正题，我们要做的就是一下三步：</p>

<p>在B中起一个server，可以让C进行连接</p>

<pre><code>B listening on 10.0.2.15:80
</code></pre>

<p>telnet到B的console里面对端口进行重定向：</p>

<pre><code>$ telnet localhost 5554
# redir add tcp:8080:90
</code></pre>

<p>在C中连接10.0.2.2:8080就可以和B进行交互了。</p>

<p>这里补充一下，你如果进入adb shell在里面查看自己的IP会发现其为10.0.2.15，其通过10.0.2.2和PC进行连接。redir相当于将到达PC的8080端口的信息全部重定向到5554端口emulator的80端口。这样就完成而来emulator之间的连接了。</p>

<hr />

<h3>手机和emulator相连</h3>

<p>照理来说按照上面的说法，手机和emulator的连接应该也很简单，只需要将手机连接到PC的ip加上一个端口P1，然后将P1重定向到emulator中server监听的端口P2就可以了。</p>

<p>但是显示总是残酷的，包括redir和adb forwarding（功能似乎和redir是一样的）都只能将PC自己向端口P中写的信息forward到emulator里面的端口，而不能把其它地方从端口进来的forward。</p>

<p>于是在<a href="http://stackoverflow.com/questions/7108326/how-can-we-change-the-ip-of-android-emulator%20question">这个问题</a>的回答中提到一种方法，在中间再加一个proxy，接下来我来介绍下这种方法：</p>

<p>这是现在的框架：</p>

<p><img src="http://ytliu.github.com/images/2012-12-01-1.png" title="framework of smartphone and emulator" alt="framework" /></p>

<p>原理和两个模拟器相连很像，但是中间加了一个proxy：</p>

<ul>
<li>首先在emulator中server监听2012端口</li>
<li>在PC上通过<em>adb forward</em>命令将PC上的2012端口forward到emulator中的2012端口（<em>adb forward tcp:2012 tcp:2012</em>）</li>
<li>在proxy中将从外面来的2013端口forward到2012端口</li>
<li>而在手机端则直接向PC的2013端口发送数据</li>
</ul>


<p>经过尝试这样是可行的。</p>

<hr />

<h3>tap/tun</h3>

<p>虽然说上面的方法是可行的，但是并没有很好地解决这个问题，因为如果是通过这种方法，则我的emulator没开启一个server，都要起一个相应的proxy，这样就显得很废。有没有什么一劳永逸的方法呢？</p>

<p>听斌哥说之前他在配qemu的时候通过tap/tun的技术来配置qemu的网络，于是我也尝试着配置tap/tun，不过虽然已经将其在PC中启动好了，但是由于对其原理还是不清楚，所以还是没有搞明白要如何使得emulator有一个自己独立的对外可见的IP，这块内容可能会等自己完全搞明白了再写吧。</p>

<p>这里推荐下wikibook中对qemu networking的配置：</p>

<p>http://en.wikibooks.org/wiki/QEMU/Networking</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2012/11/25/isfjian-wen-yu-shou-huo/">ISF见闻与收获</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2012-11-25T13:03:00+08:00" pubdate data-updated="true">Nov 25<span>th</span>, 2012</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>11月22-23日两天参加了<a href="http://isf.cisrg.org/%20ISF2012">ISF2012</a>，作为一个刚刚涉入安全领域的我来说实在是收获太多，很有必要进行个比较详细的总结。</p>

<p>我想自己在这两天最大的收获在于认识了<a href="http://www.claudxiao.net/%20ClaudXiao">Claud Xiao</a>，第一天中午吃饭的时候，当发现一起聊了很久的坐在旁边吃饭的竟然是Claud的时候我瞬间就由一种穿越的感觉，前几天还在疯狂地浏览和学习他的博客，突然发现这个人就坐在我对面。他和我们讲了很多包括业界和学术界的关于安全方面的经历和事情，讲的很平易近人，而且非常的实在。这两天包括和他的聊天，还有他对很多问题的看法，甚至让我觉得他应该在安全领域做了好久了，而最后一个晚上吃饭的时候问他才知道他竟然只比我大了一岁！唉。。。差距啊。。。作为一个学术界和工业界两头都要兼顾的人，真的很不容易吧，而他对于学习新的事物又是那么的渴望而又充满激情，实在是钦佩。在这里真的很推荐他的<a href="http://www.claudxiao.net/%20IClaud">博客</a>，这几天从那里学到好多东西。</p>

<p>还有在这两天与交大的gossip组和港中文的两个博士（sbark和茗坤）也聊了很多，发现他们在代码的静态和动态分析这块领域真的专的蛮深的，和他们一起聊这块东西感觉很多时候我们都插不上话，而只是默默地倾听和学习。和他们的聊天中发现他们对于这方面的东西如数家珍，能够非常融会贯通地聊，而很多东西在我看来听起来很熟悉，但是却时常不能将人与事物，名称和做的东西联系起来，实在是惭愧。</p>

<p>另外还见到了Seak江海客，真的是一个很有性格的boss，背着一个改造过的超大的登山包，操作着巨大的笔记本工作站，还在下面垫两块“水冷”装置，而且还有无时不刻的工作状态，感觉非常的潇洒和陶醉。还有会议的组织者Billy，真的是一个非常感性的人，充满激情，而且为人豪爽。让我感觉在他们安天的团队里一定是非常的惬意的。</p>

<p>当然了，还听了好多精彩的演讲，Seak、360的赵武、武大的玉如&#8230;这里简单地介绍下我都学到了哪些东西吧，当然了有一个最遗憾的事就是没有听到Claud的演讲，竟然被万恶地调到了周五的上午，太可惜了，估计只能看看slide了。</p>

<hr />

<h4>11月22日</h4>

<p>降速的发动机 —— 安全设备第三方AV引擎开发者的反思 by Seak</p>

<p>其实这个更像是Seak从反病毒厂商的角度出发的一篇反思的文章，讲的非常的好，而且很实在。他从“我们做了什么”、“我们仿佛为你做了这件事”、“我们拒绝做哪些”、“我们给你找了这些麻烦”、“我知道你不知道我知道的事”这几点出发，提出AV领域冗长和保守这么一点，并且和我们分享了许多现在杀毒厂商的许多做法，比如我们似乎很熟悉其实却并不了解的包过滤、云查杀、多线程支持、脱壳功能、对照扫描、行为分析等一系列话题，非常有收获。</p>

<p>而且我觉得Seak在之后的问答环节中对提问者的回答也非常的有条理和清晰，而且很实在，并不会有什么夸夸其谈，真的是一个大牛风范啊~</p>

<hr />

<p>未知感知——安全领域不可回避的挑战 by 武大</p>

<p>这个是由武大的梁博士和玉如两个人做的talk，主要是介绍他们之前和现在做的一些工作，我比较感兴趣的是玉如讲的对于android的研究，特别是他提到的LBE，这个公司之前我们都没有关注过，而似乎和我们关系很大，而且听Claud说这个属于一个高帅富团队，做的东西真的是蛮不错的，我向他们要了一份LBE最初版本的apk想来研究看看。从代码入手会深入很多吧。</p>

<hr />

<p>智能电话和平板电脑的信息安全现状以及对策</p>

<p>这个本来是由日本的西本逸郎来说的，后来他有事情没来，就由以为很和蔼的爷爷代替了，说的主要是日本相关的一些和智能相关的话题，比如他提到的恐怖事件（开发者机器被控制，应用程序自动窃取用户隐私数据；或者远程控制在bbs上发布恐怖信息）等，之后还提到了现实生活中和智能相关的话题和需求，比如（个人不希望携带多台设备；企业希望实现系统云计算化）等等。讲的还是比较泛，没有学到太多的东西，就当了解下异国文化吧。</p>

<hr />

<p>中国网站安全状况和解决方案 by 360赵武</p>

<p>这个报告讲的还是很有意思的，发现360的人其实还是做了挺多东西的，而且让我了解到目前网站这个市场上的一些黑幕和现状。我觉得他有一句话讲的很有道理，他说对于现在的网站或者企业来说，安全不是他们的硬需求！大家都知道现在网络非常危险，可是如果我连盈利都还没有开始盈利，又有谁会真正去care安全呢？</p>

<p>而现在网站面临这一系列的危险，比如网站勒索, 中国站长不懂技术，不懂安全，只会赚钱，网站管理员拥有一切，除了他的网站，还有一系列的攻击：挂马、篡改、黑链、后门、DDoS、钓鱼…而这些安全隐患由于一些主要矛盾的存在：</p>

<ul>
<li>巨大需求 - 高昂的成本</li>
<li>安全技能需求 - 网站业务发展重点</li>
<li>安全产品形式 - 网站需求</li>
</ul>


<p>使得现在的安全真的很不好做。</p>

<p>后来赵老师还提到他觉得现在互联网最大的软肋在于DNS，虽然我对此不是很赞同，不过DNS确实很危险，非常容易被攻击者所利用。</p>

<hr />

<h4>11月23日</h4>

<p>非常遗憾上午没去，所以没有听到Sbark和Claud的演讲，下午的演讲听起来没有第一天那么有意思，就没有做太多的笔记了。</p>

<hr />

<p>这两天的会开下来，让我真真切切感受到自己对于安全这一块还是多么的不了解，还有太多的东西需要去学习。</p>

<p>我现在希望自己从Claud还没写完的一本书开始，从静态和动态分析开始学习，学着去对malware进行分析，学习ded/smali/wireshark/metasploit等分析和追踪工具，把一些比较理论的东西在现实中进行尝试。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/3/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/04/30/xi-tong-diao-yong-xue-xi-bi-ji-%28%5B%3F%5D-%29-linuxxi-tong-diao-yong-biao-%28zhuan-%29/">系统调用学习笔记（一） - Linux系统调用表（转）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/04/30/xi-tong-diao-yong-xue-xi-bi-ji-ptrace/">系统调用学习笔记 - ptrace</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/04/14/tong-bu-yuan-yu-xue-xi-bi-ji-lock%2Crcuhe-transaction/">同步原语学习笔记 - Lock，RCU和Transaction Memory</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/04/09/netfilterxue-xi-bi-ji-%28san-%29/">Netfilter学习笔记（三）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/03/29/netfilterxue-xi-bi-ji-%28er-%29/">Netfilter学习笔记（二）</a>
      </li>
    
  </ul>
</section>


<section>
  <h1>Latest Tweets</h1>
  <ul id="tweets">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  <script type="text/javascript">
    $.domReady(function(){
      getTwitterFeed("microtrain016", 4, false);
    });
  </script>
  <script src="/javascripts/twitter.js" type="text/javascript"> </script>
  
    <a href="http://twitter.com/microtrain016" class="twitter-follow-button" data-show-count="false">Follow @microtrain016</a>
  
</section>



<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/mctrain016@gmail.com?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Liu Yutao -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
